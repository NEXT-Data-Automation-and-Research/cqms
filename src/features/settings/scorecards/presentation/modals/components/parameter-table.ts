/**
 * Parameter Table Component
 * Manages the error parameters table in create/edit modals
 */

import { safeSetHTML, safeSetTableBodyHTML, escapeHtml } from '../../../../../../utils/html-sanitizer.js';
import type { ScorecardParameter, ParameterType, FieldType, ErrorCategory } from '../../../domain/entities.js';
import { ParameterRow } from './parameter-row.js';
import {
  getDefaultParameterType,
  getDefaultFieldType,
  getAvailableParameterTypes,
  getAvailableFieldTypes
} from '../utils/parameter-utils.js';

export class ParameterTable {
  private container: HTMLElement | null;
  private parameters: ScorecardParameter[] = [];
  private scoringType: string = 'deductive';

  constructor(containerId: string) {
    this.container = document.getElementById(containerId);
  }

  /**
   * Set scoring type (affects available parameter types and field types)
   */
  setScoringType(scoringType: string): void {
    this.scoringType = scoringType;
    this.render();
  }

  /**
   * Add a new parameter row
   */
  addParameter(): void {
    const newParam: ScorecardParameter = {
      scorecard_id: '',
      error_name: '',
      penalty_points: 0,
      parameter_type: getDefaultParameterType(this.scoringType),
      error_category: 'Minor Error',
      field_type: getDefaultFieldType(this.scoringType),
      field_id: ParameterRow.generateFieldId(''),
      description: '',
      enable_ai_audit: false,
      is_fail_all: false
    };
    this.parameters.push(newParam);
    this.render();
  }

  /**
   * Remove a parameter by index
   */
  removeParameter(index: number): void {
    if (index >= 0 && index < this.parameters.length) {
      this.parameters.splice(index, 1);
      this.render();
    }
  }

  /**
   * Get all parameters
   */
  getParameters(): ScorecardParameter[] {
    return this.parameters;
  }

  /**
   * Set parameters
   */
  setParameters(parameters: ScorecardParameter[]): void {
    this.parameters = [...parameters];
    this.render();
  }


  /**
   * Render parameter table
   */
  render(): void {
    if (!this.container) return;

    const rowsHTML = this.parameters.map((param, index) => ParameterRow.render(param, index, this.scoringType)).join('');

    // Render rows directly into container div using safeSetHTML
    // Parameters are rendered as divs with class "parameter-row", not table rows
    const emptyMessage = '<div class="parameter-row" style="grid-column: 1 / -1; text-align: center; padding: 1rem; color: #6b7280;">No parameters added. Click "+ Add One" to add a parameter.</div>';
    safeSetHTML(this.container as HTMLElement, rowsHTML || emptyMessage);
    
    this.attachRowListeners();
  }


  /**
   * Attach event listeners to parameter rows
   */
  private attachRowListeners(): void {
    if (!this.container) return;

    // Add One button
    const addBtn = this.container.querySelector('#parameterAddOneBtn');
    if (addBtn) {
      addBtn.addEventListener('click', () => this.addParameter());
    }

    // Remove buttons
    this.container.querySelectorAll('.parameter-remove-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const index = parseInt((e.target as HTMLElement).closest('[data-index]')?.getAttribute('data-index') || '-1', 10);
        if (index >= 0) {
          this.removeParameter(index);
        }
      });
    });

    // Name input - auto-generate field ID
    this.container.querySelectorAll('.parameter-name-input').forEach(input => {
      input.addEventListener('input', (e) => {
        const index = parseInt((e.target as HTMLInputElement).getAttribute('data-index') || '-1', 10);
        const name = (e.target as HTMLInputElement).value;
        if (index >= 0 && this.parameters[index]) {
          this.parameters[index].error_name = name;
          const fieldIdInput = this.container?.querySelector(`.parameter-field-id-input[data-index="${index}"]`) as HTMLInputElement;
          if (fieldIdInput) {
            const isAutoGenerated = fieldIdInput.dataset.autoGenerated === 'true';
            const originalValue = fieldIdInput.dataset.originalValue || '';
            
            // Only auto-fill if field_id is empty or was auto-generated
            if (!fieldIdInput.value.trim() || isAutoGenerated || (originalValue && fieldIdInput.value === originalValue)) {
              const newFieldId = ParameterRow.generateFieldId(name);
              fieldIdInput.value = newFieldId;
              fieldIdInput.dataset.autoGenerated = 'true';
              this.parameters[index].field_id = newFieldId;
            }
          }
        }
      });
    });

    // Update parameter data on input changes
    this.container.querySelectorAll('.parameter-points-input').forEach(input => {
      input.addEventListener('input', (e) => {
        const index = parseInt((e.target as HTMLInputElement).getAttribute('data-index') || '-1', 10);
        const value = parseFloat((e.target as HTMLInputElement).value) || 0;
        if (index >= 0 && this.parameters[index]) {
          this.parameters[index].penalty_points = value;
        }
      });
    });

    this.container.querySelectorAll('.parameter-type-select').forEach(select => {
      select.addEventListener('change', (e) => {
        const index = parseInt((e.target as HTMLSelectElement).getAttribute('data-index') || '-1', 10);
        const value = (e.target as HTMLSelectElement).value as ParameterType;
        if (index >= 0 && this.parameters[index]) {
          this.parameters[index].parameter_type = value;
          // Update field type based on parameter type and scoring type
          const fieldTypes = getAvailableFieldTypes(value, this.scoringType);
          if (fieldTypes.length > 0 && !fieldTypes.includes(this.parameters[index].field_type)) {
            this.parameters[index].field_type = fieldTypes[0];
          }
          this.render(); // Re-render to update field type options
        }
      });
    });

    this.container.querySelectorAll('.parameter-category-select').forEach(select => {
      select.addEventListener('change', (e) => {
        const index = parseInt((e.target as HTMLSelectElement).getAttribute('data-index') || '-1', 10);
        const value = (e.target as HTMLSelectElement).value;
        if (index >= 0 && this.parameters[index]) {
          this.parameters[index].error_category = value;
        }
      });
    });

    this.container.querySelectorAll('.parameter-field-type-select').forEach(select => {
      select.addEventListener('change', (e) => {
        const index = parseInt((e.target as HTMLSelectElement).getAttribute('data-index') || '-1', 10);
        const value = (e.target as HTMLSelectElement).value as FieldType;
        if (index >= 0 && this.parameters[index]) {
          this.parameters[index].field_type = value;
        }
      });
    });

    this.container.querySelectorAll('.parameter-field-id-input').forEach(input => {
      input.addEventListener('input', (e) => {
        const index = parseInt((e.target as HTMLInputElement).getAttribute('data-index') || '-1', 10);
        const value = (e.target as HTMLInputElement).value.trim();
        if (index >= 0 && this.parameters[index]) {
          this.parameters[index].field_id = value;
          // If user manually edits, mark as not auto-generated
          (e.target as HTMLInputElement).dataset.autoGenerated = 'false';
        }
      });
    });

    this.container.querySelectorAll('.parameter-description-input').forEach(input => {
      input.addEventListener('input', (e) => {
        const index = parseInt((e.target as HTMLInputElement).getAttribute('data-index') || '-1', 10);
        const value = (e.target as HTMLInputElement).value;
        if (index >= 0 && this.parameters[index]) {
          this.parameters[index].description = value || null;
        }
      });
    });

    this.container.querySelectorAll('.parameter-ai-audit-checkbox').forEach(checkbox => {
      checkbox.addEventListener('change', (e) => {
        const index = parseInt((e.target as HTMLInputElement).getAttribute('data-index') || '-1', 10);
        const checked = (e.target as HTMLInputElement).checked;
        if (index >= 0 && this.parameters[index]) {
          this.parameters[index].enable_ai_audit = checked;
        }
      });
    });

    this.container.querySelectorAll('.parameter-fatal-error-checkbox').forEach(checkbox => {
      checkbox.addEventListener('change', (e) => {
        const index = parseInt((e.target as HTMLInputElement).getAttribute('data-index') || '-1', 10);
        const checked = (e.target as HTMLInputElement).checked;
        if (index >= 0 && this.parameters[index]) {
          this.parameters[index].is_fail_all = checked;
        }
      });
    });
  }
}

