<!DOCTYPE html>
<html lang="en">
<head>
<script src="/js/console-stub.js"></script>
<meta charset="UTF-8">
<title>Home | QMS</title>
<meta name="description" content="Quality Management System Dashboard">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAtOTYwIDk2MCA5NjAiIHdpZHRoPSIyNHB4IiBmaWxsPSIjMWY5ZTRiIj48cGF0aCBkPSJNMjAwLTEyMHEtMzMgMC01Ni41LTIzLjVUMTIwLTIwMHYtNTYwcTAtMzMgMjMuNS01Ni41VDIwMC04NDBoNTYwcTMzIDAgNTYuNSAyMy41VDg0MC03NjB2NTYwcTAgMzMtMjMuNSA1Ni41VDc2MC0xMjBIMjAwWm00OTEtODBoNjl2LTY5bC02OSA2OVptLTQ1NyAwaDczbDEyMC0xMjBoODVMNDUyLTIwMGg2NGwxMjAtMTIwaDg1TDU0MS0yMDBoNjVsMTIwLTEyMGgzNHYtNDQwSDIwMHY1MDlsNjktNjloODVMNDM0LTIwMFptNzItMjAwLTU2LTU2IDE3Ny0xNzcgODAgODAgMTQ3LTE0NyA1NiA1Ni0yMDMgMjA0LTgwLTgwLTEyMSAxMjBaIi8+PC9zdmc+">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <noscript><link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet"></noscript>
    
    <!-- CSS Loading Order (following documented architecture pattern) -->
    <link rel="stylesheet" href="/styles.css">                   <!-- 0. Tailwind CSS (compiled) -->
    <link rel="stylesheet" href="/theme.css">                    <!-- 1. Global CSS variables & base styles -->
    <link rel="stylesheet" href="/sidebar.css">                  <!-- 2. Layout system (sidebar & main-content) -->
    <link rel="stylesheet" href="/home-page.css">                <!-- 3. Page-specific styles -->
    <link rel="stylesheet" href="/home-page-inline.css">        <!-- 4. Additional inline styles -->
    
    <!-- Import map for npm packages in browser -->
    <script type="importmap">
    {
      "imports": {
        "loglevel": "https://cdn.jsdelivr.net/npm/loglevel@1.9.1/+esm",
        "@supabase/supabase-js": "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.0/+esm",
        "dompurify": "https://cdn.jsdelivr.net/npm/dompurify@3.3.1/+esm"
      }
    }
    </script>
    
<!-- Tailwind CSS is compiled via CLI into /public/styles.css; no CDN script needed in production -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <!-- Authentication Guard - Must be loaded first -->
    <script type="module" src="/js/auth-checker.js"></script>
    
    <!-- Supabase and utility scripts -->
    <!-- Load timezone utilities FIRST - required for dashboard initialization -->
    <script type="module" src="/js/utils/timezone-utils.js" defer></script>
    
    <!-- Fallback date utilities - set up immediately before any other scripts -->
    <script>
      // Set up fallback date utilities if not already loaded
      // These will be overridden by timezone-utils.js when it loads
      if (!window.getDhakaNow) {
        window.getDhakaNow = () => new Date();
      }
      if (!window.getDhakaStartOfDay) {
        window.getDhakaStartOfDay = (date) => {
          const d = date ? new Date(date) : new Date();
          d.setHours(0, 0, 0, 0);
          return d;
        };
      }
      if (!window.getDhakaEndOfDay) {
        window.getDhakaEndOfDay = (date) => {
          const d = date ? new Date(date) : new Date();
          d.setHours(23, 59, 59, 999);
          return d;
        };
      }
      if (!window.getDhakaFirstDayOfMonth) {
        window.getDhakaFirstDayOfMonth = (date) => {
          const d = new Date(date);
          d.setDate(1);
          d.setHours(0, 0, 0, 0);
          return d;
        };
      }
      if (!window.getDhakaLastDayOfMonth) {
        window.getDhakaLastDayOfMonth = (date) => {
          const d = new Date(date);
          d.setMonth(d.getMonth() + 1);
          d.setDate(0);
          d.setHours(23, 59, 59, 999);
          return d;
        };
      }
      if (!window.formatDhakaDateForInput) {
        window.formatDhakaDateForInput = (date) => {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          return `${year}-${month}-${day}`;
        };
      }
      if (!window.parseDhakaDate) {
        window.parseDhakaDate = (dateString) => new Date(dateString);
      }
      if (!window.formatDhakaDate) {
        window.formatDhakaDate = (date, options) => {
          const defaultOptions = { year: 'numeric', month: 'short', day: 'numeric', ...options };
          return date.toLocaleDateString('en-US', defaultOptions);
        };
      }
      if (!window.dhakaDateToUTCISO) {
        window.dhakaDateToUTCISO = (date) => {
          const utcTime = date.getTime() - (6 * 3600000);
          return new Date(utcTime).toISOString();
        };
      }
      if (!window.getDhakaWeekNumber) {
        window.getDhakaWeekNumber = (date) => {
          const oneJan = new Date(date.getFullYear(), 0, 1);
          const numberOfDays = Math.floor((date.getTime() - oneJan.getTime()) / (24 * 60 * 60 * 1000));
          return Math.ceil((numberOfDays + oneJan.getDay() + 1) / 7);
        };
      }
      if (!window.getDhakaWeekDates) {
        window.getDhakaWeekDates = (weekNumber, year) => {
          const oneJan = new Date(year, 0, 1);
          const daysOffset = (weekNumber - 1) * 7;
          const startDate = new Date(oneJan);
          startDate.setDate(oneJan.getDate() + daysOffset - oneJan.getDay());
          const endDate = new Date(startDate);
          endDate.setDate(startDate.getDate() + 6);
          return { start: startDate, end: endDate };
        };
      }
      if (!window.toDhakaTime) {
        window.toDhakaTime = (utcString) => {
          const utcDate = new Date(utcString);
          return new Date(utcDate.getTime() + (6 * 3600000));
        };
      }
      
      // Make functions available globally without window prefix for backward compatibility
      const getDhakaNow = window.getDhakaNow;
      const getDhakaStartOfDay = window.getDhakaStartOfDay;
      const getDhakaEndOfDay = window.getDhakaEndOfDay;
      const getDhakaFirstDayOfMonth = window.getDhakaFirstDayOfMonth;
      const getDhakaLastDayOfMonth = window.getDhakaLastDayOfMonth;
      const formatDhakaDateForInput = window.formatDhakaDateForInput;
      const parseDhakaDate = window.parseDhakaDate;
      const formatDhakaDate = window.formatDhakaDate;
      const dhakaDateToUTCISO = window.dhakaDateToUTCISO;
      const getDhakaWeekNumber = window.getDhakaWeekNumber;
      const getDhakaWeekDates = window.getDhakaWeekDates;
      const toDhakaTime = window.toDhakaTime;
    </script>
    
    <!-- Initialize Supabase FIRST before any components load -->
    <script type="module" defer>
      import { initSupabase } from '/js/utils/supabase-init.js';
      import { getSecureSupabase } from '/js/utils/secure-supabase.js';
      
      // Initialize Supabase immediately when page loads
      (async function initSupabaseFirst() {
        try {
          // Initialize base Supabase client
          await initSupabase();
          
          // Set up secure client on window.supabaseClient (required by DatabaseFactory)
          const secureClient = await getSecureSupabase(false); // Don't require auth initially (will check on each DB op)
          window.supabaseClient = secureClient;
          
          // Signal that Supabase is ready
          window.supabaseReady = true;
          window.dispatchEvent(new CustomEvent('supabaseReady'));
        } catch (error) {
          // Error logged by initSupabase/getSecureSupabase
        }
      })();
    </script>
    
    <!-- Sidebar Loader -->
    <script type="module" src="/js/load-sidebar.js" defer></script>
<style>
  /* Additional page-specific styles */
  /* Note: Main layout styles are in home-page-inline.css */
  
  /* Override sidebar.css centering for home page - constrain to 80vw */
  .main-content > * {
    width: 100%;
    max-width: var(--home-max-width, 80vw);
    margin-left: auto;
    margin-right: auto;
  }

  /* Screenshot Color Matching - Green Primary Color */
  :root {
    --primary-green: #1a733e; /* Dark green theme color */
    --primary-green-dark: #0d5e3a; /* Darker green for hover */
    --primary-green-light: #e8f5e9; /* Light green for backgrounds */
  }

  /* Primary color overrides to match screenshot */
  .bg-primary {
    background-color: var(--primary-green) !important;
  }
  
  .text-primary {
    color: var(--primary-green) !important;
  }
  
  .border-primary {
    border-color: var(--primary-green) !important;
  }
  
  .bg-primary\/10 {
    background-color: rgba(26, 115, 62, 0.1) !important;
  }
  
  .bg-primary\/20 {
    background-color: rgba(26, 115, 62, 0.2) !important;
  }
  
  .hover\:bg-primary-dark:hover {
    background-color: var(--primary-green-dark) !important;
  }


  /* Green QUALITY ANALYST badge */
  #dashboardUserRole {
    background-color: var(--primary-green) !important;
    color: white !important;
  }

  /* Icon colors to match screenshot */
  .text-primary svg,
  svg.text-primary {
    color: var(--primary-green) !important;
  }

  /* Green button matching screenshot */
  .btn-primary-action,
  .view-all-btn,
  #createAuditBtn {
    background-color: var(--primary-green) !important;
    color: white !important;
  }
  
  .btn-primary-action:hover,
  .view-all-btn:hover,
  #createAuditBtn:hover {
    background-color: var(--primary-green-dark) !important;
  }

  /* Week display button - green background */
  .week-display {
    background-color: var(--primary-green) !important;
    color: white !important;
  }

  /* Active quick date button */
  .quick-date-btn.active {
    background-color: var(--primary-green) !important;
    color: white !important;
    border-color: var(--primary-green) !important;
  }

  /* Progress bar - green */
  .progress-bar {
    background-color: var(--primary-green) !important;
  }

  /* Success color adjustments */
  .text-success {
    color: var(--primary-green) !important;
  }
  
  .bg-success\/10 {
    background-color: rgba(26, 115, 62, 0.1) !important;
  }
  
  .bg-success\/20 {
    background-color: rgba(26, 115, 62, 0.2) !important;
  }

  /* In Progress card icon - green lightning */
  #inProgressCard .text-primary {
    color: var(--primary-green) !important;
  }

  /* Avg Duration card icon - green */
  #avgDurationCard .text-primary {
    color: var(--primary-green) !important;
  }

  /* Ensure cards have proper white background and gray borders */
  .bg-white {
    background-color: #ffffff !important;
  }
  
  .border-gray-200 {
    border-color: #e5e7eb !important;
  }

  /* Text colors matching screenshot */
  .text-gray-900 {
    color: #111827 !important;
  }
  
  .text-gray-600 {
    color: #4b5563 !important;
  }
  
  .text-gray-500 {
    color: #6b7280 !important;
  }

  /* Loading optimization - show skeleton immediately */
  .animate-pulse {
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }
  
  @keyframes pulse {
    0%, 100% {
      opacity: 1;
    }
    50% {
      opacity: .5;
    }
  }

  /* Date Range Picker and Filter Styles */
  .header-actions {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    align-items: center;
    margin-bottom: 1rem;
  }

  .action-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.375rem;
    padding: 0.5rem 0.75rem;
    background-color: white;
    color: #374151;
    border: 1px solid #e5e7eb;
    border-radius: 0.375rem;
    font-size: 0.75rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: 'Poppins', sans-serif;
  }

  .action-btn:hover {
    background-color: #f9fafb;
    border-color: #1a733e;
  }

  .action-btn.active {
    background-color: #1a733e;
    color: white;
    border-color: #1a733e;
  }

  .action-btn svg {
    width: 0.875rem;
    height: 0.875rem;
  }

  /* Filter Panel */
  .filter-panel {
    display: none;
    background: #f9fafb;
    border: 1px solid #e5e7eb;
    border-radius: 0.375rem;
    padding: 1rem;
    margin-bottom: 1rem;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 0.75rem;
  }

  .filter-panel.active {
    display: grid;
  }

  .filter-group {
    display: flex;
    flex-direction: column;
    gap: 0.375rem;
  }

  .filter-label {
    font-size: 0.625rem;
    font-weight: 600;
    color: #6b7280;
  }

  .filter-input, .filter-select {
    padding: 0.375rem 0.5rem;
    border: 1px solid #e5e7eb;
    border-radius: 0.25rem;
    font-size: 0.75rem;
    font-family: 'Poppins', sans-serif;
    background-color: white;
    color: #374151;
  }

  .filter-input:focus, .filter-select:focus {
    outline: none;
    border-color: #1a733e;
  }

  /* Date Range Picker */
  .date-picker-dropdown {
    position: relative;
    display: inline-block;
  }

  .date-dropdown-menu {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    margin-top: 0.375rem;
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 0.375rem;
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    padding: 0.75rem;
    z-index: 1000;
    min-width: 250px;
  }

  .date-dropdown-menu.active {
    display: block !important;
  }
  
  /* Ensure dropdown is hidden by default */
  .date-dropdown-menu:not(.active) {
    display: none !important;
  }

  /* Dark Mode Styles */
  [data-theme="dark"] .main-content {
    background-color: var(--background-color);
  }

  [data-theme="dark"] .action-btn {
    background-color: var(--background-white);
    color: var(--text-color);
    border-color: var(--border-light);
  }

  [data-theme="dark"] .action-btn:hover {
    background-color: var(--gray-100);
    border-color: var(--primary-color);
  }

  [data-theme="dark"] .action-btn.active {
    background-color: #1a733e !important;
    color: white !important;
    border-color: #1a733e !important;
  }

  [data-theme="dark"] .filter-panel {
    background: var(--gray-100);
    border-color: var(--border-light);
  }

  [data-theme="dark"] .filter-label {
    color: var(--text-secondary);
  }

  [data-theme="dark"] .filter-input,
  [data-theme="dark"] .filter-select {
    background-color: var(--background-white);
    color: var(--text-color);
    border-color: var(--border-light);
  }

  [data-theme="dark"] .date-dropdown-menu {
    background: var(--background-white);
    border-color: var(--border-light);
    box-shadow: var(--shadow-lg);
  }

  /* Dark Mode Overrides for Tailwind Classes */
  [data-theme="dark"] .bg-white {
    background-color: var(--background-white) !important;
  }

  [data-theme="dark"] .border-gray-200 {
    border-color: var(--border-light) !important;
  }

  [data-theme="dark"] .text-gray-900 {
    color: var(--text-color) !important;
  }

  [data-theme="dark"] .text-gray-800 {
    color: var(--text-color) !important;
  }

  [data-theme="dark"] .text-gray-600 {
    color: var(--text-secondary) !important;
  }

  [data-theme="dark"] .text-gray-500 {
    color: var(--text-muted) !important;
  }

  [data-theme="dark"] .bg-gray-200 {
    background-color: var(--gray-200) !important;
  }

  [data-theme="dark"] .bg-gray-100 {
    background-color: var(--gray-100) !important;
  }

  [data-theme="dark"] .border-gray-200 {
    border-color: var(--border-light) !important;
  }

  [data-theme="dark"] .divide-gray-200 > * {
    border-color: var(--border-light) !important;
  }

  [data-theme="dark"] .divide-gray-200 > * + * {
    border-top-color: var(--border-light) !important;
  }

  [data-theme="dark"] .hover\:bg-gray-100:hover {
    background-color: var(--gray-100) !important;
  }

  [data-theme="dark"] .hover\:text-gray-900:hover {
    color: var(--text-color) !important;
  }

  [data-theme="dark"] .text-gray-400 {
    color: var(--text-muted) !important;
  }

  [data-theme="dark"] .hover\:text-gray-600:hover {
    color: var(--text-secondary) !important;
  }

  /* Loading spinner dark mode */
  [data-theme="dark"] .animate-spin circle {
    stroke: var(--text-color) !important;
  }

  [data-theme="dark"] .animate-spin path {
    fill: var(--text-color) !important;
  }

  /* Disabled button states in dark mode */
  [data-theme="dark"] .action-btn:disabled {
    background-color: var(--gray-100) !important;
    color: var(--text-muted) !important;
    border-color: var(--border-light) !important;
  }

  [data-theme="dark"] .text-gray-300 {
    color: var(--text-muted) !important;
  }

  [data-theme="dark"] .text-gray-700 {
    color: var(--text-secondary) !important;
  }

  [data-theme="dark"] .border-gray-100 {
    border-color: var(--border-light) !important;
  }

  [data-theme="dark"] .hover\:bg-gray-50:hover {
    background-color: var(--gray-100) !important;
  }

  [data-theme="dark"] .bg-gray-50 {
    background-color: var(--gray-100) !important;
  }

  [data-theme="dark"] .bg-yellow-100 {
    background-color: rgba(251, 191, 36, 0.2) !important;
  }

  [data-theme="dark"] .text-yellow-800 {
    color: #fbbf24 !important;
  }

  [data-theme="dark"] .bg-green-100 {
    background-color: rgba(16, 185, 129, 0.2) !important;
  }

  [data-theme="dark"] .text-green-800 {
    color: #10b981 !important;
  }

  [data-theme="dark"] .bg-red-100 {
    background-color: rgba(239, 68, 68, 0.2) !important;
  }

  [data-theme="dark"] .text-red-800 {
    color: #ef4444 !important;
  }

  /* User Profile Dropdown Dark Mode */
  [data-theme="dark"] #userProfileDropdown {
    background-color: var(--background-white);
    border-color: var(--border-light);
  }

  [data-theme="dark"] #userProfileDropdown .border-gray-200 {
    border-color: var(--border-light) !important;
  }

  [data-theme="dark"] #userProfileDropdown .bg-gray-50 {
    background-color: var(--gray-50) !important;
  }

  [data-theme="dark"] #userProfileDropdown .text-gray-900 {
    color: var(--text-color) !important;
  }

  [data-theme="dark"] #userProfileDropdown .text-gray-600 {
    color: var(--text-secondary) !important;
  }

  [data-theme="dark"] #userProfileDropdown .text-gray-500 {
    color: var(--text-muted) !important;
  }

  [data-theme="dark"] #userProfileDropdown .from-primary\/5 {
    background: linear-gradient(to right, rgba(26, 115, 62, 0.1), rgba(26, 115, 62, 0.15)) !important;
  }

  /* Ultra-Compact Profile Animation */
  @keyframes slideInFromTop {
    from {
      opacity: 0;
      transform: translateY(-5px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  #userProfileDashboard {
    animation: slideInFromTop 0.3s ease-out;
  }

  /* Dark Mode Profile Dashboard */
  [data-theme="dark"] #userProfileDashboard .bg-white {
    background-color: var(--card-bg) !important;
  }

  [data-theme="dark"] #userProfileDashboard .border-gray-200,
  [data-theme="dark"] #userProfileDashboard .border-gray-100 {
    border-color: var(--border-color) !important;
  }

  [data-theme="dark"] #userProfileDashboard .text-gray-900 {
    color: var(--text-color) !important;
  }

  [data-theme="dark"] #userProfileDashboard .text-gray-600 {
    color: var(--text-secondary) !important;
  }

  [data-theme="dark"] #userProfileDashboard .text-gray-400 {
    color: var(--text-muted) !important;
  }
  
  [data-theme="dark"] #userProfileDashboard .bg-blue-50,
  [data-theme="dark"] #userProfileDashboard .bg-purple-50,
  [data-theme="dark"] #userProfileDashboard .bg-green-50,
  [data-theme="dark"] #userProfileDashboard .bg-orange-50,
  [data-theme="dark"] #userProfileDashboard .bg-amber-50,
  [data-theme="dark"] #userProfileDashboard .bg-indigo-50 {
    background-color: rgba(255, 255, 255, 0.05) !important;
  }

  [data-theme="dark"] #userProfileDashboard .text-gray-400 {
    color: var(--text-muted) !important;
  }

  [data-theme="dark"] #userProfileDashboard .bg-gray-300 {
    background-color: var(--border-light) !important;
  }

  [data-theme="dark"] #userProfileDashboard .ring-white {
    --tw-ring-color: var(--background-white);
  }

  /* Badge colors in dark mode */
  [data-theme="dark"] #userProfileDashboard .bg-blue-50 {
    background-color: rgba(59, 130, 246, 0.15) !important;
  }

  [data-theme="dark"] #userProfileDashboard .text-blue-700 {
    color: #60a5fa !important;
  }

  [data-theme="dark"] #userProfileDashboard .bg-purple-50 {
    background-color: rgba(168, 85, 247, 0.15) !important;
  }

  [data-theme="dark"] #userProfileDashboard .text-purple-700 {
    color: #c084fc !important;
  }

  [data-theme="dark"] #userProfileDashboard .bg-green-50 {
    background-color: rgba(34, 197, 94, 0.15) !important;
  }

  [data-theme="dark"] #userProfileDashboard .text-green-700 {
    color: #4ade80 !important;
  }

  [data-theme="dark"] #userProfileDashboard .bg-orange-50 {
    background-color: rgba(249, 115, 22, 0.15) !important;
  }

  [data-theme="dark"] #userProfileDashboard .text-orange-700 {
    color: #fb923c !important;
  }

  [data-theme="dark"] #userProfileDashboard .bg-amber-50 {
    background-color: rgba(245, 158, 11, 0.15) !important;
  }

  [data-theme="dark"] #userProfileDashboard .text-amber-700 {
    color: #fbbf24 !important;
  }

  /* Notification Badge */
  #notificationBadge {
    min-width: 18px;
    height: 18px;
    line-height: 1;
    padding: 0 4px;
  }
  
  /* Single digit - make it circular */
  #notificationBadge:not(:empty) {
    padding: 0 5px;
  }
  
  /* Notification Badge Dark Mode */
  [data-theme="dark"] #notificationBadge {
    background-color: #ef4444 !important;
  }

  /* Notification Panel - self-contained so external CSS cannot break it */
  #notificationsModal.notification-panel {
    position: absolute !important;
    top: 100% !important;
    right: 0 !important;
    margin-top: 0.5rem !important;
    width: 420px !important;
    max-width: calc(100vw - 2rem) !important;
    max-height: min(520px, 85vh) !important;
    display: flex !important;
    flex-direction: column !important;
    background: #ffffff !important;
    border: 1px solid #e5e7eb !important;
    border-radius: 12px !important;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25) !important;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s ease, visibility 0.2s ease;
    z-index: 9999 !important;
    overflow: hidden !important;
    isolation: isolate;
  }
  #notificationBtn.group:hover #notificationsModal.notification-panel,
  #notificationsModal.notification-panel.visible {
    opacity: 1;
    visibility: visible;
  }
  #notificationsModal .notification-panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-shrink: 0;
    padding: 0.75rem 1rem;
    border-bottom: 1px solid var(--gray-200);
    background: var(--gray-50);
  }
  #notificationsModal .notification-panel-header h3 {
    margin: 0;
    font-size: var(--font-base, 0.875rem);
    font-weight: 600;
    color: var(--text-color);
    letter-spacing: -0.01em;
  }
  #notificationsModal .notification-panel-close {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.375rem;
    border: none;
    background: transparent;
    border-radius: 6px;
    color: var(--gray-500);
    cursor: pointer;
  }
  #notificationsModal .notification-panel-close:hover {
    color: var(--gray-700);
    background: var(--gray-200);
  }
  #notificationsModal .notification-panel-list {
    flex: 1;
    min-height: 0;
    overflow-y: auto;
    overflow-x: hidden;
    -webkit-overflow-scrolling: touch;
  }
  #notificationsModal .notification-panel-list::-webkit-scrollbar {
    width: 6px;
  }
  #notificationsModal .notification-panel-list::-webkit-scrollbar-track {
    background: transparent;
  }
  #notificationsModal .notification-panel-list::-webkit-scrollbar-thumb {
    background: #d1d5db;
    border-radius: 3px;
  }
  #notificationsModal .notification-panel-section {
    padding: 0.75rem 0 0.25rem;
  }
  #notificationsModal .notification-panel-header h3,
  #notificationsModal .notification-panel-item-title,
  #notificationsModal .notification-panel-item-message,
  #notificationsModal .notification-panel-item-time,
  #notificationsModal .notification-panel-section-title,
  #notificationsModal .notification-panel-item-category {
    font-family: var(--font-family, "Poppins", sans-serif);
  }
  #notificationsModal .notification-panel-section-title {
    font-size: var(--font-xs, 0.625rem);
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--text-muted) !important;
    padding: 0 0 0.5rem 0;
    margin: 0 0 0.25rem 0;
    border-bottom: 1px solid var(--gray-200);
  }
  /* Tiles: minimal with color accents */
  #notificationsModal .notification-panel-item {
    display: block;
    margin-bottom: 0.5rem;
    border-radius: 6px;
    border: 1px solid var(--gray-200);
    border-left: 3px solid var(--gray-400);
    background: var(--background-white);
    padding: 0;
    transition: border-color 0.15s ease, background-color 0.15s ease, box-shadow 0.15s ease;
    cursor: pointer;
    text-align: left;
    overflow: hidden;
  }
  #notificationsModal .notification-panel-item:last-child { margin-bottom: 0; }
  /* Assignment / Audit: green accent */
  #notificationsModal .notification-panel-item.notification-type-assignment {
    border-left-color: #10b981;
    background: rgba(16, 185, 129, 0.04);
  }
  #notificationsModal .notification-panel-item.notification-type-assignment:hover {
    background: rgba(16, 185, 129, 0.08);
    border-color: rgba(16, 185, 129, 0.2);
  }
  /* Reversal: amber accent */
  #notificationsModal .notification-panel-item.notification-type-reversal {
    border-left-color: #f59e0b;
    background: rgba(245, 158, 11, 0.04);
  }
  #notificationsModal .notification-panel-item.notification-type-reversal:hover {
    background: rgba(245, 158, 11, 0.08);
    border-color: rgba(245, 158, 11, 0.2);
  }
  /* Reversal status: indigo accent */
  #notificationsModal .notification-panel-item.notification-type-reversal_status {
    border-left-color: #6366f1;
    background: rgba(99, 102, 241, 0.04);
  }
  #notificationsModal .notification-panel-item.notification-type-reversal_status:hover {
    background: rgba(99, 102, 241, 0.08);
    border-color: rgba(99, 102, 241, 0.2);
  }
  /* Highlight newest notifications */
  #notificationsModal .notification-panel-item.notification-new {
    background: rgba(59, 130, 246, 0.06);
    border-left-color: #3b82f6;
    border-color: rgba(59, 130, 246, 0.15);
    box-shadow: 0 1px 3px rgba(59, 130, 246, 0.1);
  }
  #notificationsModal .notification-panel-item.notification-new:hover {
    background: rgba(59, 130, 246, 0.1);
    border-color: rgba(59, 130, 246, 0.25);
    box-shadow: 0 2px 6px rgba(59, 130, 246, 0.15);
  }
  #notificationsModal .notification-panel-item:hover {
    border-color: var(--gray-300);
  }
  #notificationsModal .notification-panel-item-inner {
    display: flex;
    align-items: flex-start;
    gap: 0.75rem;
    padding: 0.75rem 1rem;
  }
  #notificationsModal .notification-panel-item-icon {
    width: 2.25rem;
    height: 2.25rem;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    background: var(--gray-100);
    color: var(--gray-600);
  }
  /* Colored icon backgrounds by category */
  #notificationsModal .notification-panel-item.notification-type-assignment .notification-panel-item-icon {
    background: rgba(16, 185, 129, 0.12);
    color: #059669;
  }
  #notificationsModal .notification-panel-item.notification-type-reversal .notification-panel-item-icon {
    background: rgba(245, 158, 11, 0.12);
    color: #d97706;
  }
  #notificationsModal .notification-panel-item.notification-type-reversal_status .notification-panel-item-icon {
    background: rgba(99, 102, 241, 0.12);
    color: #6366f1;
  }
  #notificationsModal .notification-panel-item.notification-new .notification-panel-item-icon {
    background: rgba(59, 130, 246, 0.15);
    color: #2563eb;
  }
  #notificationsModal .notification-panel-item-body { flex: 1; min-width: 0; }
  #notificationsModal .notification-panel-item-meta {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.5rem;
    margin-bottom: 0.375rem;
    flex-wrap: wrap;
  }
  #notificationsModal .notification-panel-item-chips {
    display: inline-flex;
    align-items: center;
    gap: 0.375rem;
    flex-wrap: wrap;
  }
  /* Chips: colored by category */
  #notificationsModal .notification-panel-item-category,
  #notificationsModal .notification-panel-item-status-chip {
    display: inline-flex;
    align-items: center;
    font-size: var(--font-xs, 0.625rem);
    font-weight: 500;
    letter-spacing: 0.02em;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    flex-shrink: 0;
  }
  /* Category chips: colored */
  #notificationsModal .notification-panel-item-category.category-audit {
    background: rgba(16, 185, 129, 0.15);
    color: #047857;
    border: 1px solid rgba(16, 185, 129, 0.25);
  }
  #notificationsModal .notification-panel-item-category.category-reversal {
    background: rgba(245, 158, 11, 0.15);
    color: #b45309;
    border: 1px solid rgba(245, 158, 11, 0.25);
  }
  #notificationsModal .notification-panel-item-category.category-status {
    background: rgba(99, 102, 241, 0.15);
    color: #4f46e5;
    border: 1px solid rgba(99, 102, 241, 0.25);
  }
  /* Status chips: neutral with subtle tint */
  #notificationsModal .notification-panel-item-status-chip {
    background: var(--gray-100);
    color: var(--gray-700);
    border: 1px solid var(--gray-200);
  }
  /* Status chip colors for specific statuses */
  #notificationsModal .notification-panel-item-status-chip[data-status="Approved"],
  #notificationsModal .notification-panel-item[data-status="Approved"] .notification-panel-item-status-chip {
    background: rgba(16, 185, 129, 0.12);
    color: #047857;
    border-color: rgba(16, 185, 129, 0.2);
  }
  #notificationsModal .notification-panel-item-status-chip[data-status="Rejected"],
  #notificationsModal .notification-panel-item[data-status="Rejected"] .notification-panel-item-status-chip {
    background: rgba(239, 68, 68, 0.12);
    color: #b91c1c;
    border-color: rgba(239, 68, 68, 0.2);
  }
  #notificationsModal .notification-panel-item-status-chip[data-status="completed"],
  #notificationsModal .notification-panel-item[data-status="completed"] .notification-panel-item-status-chip {
    background: rgba(16, 185, 129, 0.12);
    color: #047857;
    border-color: rgba(16, 185, 129, 0.2);
  }
  #notificationsModal .notification-panel-item-status-chip[data-status="Acknowledged"] {
    background: rgba(99, 102, 241, 0.12);
    color: #4f46e5;
    border-color: rgba(99, 102, 241, 0.2);
  }
  #notificationsModal .notification-panel-item-time {
    font-size: var(--font-xs, 0.625rem);
    color: var(--text-muted) !important;
    margin: 0;
    flex-shrink: 0;
    font-weight: 400;
  }
  #notificationsModal .notification-panel-item-title {
    font-size: var(--font-base, 0.875rem);
    font-weight: 600;
    color: var(--text-color);
    margin: 0 0 0.25rem;
    line-height: 1.4;
  }
  #notificationsModal .notification-panel-item-message {
    font-size: var(--font-sm, 0.75rem);
    color: var(--text-secondary) !important;
    margin: 0;
    line-height: 1.5;
    word-break: break-word;
    font-weight: 400;
  }
  #notificationsModal .notification-panel-empty {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 2.5rem 1rem;
    text-align: center;
  }
  #notificationsModal .notification-panel-empty svg {
    width: 3rem;
    height: 3rem;
    margin-bottom: 0.75rem;
    color: var(--gray-300);
  }
  #notificationsModal .notification-panel-empty .notification-panel-empty-title {
    font-size: var(--font-base, 0.875rem);
    font-weight: 500;
    color: var(--text-secondary);
    margin: 0 0 0.25rem;
  }
  #notificationsModal .notification-panel-empty .notification-panel-empty-text {
    font-size: var(--font-sm, 0.75rem);
    color: var(--text-muted);
    margin: 0;
  }
  @keyframes notification-panel-spin {
    to { transform: rotate(360deg); }
  }
  #notificationsModal .notification-panel-empty .animate-spin {
    animation: notification-panel-spin 1s linear infinite;
  }
  [data-theme="dark"] #notificationsModal.notification-panel,
  [data-theme="dark"] #notificationsModal .notification-panel-header {
    background-color: var(--background-white) !important;
    border-color: var(--border-light) !important;
  }
  [data-theme="dark"] #notificationsModal .notification-panel-header {
    background-color: rgba(55, 65, 81, 0.4) !important;
  }
  [data-theme="dark"] #notificationsModal .notification-panel-section-title {
    color: var(--text-muted) !important;
  }
  [data-theme="dark"] #notificationsModal .notification-panel-item:hover {
    background: var(--gray-100) !important;
    border-color: var(--gray-300) !important;
  }
  [data-theme="dark"] #notificationsModal .notification-panel-item-title { color: var(--text-color) !important; }
  [data-theme="dark"] #notificationsModal .notification-panel-item-message { color: var(--text-secondary) !important; }
  [data-theme="dark"] #notificationsModal .notification-panel-item-time { color: var(--text-muted) !important; }
  [data-theme="dark"] #notificationsModal .notification-panel-item-category.category-audit {
    background: rgba(16, 185, 129, 0.2) !important;
    color: #6ee7b7 !important;
    border-color: rgba(16, 185, 129, 0.3) !important;
  }
  [data-theme="dark"] #notificationsModal .notification-panel-item-category.category-reversal {
    background: rgba(245, 158, 11, 0.2) !important;
    color: #fcd34d !important;
    border-color: rgba(245, 158, 11, 0.3) !important;
  }
  [data-theme="dark"] #notificationsModal .notification-panel-item-category.category-status {
    background: rgba(99, 102, 241, 0.2) !important;
    color: #a5b4fc !important;
    border-color: rgba(99, 102, 241, 0.3) !important;
  }
  [data-theme="dark"] #notificationsModal .notification-panel-item-status-chip {
    background: var(--gray-100) !important;
    color: var(--gray-600) !important;
    border-color: var(--gray-200) !important;
  }
  [data-theme="dark"] #notificationsModal .notification-panel-item.notification-new {
    background: rgba(59, 130, 246, 0.12) !important;
    border-left-color: #60a5fa !important;
  }
  [data-theme="dark"] #notificationsModal .notification-panel-item.notification-new:hover {
    background: rgba(59, 130, 246, 0.18) !important;
  }
  [data-theme="dark"] #notificationsModal .notification-panel-section-title {
    border-bottom-color: var(--border-light) !important;
  }
  [data-theme="dark"] #notificationsModal .notification-panel-item-icon {
    background: var(--gray-100) !important;
    color: var(--gray-500) !important;
  }
  [data-theme="dark"] #notificationsModal .notification-panel-item.notification-type-assignment .notification-panel-item-icon {
    background: rgba(16, 185, 129, 0.2) !important;
    color: #34d399 !important;
  }
  [data-theme="dark"] #notificationsModal .notification-panel-item.notification-type-reversal .notification-panel-item-icon {
    background: rgba(245, 158, 11, 0.2) !important;
    color: #fbbf24 !important;
  }
  [data-theme="dark"] #notificationsModal .notification-panel-item.notification-type-reversal_status .notification-panel-item-icon {
    background: rgba(99, 102, 241, 0.2) !important;
    color: #818cf8 !important;
  }
  [data-theme="dark"] #notificationsModal .notification-panel-item.notification-new .notification-panel-item-icon {
    background: rgba(59, 130, 246, 0.2) !important;
    color: #60a5fa !important;
  }
  [data-theme="dark"] #notificationsModal .notification-panel-header {
    background: var(--gray-100) !important;
    border-bottom-color: var(--border-light) !important;
  }

  /* Calendar and Grid Modals Dark Mode */
  [data-theme="dark"] #calendarModal,
  [data-theme="dark"] #gridModal {
    background-color: var(--background-white) !important;
    border-color: var(--border-light) !important;
  }

  [data-theme="dark"] #calendarModal .border-gray-200,
  [data-theme="dark"] #gridModal .border-gray-200 {
    border-color: var(--border-light) !important;
  }

  [data-theme="dark"] #calendarModal .text-gray-900,
  [data-theme="dark"] #gridModal .text-gray-900 {
    color: var(--text-color) !important;
  }

  [data-theme="dark"] #calendarModal .text-gray-500,
  [data-theme="dark"] #gridModal .text-gray-500 {
    color: var(--text-muted) !important;
  }

  [data-theme="dark"] #calendarModal .text-gray-600,
  [data-theme="dark"] #gridModal .text-gray-600 {
    color: var(--text-secondary) !important;
  }

  [data-theme="dark"] #calendarModal .text-gray-700,
  [data-theme="dark"] #gridModal .text-gray-700 {
    color: var(--text-secondary) !important;
  }

  [data-theme="dark"] #calendarModal .hover\:bg-gray-50:hover,
  [data-theme="dark"] #gridModal .hover\:bg-gray-50:hover {
    background-color: var(--gray-100) !important;
  }

  [data-theme="dark"] #calendarModal .divide-gray-200 > *,
  [data-theme="dark"] #gridModal .divide-gray-200 > * {
    border-color: var(--border-light) !important;
  }

  /* Avatar Logout Menu Dark Mode */
  [data-theme="dark"] #avatarLogoutMenu {
    background-color: var(--background-white) !important;
    border-color: var(--border-light) !important;
  }

  [data-theme="dark"] #avatarLogoutMenu .text-error {
    color: #ef4444 !important;
  }

  [data-theme="dark"] #avatarLogoutMenu .hover\:bg-error\/10:hover {
    background-color: rgba(239, 68, 68, 0.1) !important;
  }

  /* Page heading styling - black color like other pages */
  h1.text-gray-900 {
    color: #000000 !important;
    font-weight: 700;
  }
</style>
</head>

<body class="home-page">
<!-- Sidebar will be loaded dynamically by load-sidebar.js -->
 <main class="main-content" role="main">
  <!-- Main Dashboard Content -->
  <div class="px-4 py-4 max-w-7xl mx-auto w-full">
    <!-- Action Icons - Aligned to the right -->
    <div class="flex items-center justify-end mb-4">
      <div class="flex items-center gap-2">
        <button id="createAuditBtn" class="flex items-center gap-1.5 px-3 py-1.5 bg-primary text-white rounded text-xs font-medium hover:bg-primary-dark transition-colors">
          <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
          </svg>
          Create Audit
        </button>
        <button id="searchBtn" class="p-1.5 text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded transition-colors">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
          </svg>
        </button>
        <div id="notificationBtn" class="relative group">
          <button class="p-1.5 text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded transition-colors relative">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"/>
            </svg>
            <span id="notificationBadge" class="hidden absolute -top-1 -right-1 bg-error rounded-full text-white text-[10px] font-bold flex items-center justify-center shadow-sm"></span>
          </button>
          
          <!-- Notifications Modal - Appears on hover (styles in page style block) -->
          <div id="notificationsModal" class="notification-panel">
            <div class="notification-panel-header">
              <h3>Notifications</h3>
              <button type="button" class="notification-panel-close" aria-label="Close notifications">
                <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
              </button>
            </div>
            <div id="notificationsList" class="notification-panel-list">
              <div class="notification-panel-empty">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"/>
                </svg>
                <p class="notification-panel-empty-title">Loading notifications...</p>
              </div>
            </div>
          </div>
        </div>
        <div id="calendarBtn" class="relative group">
          <button class="p-1.5 text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded transition-colors relative">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
            </svg>
          </button>
          
          <!-- Calendar Events Modal - Appears on hover -->
          <div id="calendarModal" class="absolute top-full right-0 mt-2 bg-white rounded-lg shadow-xl w-80 max-h-[calc(100vh-5rem)] flex flex-col opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50">
            <!-- Modal Header -->
            <div class="px-4 py-3 border-b border-gray-200 flex items-center justify-between">
              <h3 class="text-sm font-semibold text-gray-900">Upcoming Events</h3>
              <button class="text-gray-400 hover:text-gray-600 transition-colors">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
              </button>
            </div>
            
            <!-- Events List -->
            <div id="eventsList" class="flex-1 overflow-y-auto divide-y divide-gray-200">
              <div class="px-4 py-8 text-center text-gray-500 text-xs">
                <div class="animate-pulse">Loading events...</div>
              </div>
            </div>
            
            <!-- Modal Footer -->
            <div class="px-4 py-3 border-t border-gray-200">
              <button id="manageEventsBtn" class="w-full px-3 py-2 text-xs font-medium text-primary hover:bg-primary/10 rounded transition-colors flex items-center justify-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                </svg>
                Manage Events
              </button>
            </div>
          </div>
        </div>
        <div id="gridBtn" class="relative group">
          <button class="p-1.5 text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded transition-colors relative">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"/>
            </svg>
          </button>
          
          <!-- Grid Quick Actions Modal - Appears on hover -->
          <div id="gridModal" class="absolute top-full right-0 mt-2 bg-white rounded-lg shadow-xl w-64 max-h-[calc(100vh-5rem)] flex flex-col opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50">
            <!-- Modal Header -->
            <div class="px-4 py-3 border-b border-gray-200 flex items-center justify-between">
              <h3 class="text-sm font-semibold text-gray-900">Quick Actions</h3>
              <button class="text-gray-400 hover:text-gray-600 transition-colors">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
              </button>
            </div>
            
            <!-- Quick Actions List -->
            <div id="quickActionsList" class="flex-1 overflow-y-auto divide-y divide-gray-200">
              <div id="quickActionCreateAudit" class="px-4 py-3 hover:bg-gray-50 transition-colors cursor-pointer">
                <div class="flex items-center gap-3">
                  <div class="w-8 h-8 rounded bg-primary/10 flex items-center justify-center">
                    <svg class="w-4 h-4 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                    </svg>
                  </div>
                  <div class="flex-1">
                    <p class="text-xs font-semibold text-gray-900">Create Audit</p>
                    <p class="text-[10px] text-gray-500">Start a new audit</p>
                  </div>
                </div>
              </div>
              <div class="px-4 py-3 hover:bg-gray-50 transition-colors cursor-pointer" id="quickActionReports">
                <div class="flex items-center gap-3">
                  <div class="w-8 h-8 rounded bg-success/10 flex items-center justify-center">
                    <svg class="w-4 h-4 text-success" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                    </svg>
                  </div>
                  <div class="flex-1">
                    <p class="text-xs font-semibold text-gray-900">View Reports</p>
                    <p class="text-[10px] text-gray-500">Browse audit reports</p>
                  </div>
                </div>
              </div>
              <div class="px-4 py-3 hover:bg-gray-50 transition-colors cursor-pointer" id="quickActionEvents">
                <div class="flex items-center gap-3">
                  <div class="w-8 h-8 rounded bg-warning/10 flex items-center justify-center">
                    <svg class="w-4 h-4 text-warning" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                    </svg>
                  </div>
                  <div class="flex-1">
                    <p class="text-xs font-semibold text-gray-900">Events</p>
                    <p class="text-[10px] text-gray-500">Manage events</p>
                  </div>
                </div>
              </div>
              <div id="quickActionSettings" class="px-4 py-3 hover:bg-gray-50 transition-colors cursor-pointer">
                <div class="flex items-center gap-3">
                  <div class="w-8 h-8 rounded bg-gray-100 flex items-center justify-center">
                    <svg class="w-4 h-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                    </svg>
                  </div>
                  <div class="flex-1">
                    <p class="text-xs font-semibold text-gray-900">Settings</p>
                    <p class="text-[10px] text-gray-500">System settings</p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="relative group" id="userProfileContainer">
          <div id="userAvatar" class="w-7 h-7 rounded-full bg-primary flex items-center justify-center text-white text-xs font-medium cursor-pointer hover:bg-primary-dark transition-colors">
            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
              <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 4c1.93 0 3.5 1.57 3.5 3.5S13.93 13 12 13s-3.5-1.57-3.5-3.5S10.07 6 12 6zm0 14c-2.03 0-4.43-.82-6.14-2.88C7.55 15.8 9.68 15 12 15s4.45.8 6.14 2.12C16.43 19.18 14.03 20 12 20z"/>
            </svg>
          </div>
          
          <!-- Logout Button - Appears on hover -->
          <div id="avatarLogoutMenu" class="absolute top-full right-0 mt-2 bg-white rounded-lg shadow-xl w-48 border border-gray-200 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50">
            <div class="p-2">
              <button class="logout-btn w-full px-3 py-2 text-xs font-medium text-error hover:bg-error/10 rounded transition-colors flex items-center justify-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"/>
                </svg>
                Logout
              </button>
            </div>
          </div>
          
          <!-- User Profile Dropdown (Hidden - kept for reference) -->
          <div id="userProfileDropdown" class="user-profile-dropdown hidden">
            <!-- Profile Header -->
            <div class="p-4 border-b border-gray-200 bg-gradient-to-r from-primary/5 to-primary/10">
              <div class="flex items-center gap-3">
                <div id="dropdownAvatar" class="w-12 h-12 rounded-full bg-primary flex items-center justify-center text-white text-base font-semibold flex-shrink-0">
                  <!-- Will be populated by JS -->
                </div>
                <div class="flex-1 min-w-0">
                  <div id="userName" class="text-sm font-semibold text-gray-900 truncate">Loading...</div>
                  <div id="userEmail" class="text-xs text-gray-600 truncate">Loading...</div>
                </div>
              </div>
            </div>
            
            <!-- Profile Details -->
            <div class="p-4 space-y-3">
              <!-- Role Badge -->
              <div class="flex items-center justify-between">
                <span class="text-xs font-medium text-gray-500">Role</span>
                <span id="userRoleBadge" class="px-2.5 py-1 bg-primary/10 text-primary text-xs font-semibold rounded">
                  <!-- Will be populated by JS -->
                </span>
              </div>
              
              <!-- Employee-specific fields -->
              <div id="employeeFields" class="space-y-2.5 field-group-hidden">
                <div class="flex items-center justify-between">
                  <span class="text-xs font-medium text-gray-500">Employee ID</span>
                  <span id="userEmployeeId" class="text-xs text-gray-900 font-medium">-</span>
                </div>
                <div class="flex items-center justify-between">
                  <span class="text-xs font-medium text-gray-500">Channel</span>
                  <span id="userChannel" class="text-xs text-gray-900 font-medium">-</span>
                </div>
                <div class="flex items-center justify-between">
                  <span class="text-xs font-medium text-gray-500">Team</span>
                  <span id="userTeam" class="text-xs text-gray-900 font-medium">-</span>
                </div>
                <div class="flex items-center justify-between">
                  <span class="text-xs font-medium text-gray-500">Supervisor</span>
                  <span id="userSupervisor" class="text-xs text-gray-900 font-medium">-</span>
                </div>
              </div>
              
              <!-- Admin-specific fields -->
              <div id="adminFields" class="space-y-2.5 field-group-hidden">
                <div class="flex items-center justify-between">
                  <span class="text-xs font-medium text-gray-500">Channel</span>
                  <span id="adminChannel" class="text-xs text-gray-900 font-medium">-</span>
                </div>
                <div class="flex items-center justify-between">
                  <span class="text-xs font-medium text-gray-500">Quality Mentor</span>
                  <span id="userQualityMentor" class="text-xs text-gray-900 font-medium">-</span>
                </div>
              </div>
            </div>
            
            <!-- Actions -->
            <div class="p-3 border-t border-gray-200 bg-gray-50">
              <button class="logout-btn w-full px-3 py-2 text-xs font-medium text-error hover:bg-error/10 rounded transition-colors flex items-center justify-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"/>
                </svg>
                Sign Out
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
    <h1 class="page-heading-global">Home</h1>

    <!-- User Profile Card (Matching Screenshot) -->
    <div id="userProfileDashboard" class="mb-4">
      <div class="bg-white rounded-lg border border-gray-200 shadow-sm px-4 py-3">
        <div class="flex items-center justify-between gap-4 flex-wrap">
          <!-- Left: Avatar + Name + Role + Channel -->
          <div class="flex items-center gap-3">
            <div id="dashboardAvatar" class="w-10 h-10 rounded-full bg-gradient-to-br from-primary to-primary flex items-center justify-center text-white text-sm font-bold shadow ring-1 ring-gray-200 flex-shrink-0">
              <!-- Avatar -->
            </div>
            <div class="flex flex-col gap-1.5">
              <div class="flex items-center gap-2 flex-wrap">
                <h3 id="dashboardUserName" class="text-base font-bold text-gray-900">Loading...</h3>
                <span id="dashboardUserRole" class="px-2 py-0.5 bg-primary text-white text-[10px] font-semibold rounded uppercase">
                  <!-- Role -->
                </span>
              </div>
              <div id="profileInfoPills" class="flex items-center gap-2 flex-wrap">
                <!-- Employee Pills (hidden by default, shown conditionally) -->
                <div id="pillEmployeeId" class="hidden flex items-center gap-1.5 px-2.5 py-1 bg-blue-50 rounded text-[10px]">
                  <svg class="w-3 h-3 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V8a2 2 0 00-2-2h-5m-4 0V5a2 2 0 114 0v1m-4 0a2 2 0 104 0m-5 8a2 2 0 100-4 2 2 0 000 4zm0 0c1.306 0 2.417.835 2.83 2M9 14a3.001 3.001 0 00-2.83 2M15 11h3m-3 4h2"/>
                  </svg>
                  <span class="text-blue-500 font-medium">ID:</span>
                  <span class="text-blue-700 font-bold" id="displayEmployeeId">-</span>
                </div>
                <div id="pillTeam" class="hidden flex items-center gap-1.5 px-2.5 py-1 bg-green-50 rounded text-[10px]">
                  <svg class="w-3 h-3 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"/>
                  </svg>
                  <span class="text-primary font-medium">Team:</span>
                  <span class="text-primary font-bold" id="displayTeam">-</span>
                </div>
                <div id="pillSupervisor" class="hidden flex items-center gap-1.5 px-2.5 py-1 bg-orange-50 rounded text-[10px]">
                  <svg class="w-3 h-3 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
                  </svg>
                  <span class="text-orange-500 font-medium">Supervisor:</span>
                  <span class="text-orange-700 font-bold" id="displaySupervisor">-</span>
                </div>
                <div id="pillIntercomAlias" class="hidden flex items-center gap-1.5 px-2.5 py-1 bg-indigo-50 rounded text-[10px]">
                  <svg class="w-3 h-3 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"/>
                  </svg>
                  <span class="text-indigo-500 font-medium">Intercom:</span>
                  <span class="text-indigo-700 font-bold" id="displayIntercomAlias">-</span>
                </div>
                <!-- Admin Pills -->
                <div id="pillAdminChannel" class="hidden flex items-center gap-1.5 px-2.5 py-1 bg-purple-50 rounded text-[10px]">
                  <svg class="w-3 h-3 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 20l4-16m2 16l4-16M6 9h14M4 15h14"/>
                  </svg>
                  <span class="text-purple-500 font-medium">Channel:</span>
                  <span class="text-purple-700 font-bold" id="displayAdminChannel">-</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Action Buttons -->
    <div class="header-actions">
      <!-- Week Navigation -->
      <div class="week-nav-container">
        <button class="action-btn week-btn" id="prevWeekBtn" title="Previous Week">
          <svg class="icon-md" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
          </svg>
        </button>
        <div class="action-btn week-display" id="weekDisplay">
          <span id="weekText">Week -</span>
        </div>
        <button class="action-btn week-btn" id="nextWeekBtn" title="Next Week">
          <svg class="icon-md" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
          </svg>
        </button>
      </div>
      <div class="date-picker-dropdown">
        <button class="action-btn" id="dateBtn">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
          </svg>
          <span id="dateBtnText">Date Range</span>
          <svg class="icon-sm" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
          </svg>
        </button>
        <div class="date-dropdown-menu" id="dateDropdown" style="display: none;">
          <div class="filter-group">
            <label class="filter-label">Start Date</label>
            <input type="date" class="filter-input" id="startDate">
          </div>
          <div class="filter-group">
            <label class="filter-label">End Date</label>
            <input type="date" class="filter-input" id="endDate">
          </div>
          <div class="date-input-group">
            <button class="action-btn" id="applyDateFilterBtn">Apply</button>
            <button class="action-btn" id="clearDateFilterBtn">Clear</button>
          </div>
        </div>
      </div>
      <!-- Quick Date Filters -->
      <div class="date-filter-container">
          <button class="action-btn quick-date-btn" id="todayBtn">Today</button>
          <button class="action-btn quick-date-btn" id="yesterdayBtn">Yesterday</button>
          <button class="action-btn quick-date-btn active" id="thisMonthBtn">This Month</button>
          <button class="action-btn quick-date-btn" id="lastMonthBtn">Last Month</button>
      </div>
      <button class="action-btn" id="filterBtn">
        <svg id="filterBtnIcon" fill="none" stroke="currentColor" viewBox="0 0 24 24" class="w-4 h-4">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"></path>
        </svg>
        <span id="filterBtnText">Filter</span>
      </button>
    </div>

    <!-- Filter Panel -->
    <div class="filter-panel" id="filterPanel">
      <div class="filter-group">
        <label class="filter-label">Channel</label>
        <select class="filter-select" id="filterChannel">
          <option value="">All Channels</option>
        </select>
      </div>
      <div class="filter-group">
        <label class="filter-label">Status</label>
        <select class="filter-select" id="filterStatus">
          <option value="">All Statuses</option>
          <option value="pending">Pending</option>
          <option value="in_progress">In Progress</option>
          <option value="completed">Completed</option>
        </select>
      </div>
      <div class="filter-group filter-group-hidden" id="filterAgentGroup">
        <label class="filter-label">Agent</label>
        <select class="filter-select" id="filterAgent">
          <option value="">All Agents</option>
        </select>
      </div>
      <div class="filter-group filter-group-end">
        <button class="action-btn" id="applyFiltersBtn">Apply Filters</button>
      </div>
    </div>

    <!-- Stats Cards -->
    <div id="stats-cards-container" class="flex flex-wrap gap-3 mb-4 justify-center">
      <!-- Audits Conducted Card -->
      <div id="auditsConductedCard" class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow group stat-card" style="min-width: 200px; max-width: 300px; flex: 1 1 250px;">
        <div class="flex items-center justify-between mb-2">
          <div class="w-10 h-10 rounded-lg bg-primary/10 flex items-center justify-center group-hover:bg-primary/20 transition-colors">
            <svg class="w-5 h-5 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
            </svg>
          </div>
        </div>
        <div class="text-[10px] font-semibold text-gray-500 uppercase tracking-wide mb-1">Audits Conducted</div>
        <div class="text-3xl font-bold text-gray-900 mb-2" id="statsAuditsConductedCount">
          <div class="h-8 w-16 bg-gray-200 rounded animate-pulse"></div>
        </div>
        <!-- Progress bar showing remaining audits -->
        <div class="mt-2">
          <div class="flex items-center justify-between mb-1">
            <span class="text-[10px] font-medium text-gray-600" id="statsRemainingText">- remaining</span>
          </div>
          <div class="w-full bg-gray-200 rounded-full h-1.5">
            <div class="progress-bar" id="statsRemainingProgress"></div>
          </div>
        </div>
      </div>

      <!-- Average Quality Score Card -->
      <div id="avgQualityScoreCard" class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow group stat-card" style="min-width: 200px; max-width: 300px; flex: 1 1 250px;">
        <div class="flex items-center justify-between mb-2">
          <div class="w-10 h-10 rounded-lg bg-success/10 flex items-center justify-center group-hover:bg-success/20 transition-colors">
            <svg class="w-5 h-5 text-success" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
            </svg>
          </div>
        </div>
        <div class="text-[10px] font-semibold text-gray-500 uppercase tracking-wide mb-1">Average Quality Score</div>
        <div class="text-3xl font-bold text-gray-900 mb-1" id="statsAvgQualityScore">
          <div class="h-8 w-16 bg-gray-200 rounded animate-pulse"></div>
        </div>
        <div class="text-xs font-medium text-gray-600 mt-1" id="statsAvgScoreSubtitle">
          <div class="h-4 w-24 bg-gray-200 rounded animate-pulse"></div>
        </div>
      </div>

      <!-- Pass Rate Card (Employees Only) -->
      <div id="passRateCard" class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow group stats-card-hidden stat-card" style="min-width: 200px; max-width: 300px; flex: 1 1 250px;">
        <div class="flex items-center justify-between mb-2">
          <div class="w-10 h-10 rounded-lg bg-success/10 flex items-center justify-center group-hover:bg-success/20 transition-colors">
            <svg class="w-5 h-5 text-success" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
          </div>
        </div>
        <div class="text-[10px] font-semibold text-gray-500 uppercase tracking-wide mb-1">Pass Rate</div>
        <div class="flex items-start gap-2 mb-1">
          <div class="text-3xl font-bold text-gray-900" id="statsPassRate">
            <div class="h-8 w-16 bg-gray-200 rounded animate-pulse"></div>
          </div>
          <div class="flex flex-col gap-1">
            <div class="inline-flex items-center gap-1 px-2 py-0.5 rounded text-[8px] font-semibold bg-primary/10 text-primary" id="statsPassingCount">
              <svg class="icon-xs" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
              </svg>
              <span class="inline-block h-3 w-4 bg-gray-200 rounded animate-pulse"></span>
              <span>Passed</span>
            </div>
            <div class="inline-flex items-center gap-1 px-2 py-0.5 rounded text-[8px] font-semibold bg-red-100 text-red-800" id="statsNotPassingCount">
              <svg class="icon-xs" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
              </svg>
              <span class="inline-block h-3 w-4 bg-gray-200 rounded animate-pulse"></span>
              <span>Not Passed</span>
            </div>
          </div>
        </div>
        <div class="text-xs font-medium text-success mt-1 hidden" id="statsPassRateChange">
          <div class="h-4 w-24 bg-gray-200 rounded animate-pulse"></div>
        </div>
      </div>

      <!-- Remaining Card -->
      <div id="remainingCard" class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow group stat-card" style="min-width: 200px; max-width: 300px; flex: 1 1 250px;">
        <div class="flex items-center justify-between mb-2">
          <div class="w-10 h-10 rounded-lg bg-warning/10 flex items-center justify-center group-hover:bg-warning/20 transition-colors">
            <svg class="w-5 h-5 text-warning" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
          </div>
        </div>
        <div class="text-[10px] font-semibold text-gray-500 uppercase tracking-wide mb-1">Remaining</div>
        <div class="text-3xl font-bold text-gray-900 mb-1" id="statsRemainingCount">
          <div class="h-8 w-16 bg-gray-200 rounded animate-pulse"></div>
        </div>
      </div>

      <!-- Requires Acknowledgment Card (Agents Only) -->
      <div id="requiresAcknowledgmentCard" class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow group stats-card-hidden stat-card" style="min-width: 200px; max-width: 300px; flex: 1 1 250px;">
        <div class="flex items-center justify-between mb-2">
          <div class="w-10 h-10 rounded-lg bg-primary/10 flex items-center justify-center group-hover:bg-primary/20 transition-colors">
            <svg class="w-5 h-5 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
          </div>
        </div>
        <div class="text-[10px] font-semibold text-gray-500 uppercase tracking-wide mb-1">Requires Acknowledgment</div>
        <div class="text-3xl font-bold text-gray-900 mb-1" id="statsRequiresAcknowledgmentCount">
          <div class="h-8 w-16 bg-gray-200 rounded animate-pulse"></div>
        </div>
        <div class="text-xs font-medium text-gray-600 mt-1">reports pending</div>
      </div>

      <!-- Reversal Card -->
      <div class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow group stat-card" style="min-width: 200px; max-width: 300px; flex: 1 1 250px;">
        <div class="flex items-center justify-between mb-2">
          <div class="w-10 h-10 rounded-lg bg-error/10 flex items-center justify-center group-hover:bg-error/20 transition-colors">
            <svg class="w-5 h-5 text-error" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
            </svg>
          </div>
        </div>
        <div class="text-[10px] font-semibold text-gray-500 uppercase tracking-wide mb-1">Reversal</div>
        <div class="text-3xl font-bold text-gray-900 mb-2" id="statsReversalTotalCount">
          <div class="h-8 w-16 bg-gray-200 rounded animate-pulse"></div>
        </div>
        <div class="flex items-center gap-3 text-xs flex-wrap">
          <div class="flex items-center gap-1">
            <span class="text-gray-600">Active:</span>
            <span class="font-semibold text-warning" id="statsReversalActiveCount">
              <span class="inline-block h-4 w-6 bg-gray-200 rounded animate-pulse"></span>
            </span>
          </div>
          <div class="flex items-center gap-1">
            <span class="text-gray-600">Resolved:</span>
            <span class="font-semibold text-success" id="statsReversalResolvedCount">
              <span class="inline-block h-4 w-6 bg-gray-200 rounded animate-pulse"></span>
            </span>
          </div>
        </div>
      </div>

      <!-- In Progress Card -->
      <div id="inProgressCard" class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow group stat-card" style="min-width: 200px; max-width: 300px; flex: 1 1 250px;">
        <div class="flex items-center justify-between mb-2">
          <div class="w-10 h-10 rounded-lg bg-primary/10 flex items-center justify-center group-hover:bg-primary/20 transition-colors">
            <svg class="w-5 h-5 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="color: var(--primary-green);">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
            </svg>
          </div>
        </div>
        <div class="text-[10px] font-semibold text-gray-500 uppercase tracking-wide mb-1">In Progress</div>
        <div class="text-3xl font-bold text-gray-900 mb-1" id="statsInProgressCount">
          <div class="h-8 w-16 bg-gray-200 rounded animate-pulse"></div>
        </div>
        <div class="text-xs font-medium text-gray-600 mt-1" id="statsDaysRemaining">
          <div class="h-4 w-24 bg-gray-200 rounded animate-pulse"></div>
        </div>
      </div>

      <!-- Avg Duration Card -->
      <div id="avgDurationCard" class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow group stat-card" style="min-width: 200px; max-width: 300px; flex: 1 1 250px;">
        <div class="flex items-center justify-between mb-2">
          <div class="w-10 h-10 rounded-lg bg-primary/10 flex items-center justify-center group-hover:bg-primary/20 transition-colors">
            <svg class="w-5 h-5 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
          </div>
        </div>
        <div class="text-[10px] font-semibold text-gray-500 uppercase tracking-wide mb-1">Avg Duration</div>
        <div class="text-2xl font-bold text-gray-900 mb-1" id="statsAvgDuration">
          <div class="h-7 w-16 bg-gray-200 rounded animate-pulse"></div>
        </div>
        <div class="text-xs font-medium text-gray-600 mt-1" id="statsAvgDurationSubtitle">per audit</div>
      </div>
    </div>

    <!-- Recents Section -->
    <div class="bg-white rounded border border-gray-200">
      <div class="px-4 py-3 border-b border-gray-200 flex items-center justify-between">
        <h2 class="text-sm font-semibold text-gray-900 flex items-center gap-2">
          <span id="unifiedSectionTitle">Recents</span>
          <span id="reversalUpdatesCount" class="badge hidden">0</span>
        </h2>
        <div class="flex items-center gap-2">
          <button id="viewAllBtn" class="view-all-btn btn-primary-action">
            View All
          </button>
        </div>
      </div>
      
      <div id="recentUpdatesSection">
        <div id="updatesFeed" class="divide-y divide-gray-200 max-h-[800px] overflow-y-auto">
          <div class="px-4 py-3 space-y-3">
            <div class="flex items-start gap-3">
              <div class="w-8 h-8 bg-gray-200 rounded-full animate-pulse flex-shrink-0"></div>
              <div class="flex-1 space-y-2">
                <div class="h-4 w-3/4 bg-gray-200 rounded animate-pulse"></div>
                <div class="h-3 w-1/2 bg-gray-200 rounded animate-pulse"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

</main>

<script>
// Dashboard State
let currentUserEmail = '';
let currentUserRole = '';
let isAgent = false;
let allUsers = [];
let allAssignments = [];
let assignedAudits = [];
let sortBy = 'date_desc'; // Default will be updated based on user role
let notifications = [];
let unreadNotificationCount = 0;

// Cache for scorecards to avoid multiple queries
let cachedScorecards = null;
let cachedScorecardsTime = null;
const SCORECARDS_CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

// Helper: get set of existing audit table names (avoids 404s for scorecards whose table is missing)
async function getExistingAuditTableNames(supabase) {
  try {
    const { data, error } = await supabase.rpc('get_audit_tables');
    if (error || !data || !Array.isArray(data)) return new Set();
    return new Set(data.map(function (r) { return r.table_name; }));
  } catch (e) {
    return new Set();
  }
}

// Helper function to get cached scorecards (only scorecards whose audit table exists)
async function getCachedScorecards(supabase, fields = 'id, name, table_name, scoring_type') {
  const now = Date.now();
  if (cachedScorecards && cachedScorecardsTime && (now - cachedScorecardsTime) < SCORECARDS_CACHE_DURATION) {
    return cachedScorecards;
  }
  
  const { data: scorecards, error } = await supabase
    .from('scorecards')
    .select(fields)
    .eq('is_active', true);
  
  if (error) {
    console.error('Error loading scorecards:', error);
    return cachedScorecards || []; // Return cached if available, otherwise empty
  }
  
  let list = (scorecards || []).filter(function (s) { return s.table_name; });
  const existingTables = await getExistingAuditTableNames(supabase);
  if (existingTables.size > 0) {
    list = list.filter(function (s) { return existingTables.has(s.table_name); });
  }
  
  cachedScorecards = list;
  cachedScorecardsTime = now;
  return cachedScorecards;
}

// Date Filter State
let dateFilter = { start: null, end: null };
let currentFilters = { channel: '', status: '', agent: '' };
let currentWeek = null; // Current week number (1-52)
let currentWeekYear = null; // Year for the current week
let useWeekFilter = true; // Whether to use week filter (default) or date range filter

// Helper function to get week number (1-52)
function getWeekNumber(date = null) {
  if (!date) date = getDhakaNow();
  return getDhakaWeekNumber(date);
}

// Helper function to get week dates (Monday to Sunday)
function getWeekDates(weekNumber, year) {
  return getDhakaWeekDates(weekNumber, year);
}

// Initialize week filter
function initializeWeekFilter() {
  const today = getDhakaNow();
  currentWeek = getDhakaWeekNumber(today);
  currentWeekYear = today.getFullYear();
  updateWeekDisplay();
}

// Update week display
function updateWeekDisplay() {
  const weekTextEl = document.getElementById('weekText');
  const prevWeekBtn = document.getElementById('prevWeekBtn');
  const nextWeekBtn = document.getElementById('nextWeekBtn');
  const weekDisplay = document.getElementById('weekDisplay');
  
  // Initialize current week if not set
  if (currentWeek === null) {
    const today = getDhakaNow();
    currentWeek = getDhakaWeekNumber(today);
    currentWeekYear = today.getFullYear();
  }
  
  if (weekTextEl) {
    if (useWeekFilter && currentWeek !== null) {
      weekTextEl.textContent = `Week ${currentWeek}`;
    } else {
      weekTextEl.textContent = `Week ${currentWeek || '-'}`;
    }
  }
  
  // Always enable week navigation buttons - they can switch to week view when clicked
  if (prevWeekBtn) {
    prevWeekBtn.removeAttribute('disabled');
    prevWeekBtn.disabled = false;
    prevWeekBtn.style.opacity = '1';
    prevWeekBtn.style.cursor = 'pointer';
    prevWeekBtn.style.pointerEvents = 'auto';
  }
  
  if (nextWeekBtn) {
    nextWeekBtn.removeAttribute('disabled');
    nextWeekBtn.disabled = false;
    nextWeekBtn.style.opacity = '1';
    nextWeekBtn.style.cursor = 'pointer';
    nextWeekBtn.style.pointerEvents = 'auto';
  }
  
  // Update week display styling
  if (weekDisplay) {
    if (useWeekFilter) {
      weekDisplay.style.backgroundColor = '#1a733e';
      weekDisplay.style.color = 'white';
      weekDisplay.style.borderColor = '#1a733e';
      weekDisplay.style.cursor = 'default';
      weekDisplay.style.pointerEvents = 'auto';
    } else {
      weekDisplay.style.backgroundColor = '#f3f4f6';
      weekDisplay.style.color = '#6b7280';
      weekDisplay.style.borderColor = '#e5e7eb';
      weekDisplay.style.cursor = 'pointer';
      weekDisplay.style.pointerEvents = 'auto';
    }
  }
}

// Navigate week
function navigateWeek(direction) {
  // Initialize current week if not set
  if (currentWeek === null) {
    const today = getDhakaNow();
    currentWeek = getDhakaWeekNumber(today);
    currentWeekYear = today.getFullYear();
  }
  
  currentWeek += direction;
  
  // Handle week overflow/underflow
  if (currentWeek > 52) {
    currentWeek = 1;
    currentWeekYear += 1;
  } else if (currentWeek < 1) {
    currentWeek = 52;
    currentWeekYear -= 1;
  }
  
  // Switch to week view when navigating
  useWeekFilter = true;
  dateFilter.start = null;
  dateFilter.end = null;
  const startDateInput = document.getElementById('startDate');
  const endDateInput = document.getElementById('endDate');
  const dateBtnTextEl = document.getElementById('dateBtnText');
  if (startDateInput) startDateInput.value = '';
  if (endDateInput) endDateInput.value = '';
  if (dateBtnTextEl) dateBtnTextEl.textContent = 'Date Range';
  
  // Clear active state of quick filter buttons when switching to week view
  const quickDateButtons = document.querySelectorAll('.quick-date-btn');
  quickDateButtons.forEach(btn => btn.classList.remove('active'));
  
  // Disable week navigation buttons during loading
  const prevWeekBtn = document.getElementById('prevWeekBtn');
  const nextWeekBtn = document.getElementById('nextWeekBtn');
  const weekDisplay = document.getElementById('weekDisplay');
  if (prevWeekBtn) {
    prevWeekBtn.disabled = true;
    prevWeekBtn.style.opacity = '0.6';
    prevWeekBtn.style.cursor = 'not-allowed';
  }
  if (nextWeekBtn) {
    nextWeekBtn.disabled = true;
    nextWeekBtn.style.opacity = '0.6';
    nextWeekBtn.style.cursor = 'not-allowed';
  }
  if (weekDisplay) {
    weekDisplay.style.opacity = '0.6';
  }
  
  // Clear cache when period changes
  clearCache(`_${currentUserEmail}_`);
  
  updateWeekDisplay();
  
  // Show loaders
  showLoader('updatesFeed');
  showLoader('assignedAuditsList');
  showStatsLoader();
  
  // Reload data with week filter
  Promise.all([
    loadUnifiedAuditData(),
    updateYourStats(),
    loadNotifications()
  ]).then(() => {
    // Re-enable week navigation buttons
    if (prevWeekBtn) {
      prevWeekBtn.disabled = false;
      prevWeekBtn.style.opacity = '1';
      prevWeekBtn.style.cursor = 'pointer';
    }
    if (nextWeekBtn) {
      nextWeekBtn.disabled = false;
      nextWeekBtn.style.opacity = '1';
      nextWeekBtn.style.cursor = 'pointer';
    }
    if (weekDisplay) {
      weekDisplay.style.opacity = '1';
    }
  }).catch(error => {
    console.error('Error navigating week:', error);
    // Re-enable buttons even on error
    if (prevWeekBtn) {
      prevWeekBtn.disabled = false;
      prevWeekBtn.style.opacity = '1';
      prevWeekBtn.style.cursor = 'pointer';
    }
    if (nextWeekBtn) {
      nextWeekBtn.disabled = false;
      nextWeekBtn.style.opacity = '1';
      nextWeekBtn.style.cursor = 'pointer';
    }
    if (weekDisplay) {
      weekDisplay.style.opacity = '1';
    }
  });
}

// Function to switch to week view when week display is clicked
function switchToWeekView() {
  // Initialize current week if not set
  if (currentWeek === null) {
    const today = getDhakaNow();
    currentWeek = getDhakaWeekNumber(today);
    currentWeekYear = today.getFullYear();
  }
  
  useWeekFilter = true;
  dateFilter.start = null;
  dateFilter.end = null;
  const startDateInput = document.getElementById('startDate');
  const endDateInput = document.getElementById('endDate');
  const dateBtnTextEl = document.getElementById('dateBtnText');
  if (startDateInput) startDateInput.value = '';
  if (endDateInput) endDateInput.value = '';
  if (dateBtnTextEl) dateBtnTextEl.textContent = 'Date Range';
  
  // Clear active state of quick filter buttons when switching to week view
  const quickDateButtons = document.querySelectorAll('.quick-date-btn');
  quickDateButtons.forEach(btn => btn.classList.remove('active'));
  
  // Clear cache when switching to week view
  clearCache(`_${currentUserEmail}_`);
  
  updateWeekDisplay();
  
  // Show loaders
  showLoader('updatesFeed');
  showLoader('assignedAuditsList');
  showStatsLoader();
  
  // Reload data with week filter
  Promise.all([
    loadRecentUpdates(),
    updateYourStats(),
    loadAssignedAudits(),
    loadNotifications()
  ]).catch(error => {
    console.error('Error switching to week view:', error);
  });
}

// Initialize date filter (now uses month filter by default)
function initializeDateFilter() {
  // Initialize month filter (default view)
  // Functions are now available globally via fallback script above
  const today = getDhakaNow();
  const firstDay = getDhakaFirstDayOfMonth(today);
  const lastDay = getDhakaLastDayOfMonth(today);
  
  dateFilter.start = firstDay;
  dateFilter.end = lastDay;
  useWeekFilter = false;
  
  const startDateInput = document.getElementById('startDate');
  const endDateInput = document.getElementById('endDate');
  if (startDateInput) startDateInput.value = formatDhakaDateForInput(firstDay);
  if (endDateInput) endDateInput.value = formatDhakaDateForInput(lastDay);
  
  updateDateButtonText();
  
  // Activate "This Month" button
  const quickDateButtons = document.querySelectorAll('.quick-date-btn');
  quickDateButtons.forEach(btn => btn.classList.remove('active'));
  const thisMonthBtn = document.getElementById('thisMonthBtn');
  if (thisMonthBtn) {
    thisMonthBtn.classList.add('active');
  }
  
  // Initialize week filter for display purposes
  initializeWeekFilter();
}

function formatDateForInput(date) {
  return formatDhakaDateForInput(date);
}

function updateDateButtonText() {
  const dateBtnText = document.getElementById('dateBtnText');
  if (!dateBtnText) return;
  
  if (dateFilter.start && dateFilter.end) {
    const start = dateFilter.start instanceof Date ? dateFilter.start : parseDhakaDate(formatDhakaDateForInput(dateFilter.start));
    const end = dateFilter.end instanceof Date ? dateFilter.end : parseDhakaDate(formatDhakaDateForInput(dateFilter.end));
    const startStr = formatDhakaDate(start, { month: 'short', day: 'numeric' });
    const endStr = formatDhakaDate(end, { month: 'short', day: 'numeric' });
    dateBtnText.textContent = `${startStr} - ${endStr}`;
  } else {
    dateBtnText.textContent = 'Date Range';
  }
}

// Get current period dates (week or date range)
function getCurrentPeriodDates() {
  if (dateFilter.start || dateFilter.end) {
    // Using date range filter
    return {
      start: dateFilter.start ? (dateFilter.start instanceof Date ? dateFilter.start : getDhakaStartOfDay(parseDhakaDate(formatDhakaDateForInput(dateFilter.start)))) : new Date(0),
      end: dateFilter.end ? (dateFilter.end instanceof Date ? dateFilter.end : getDhakaEndOfDay(parseDhakaDate(formatDhakaDateForInput(dateFilter.end)))) : getDhakaNow()
    };
  } else if (useWeekFilter && currentWeek !== null) {
    // Using week filter
    return getDhakaWeekDates(currentWeek, currentWeekYear);
  } else {
    // Default to current week
    const today = getDhakaNow();
    return getDhakaWeekDates(getDhakaWeekNumber(today), today.getFullYear());
  }
}

// Apply date filter
function applyDateFilter() {
  const startDateInput = document.getElementById('startDate');
  const endDateInput = document.getElementById('endDate');
  const dateBtn = document.getElementById('dateBtn');
  const dateBtnText = document.getElementById('dateBtnText');
  
  if (startDateInput && startDateInput.value) {
    const startDate = getDhakaStartOfDay(parseDhakaDate(startDateInput.value));
    dateFilter.start = startDate;
  } else {
    dateFilter.start = null;
  }
  
  if (endDateInput && endDateInput.value) {
    const endDate = getDhakaEndOfDay(parseDhakaDate(endDateInput.value));
    dateFilter.end = endDate;
  } else {
    dateFilter.end = null;
  }
  
  // Show loading state on date button
  if (dateBtn) {
    dateBtn.disabled = true;
    dateBtn.style.opacity = '0.6';
    dateBtn.style.cursor = 'not-allowed';
  }
  if (dateBtnText) {
    const originalText = dateBtnText.textContent;
    dateBtnText.textContent = 'Loading...';
    dateBtnText.dataset.originalText = originalText;
  }
  
  // Update button text
  if (dateFilter.start || dateFilter.end) {
    const start = dateFilter.start ? formatDhakaDate(dateFilter.start instanceof Date ? dateFilter.start : parseDhakaDate(formatDhakaDateForInput(dateFilter.start)), { month: 'short', day: 'numeric' }) : 'Start';
    const end = dateFilter.end ? formatDhakaDate(dateFilter.end instanceof Date ? dateFilter.end : parseDhakaDate(formatDhakaDateForInput(dateFilter.end)), { month: 'short', day: 'numeric' }) : 'End';
    if (dateBtnText) {
      dateBtnText.dataset.originalText = `${start} - ${end}`;
    }
    useWeekFilter = false; // Date range overrides week filter
    
    // Clear active state of quick filter buttons when using custom date range
    const quickDateButtons = document.querySelectorAll('.quick-date-btn');
    quickDateButtons.forEach(btn => btn.classList.remove('active'));
    
    // Clear cache when date filter changes
    clearCache(`_${currentUserEmail}_`);
    
    updateWeekDisplay(); // Update week display to show "-"
  } else {
    updateDateButtonText();
    useWeekFilter = true; // Clear date range, go back to week filter
    
    // Clear cache when date filter changes
    clearCache(`_${currentUserEmail}_`);
    
    updateWeekDisplay(); // Update week display to show week number
  }
  
  const dateDropdown = document.getElementById('dateDropdown');
  if (dateDropdown) {
    dateDropdown.classList.remove('active');
    dateDropdown.style.display = 'none';
  }
  
  // Show loaders
  showLoader('updatesFeed');
  showLoader('assignedAuditsList');
  showStatsLoader();
  
  // Reload data with filters
  Promise.all([
    loadRecentUpdates(),
    updateYourStats(),
    loadAssignedAudits(),
    loadNotifications()
  ]).then(() => {
    // Reset date button state
    if (dateBtn) {
      dateBtn.disabled = false;
      dateBtn.style.opacity = '1';
      dateBtn.style.cursor = 'pointer';
    }
    if (dateBtnText && dateBtnText.dataset.originalText) {
      dateBtnText.textContent = dateBtnText.dataset.originalText;
      delete dateBtnText.dataset.originalText;
    } else {
      updateDateButtonText();
    }
  }).catch(error => {
    console.error('Error applying date filter:', error);
    // Reset button state even on error
    if (dateBtn) {
      dateBtn.disabled = false;
      dateBtn.style.opacity = '1';
      dateBtn.style.cursor = 'pointer';
    }
    if (dateBtnText && dateBtnText.dataset.originalText) {
      dateBtnText.textContent = dateBtnText.dataset.originalText;
      delete dateBtnText.dataset.originalText;
    } else {
      updateDateButtonText();
    }
  });
}

// Use shared date filter utility - wrap to provide page-specific callbacks
// Note: home.html uses Date objects instead of date strings
// Save reference to original utility function before defining wrapper
const originalApplyQuickDateFilter = window.applyQuickDateFilter;

window.applyQuickDateFilter = function(period) {
  // Disable all quick date buttons during loading
  const quickDateButtons = document.querySelectorAll('.quick-date-btn');
  quickDateButtons.forEach(btn => {
    btn.disabled = true;
    btn.style.opacity = '0.6';
    btn.style.cursor = 'not-allowed';
  });
  
  // Check if the utility function is available
  if (typeof originalApplyQuickDateFilter !== 'function') {
    console.error('applyQuickDateFilter utility not loaded yet. Please ensure date-filter-utils.js is loaded.');
    // Fallback: try to apply the filter manually
    try {
      const today = getDhakaStartOfDay();
      let startDate, endDate;
      
      switch(period) {
        case 'today':
          startDate = getDhakaStartOfDay();
          endDate = getDhakaEndOfDay();
          break;
        case 'yesterday':
          const yesterday = new Date(today);
          yesterday.setDate(yesterday.getDate() - 1);
          startDate = getDhakaStartOfDay(yesterday);
          endDate = getDhakaEndOfDay(yesterday);
          break;
        case 'thisMonth':
          startDate = getDhakaFirstDayOfMonth(today);
          endDate = getDhakaLastDayOfMonth(today);
          break;
        default:
          // Re-enable buttons
          quickDateButtons.forEach(btn => {
            btn.disabled = false;
            btn.style.opacity = '1';
            btn.style.cursor = 'pointer';
          });
          return;
      }
      
      dateFilter.start = startDate;
      dateFilter.end = endDate;
      useWeekFilter = false;
      
      const startDateInput = document.getElementById('startDate');
      const endDateInput = document.getElementById('endDate');
      if (startDateInput) startDateInput.value = formatDateForInput(startDate);
      if (endDateInput) endDateInput.value = formatDateForInput(endDate);
      
      updateDateButtonText();
      updateWeekDisplay();
      
      // Update active state
      quickDateButtons.forEach(btn => btn.classList.remove('active'));
      const activeButton = document.getElementById(period + 'Btn');
      if (activeButton) activeButton.classList.add('active');
      
      // Show loaders
      showLoader('updatesFeed');
      showLoader('assignedAuditsList');
      showStatsLoader();
      
      // Refresh data
      Promise.all([
        loadUnifiedAuditData(),
        updateYourStats(),
        loadNotifications()
      ]).then(() => {
        // Re-enable buttons
        quickDateButtons.forEach(btn => {
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
        });
      }).catch(error => {
        console.error('Error applying quick date filter:', error);
        // Re-enable buttons even on error
        quickDateButtons.forEach(btn => {
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
        });
      });
    } catch (error) {
      console.error('Error applying quick date filter:', error);
      // Re-enable buttons on error
      quickDateButtons.forEach(btn => {
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';
      });
    }
    return;
  }
  
  originalApplyQuickDateFilter(period, {
    dateFilter: dateFilter,
    setUseWeekFilter: () => { useWeekFilter = false; },
    useDateObjects: true,
    formatDateForInput: formatDateForInput,
    onUpdate: updateWeekDisplay,
    onRefresh: () => {
      // Clear cache when quick date filter changes
      clearCache(`_${currentUserEmail}_`);
      
      // Show loaders
      showLoader('updatesFeed');
      showLoader('assignedAuditsList');
      showStatsLoader();
      
      Promise.all([
        loadUnifiedAuditData(),
        updateYourStats(),
        loadNotifications()
      ]).then(() => {
        // Re-enable buttons
        quickDateButtons.forEach(btn => {
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
        });
      }).catch(error => {
        console.error('Error applying quick date filter:', error);
        // Re-enable buttons even on error
        quickDateButtons.forEach(btn => {
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
        });
      });
    }
  });
};

// Clear date filter
function clearDateFilter() {
  dateFilter.start = null;
  dateFilter.end = null;
  const startDateInput = document.getElementById('startDate');
  const endDateInput = document.getElementById('endDate');
  const dateBtn = document.getElementById('dateBtn');
  const dateBtnText = document.getElementById('dateBtnText');
  
  if (startDateInput) startDateInput.value = '';
  if (endDateInput) endDateInput.value = '';
  
  // Show loading state on date button
  if (dateBtn) {
    dateBtn.disabled = true;
    dateBtn.style.opacity = '0.6';
    dateBtn.style.cursor = 'not-allowed';
  }
  if (dateBtnText) {
    dateBtnText.textContent = 'Loading...';
  }
  
  updateDateButtonText();
  const dateDropdown = document.getElementById('dateDropdown');
  if (dateDropdown) {
    dateDropdown.classList.remove('active');
    dateDropdown.style.display = 'none';
  }
  useWeekFilter = true; // Go back to week filter
  
  // Clear active state of quick filter buttons
  const quickDateButtons = document.querySelectorAll('.quick-date-btn');
  quickDateButtons.forEach(btn => btn.classList.remove('active'));
  
  // Clear cache when date filter is cleared
  clearCache(`_${currentUserEmail}_`);
  
  updateWeekDisplay(); // Update week display to show week number
  
  // Show loaders
  showLoader('updatesFeed');
  showLoader('assignedAuditsList');
  showStatsLoader();
  
  // Reload data with week filter
  Promise.all([
    loadUnifiedAuditData(),
    updateYourStats(),
    loadNotifications()
  ]).then(() => {
    // Reset date button state
    if (dateBtn) {
      dateBtn.disabled = false;
      dateBtn.style.opacity = '1';
      dateBtn.style.cursor = 'pointer';
    }
    if (dateBtnText) {
      updateDateButtonText();
    }
  }).catch(error => {
    console.error('Error clearing date filter:', error);
    // Reset button state even on error
    if (dateBtn) {
      dateBtn.disabled = false;
      dateBtn.style.opacity = '1';
      dateBtn.style.cursor = 'pointer';
    }
    if (dateBtnText) {
      updateDateButtonText();
    }
  });
}

// Apply filters
function applyFilters() {
  const channelSelect = document.getElementById('filterChannel');
  const statusSelect = document.getElementById('filterStatus');
  const agentSelect = document.getElementById('filterAgent');
  const filterBtn = document.getElementById('filterBtn');
  const filterBtnIcon = document.getElementById('filterBtnIcon');
  const filterBtnText = document.getElementById('filterBtnText');
  
  currentFilters.channel = channelSelect ? channelSelect.value : '';
  currentFilters.status = statusSelect ? statusSelect.value : '';
  currentFilters.agent = agentSelect ? agentSelect.value : '';
  
  // Show loading state on filter button
  if (filterBtn) {
    filterBtn.disabled = true;
    filterBtn.style.opacity = '0.6';
    filterBtn.style.cursor = 'not-allowed';
  }
  if (filterBtnIcon) {
    filterBtnIcon.classList.add('animate-spin');
    filterBtnIcon.setAttribute('viewBox', '0 0 24 24');
    filterBtnIcon.innerHTML = '<circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" fill="none"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>';
  }
  if (filterBtnText) {
    filterBtnText.textContent = 'Applying...';
  }
  
  // Clear cache when filters change
  clearCache(`_${currentUserEmail}_`);
  
  // Show loaders
  showLoader('updatesFeed');
  showLoader('assignedAuditsList');
  showStatsLoader();
  
  // Reload data with filters
  Promise.all([
    loadRecentUpdates(),
    updateYourStats(),
    loadAssignedAudits(),
    loadNotifications()
  ]).then(() => {
    // Reset filter button state
    if (filterBtn) {
      filterBtn.disabled = false;
      filterBtn.style.opacity = '1';
      filterBtn.style.cursor = 'pointer';
    }
    if (filterBtnIcon) {
      filterBtnIcon.classList.remove('animate-spin');
      filterBtnIcon.setAttribute('viewBox', '0 0 24 24');
      filterBtnIcon.setAttribute('fill', 'none');
      filterBtnIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"></path>';
    }
    if (filterBtnText) {
      filterBtnText.textContent = 'Filter';
    }
  }).catch(error => {
    console.error('Error applying filters:', error);
    // Reset filter button state even on error
    if (filterBtn) {
      filterBtn.disabled = false;
      filterBtn.style.opacity = '1';
      filterBtn.style.cursor = 'pointer';
    }
    if (filterBtnIcon) {
      filterBtnIcon.classList.remove('animate-spin');
      filterBtnIcon.setAttribute('viewBox', '0 0 24 24');
      filterBtnIcon.setAttribute('fill', 'none');
      filterBtnIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"></path>';
    }
    if (filterBtnText) {
      filterBtnText.textContent = 'Filter';
    }
  });
}

// Populate filter options
async function populateFilters() {
  try {
    // Check cache first
    const cacheKey = `filters_${currentUserEmail}`;
    const cachedData = sessionStorage.getItem(cacheKey);
    const cachedTime = sessionStorage.getItem(cacheKey + '_time');
    const cacheAge = cachedTime ? Date.now() - parseInt(cachedTime) : Infinity;
    
    if (cachedData && cacheAge < 120000) { // 2 minutes cache (filters change less frequently)
      const filtersData = JSON.parse(cachedData);
      renderFiltersFromData(filtersData);
      return;
    }
    
    // Show loader in filter selects (optional, since filters load quickly)
    const channelSelect = document.getElementById('filterChannel');
    const agentSelect = document.getElementById('filterAgent');
    if (channelSelect) {
      channelSelect.disabled = true;
      channelSelect.innerHTML = '<option value="">Loading channels...</option>';
    }
    if (agentSelect) {
      agentSelect.disabled = true;
      agentSelect.innerHTML = '<option value="">Loading agents...</option>';
    }
    
    await fetchAndCacheFilters();
    
    // Re-enable selects after loading
    if (channelSelect) channelSelect.disabled = false;
    if (agentSelect) agentSelect.disabled = false;
  } catch (error) {
    console.error('Error populating filters:', error);
    const channelSelect = document.getElementById('filterChannel');
    const agentSelect = document.getElementById('filterAgent');
    if (channelSelect) {
      channelSelect.disabled = false;
      channelSelect.innerHTML = '<option value="">Error loading channels</option>';
    }
    if (agentSelect) {
      agentSelect.disabled = false;
      agentSelect.innerHTML = '<option value="">Error loading agents</option>';
    }
  }
}

async function fetchAndCacheFilters() {
  try {
    // Load all assignments for filter population (without filters)
    let allAssignmentsForFilters = [];
    
    if (isAgent) {
      // For agents, load all completed audits to get channels
      const { data: scorecards, error: scError } = await window.supabaseClient
        .from('scorecards')
        .select('table_name')
        .eq('is_active', true);
      
      if (!scError && scorecards) {
        for (const scorecard of scorecards) {
          try {
            const { data: audits, error } = await window.supabaseClient
              .from(scorecard.table_name)
              .select('channel, employee_email')
              .eq('employee_email', currentUserEmail);
            
            if (!error && audits) {
              allAssignmentsForFilters = allAssignmentsForFilters.concat(audits);
            }
          } catch (err) {
            console.warn(`Error loading audits for filters from ${scorecard.table_name}:`, err);
          }
        }
      }
    } else {
      // For auditors, load all assignments from audit tables
      const { data: scorecards, error: scError } = await window.supabaseClient
        .from('scorecards')
        .select('table_name')
        .eq('is_active', true);
      
      if (!scError && scorecards) {
        const assignmentPromises = scorecards.map(async (scorecard) => {
          try {
            // Query scorecard tables (all audits in scorecard tables are completed by default)
            let { data: audits, error } = await window.supabaseClient
              .from(scorecard.table_name)
              .select('channel, employee_email')
              .eq('auditor_email', currentUserEmail);
            
            if (error) {
              // If error, table might not have auditor_email column - skip this table silently
              // Don't log warning as this is expected for some tables
              return [];
            }
            
            if (!error && audits) {
              return audits;
            }
            return [];
          } catch (err) {
            console.warn(`Error loading from ${scorecard.table_name}:`, err);
            return [];
          }
        });
        
        const assignmentResults = await Promise.all(assignmentPromises);
        allAssignmentsForFilters = assignmentResults.flat();
      }
    }
    
    // Populate channels
    const channels = [...new Set(allAssignmentsForFilters.map(a => a.channel).filter(Boolean))].sort();
    const agents = !isAgent ? [...new Set(allAssignmentsForFilters.map(a => a.employee_email).filter(Boolean))].sort() : [];
    
    // Cache the results
    const filtersData = { channels, agents };
    const cacheKey = `filters_${currentUserEmail}`;
    sessionStorage.setItem(cacheKey, JSON.stringify(filtersData));
    sessionStorage.setItem(cacheKey + '_time', Date.now().toString());
    
    // Update UI with fresh data
    renderFiltersFromData(filtersData);
  } catch (error) {
    console.error('Error populating filters:', error);
  }
}

function renderFiltersFromData(filtersData) {
  const { channels, agents } = filtersData;
  
  // Populate channels
  const channelSelect = document.getElementById('filterChannel');
  if (channelSelect) {
    const existingValue = channelSelect.value;
    channelSelect.innerHTML = '<option value="">All Channels</option>';
    channels.forEach(channel => {
      const option = document.createElement('option');
      option.value = channel;
      option.textContent = channel;
      channelSelect.appendChild(option);
    });
    if (existingValue) channelSelect.value = existingValue;
  }

  // Populate agents (only for auditors)
  if (!isAgent) {
    const agentSelect = document.getElementById('filterAgent');
    const agentGroup = document.getElementById('filterAgentGroup');
    if (agentSelect && agentGroup) {
      const existingValue = agentSelect.value;
      agentSelect.innerHTML = '<option value="">All Agents</option>';
      agents.forEach(agent => {
        const option = document.createElement('option');
        option.value = agent;
        option.textContent = formatAgentName(agent);
        agentSelect.appendChild(option);
      });
      if (existingValue) agentSelect.value = existingValue;
      agentGroup.style.display = 'flex';
    }
  }
}

function formatAgentName(email) {
  if (!email || email === 'Unknown') return 'Unknown';
  return email.split('@')[0].replace(/\./g, ' ').replace(/\b\w/g, l => l.toUpperCase());
}

// Clear cache for a specific pattern
function clearCache(pattern) {
  const keys = Object.keys(sessionStorage);
  keys.forEach(key => {
    if (key.includes(pattern)) {
      sessionStorage.removeItem(key);
    }
  });
}

// Loading state management
function showLoader(elementId, loadingHtml = null) {
  const element = document.getElementById(elementId);
  if (!element) return;
  
  if (loadingHtml) {
    element.innerHTML = loadingHtml;
  } else {
    // Default loading skeleton
    if (elementId.includes('Feed') || elementId.includes('List')) {
      element.innerHTML = `
        <div class="px-4 py-8 text-center">
          <div class="inline-flex items-center gap-2 text-gray-500 text-xs">
            <svg class="animate-spin h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
              <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span>Loading...</span>
          </div>
        </div>
      `;
    }
  }
}

function showStatsLoader() {
  // Show loading state for stats cards
  const statsElements = [
    'statsAuditsConductedCount',
    'statsAvgQualityScore',
    'statsPassRate',
    'statsRemainingCount',
    'statsRequiresAcknowledgmentCount',
    'statsReversalTotalCount',
    'statsInProgressCount',
    'statsAvgDuration'
  ];
  
  statsElements.forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.innerHTML = '<div class="h-8 w-16 bg-gray-200 rounded animate-pulse"></div>';
    }
  });
  
  // Reset progress bar
  const progressEl = document.getElementById('statsRemainingProgress');
  if (progressEl) {
    progressEl.style.width = '0%';
  }
}

// Helper function to check if date is within filter range
function isDateInRange(date, filterStart, filterEnd) {
  // If no filters, check against current period (week or date range)
  if (!filterStart && !filterEnd) {
    const period = getCurrentPeriodDates();
    filterStart = period.start;
    filterEnd = period.end;
  }
  
  if (!filterStart && !filterEnd) return true;
  const checkDate = new Date(date);
  checkDate.setHours(0, 0, 0, 0);
  
  if (filterStart) {
    const start = new Date(filterStart);
    start.setHours(0, 0, 0, 0);
    if (checkDate < start) return false;
  }
  
  if (filterEnd) {
    const end = new Date(filterEnd);
    end.setHours(23, 59, 59, 999);
    if (checkDate > end) return false;
  }
  
  return true;
}

// Setup event listeners to replace inline handlers (CSP compliance)
function setupEventListenersForCSP() {
  // Event delegation for dynamically generated content (CSP compliance)
  document.addEventListener('click', (e) => {
    // Don't interfere with date dropdown clicks - handled separately
    if (e.target.closest('.date-picker-dropdown') || e.target.closest('#dateDropdown')) {
      return;
    }
    // Handle audit details/assignment clicks
    const auditTarget = e.target.closest('[data-audit-id]');
    if (auditTarget && auditTarget.dataset.auditId) {
      const auditId = auditTarget.dataset.auditId;
      const scorecardId = auditTarget.dataset.scorecardId || '';
      const scorecardTable = auditTarget.dataset.scorecardTable || '';
      
      if (auditTarget.dataset.action === 'view-details') {
        e.stopPropagation();
        if (typeof viewAuditDetails === 'function') {
          viewAuditDetails(auditId, scorecardId, scorecardTable);
        }
      } else if (auditTarget.dataset.action === 'view-assignment') {
        e.stopPropagation();
        if (typeof viewAudit === 'function') {
          viewAudit(auditId);
        }
      }
      return;
    }
    
    // Handle notification clicks
    const notificationTarget = e.target.closest('[data-notification-id]');
    if (notificationTarget && notificationTarget.dataset.notificationId) {
      if (typeof handleNotificationClick === 'function') {
        handleNotificationClick(notificationTarget.dataset.notificationId);
      }
      return;
    }
    
    // Handle create audit actions
    const createAuditTarget = e.target.closest('[data-action="create-audit"]');
    if (createAuditTarget) {
      e.stopPropagation();
      window.location.href = '/create-audit';
      return;
    }
  });
  
  // Create Audit button
  const createAuditBtn = document.getElementById('createAuditBtn');
  if (createAuditBtn) {
    createAuditBtn.addEventListener('click', () => {
      window.location.href = '/create-audit';
    });
  }
  
  // Search button
  const searchBtn = document.getElementById('searchBtn');
  if (searchBtn) {
    searchBtn.addEventListener('click', () => {
      window.location.href = 'search.html';
    });
  }
  
  // Notifications modal close buttons (first button in modal header)
  const notificationsModal = document.getElementById('notificationsModal');
  if (notificationsModal) {
    const notificationCloseBtn = notificationsModal.querySelector('.notification-panel-close');
    if (notificationCloseBtn) {
      notificationCloseBtn.addEventListener('click', hideNotifications);
    }
    notificationsModal.addEventListener('mouseleave', hideNotifications);
  }
  
  // Calendar modal close buttons
  const calendarModal = document.getElementById('calendarModal');
  if (calendarModal) {
    const calendarCloseBtn = calendarModal.querySelector('.px-4.py-3 button');
    if (calendarCloseBtn && calendarCloseBtn.id !== 'manageEventsBtn') {
      calendarCloseBtn.addEventListener('click', hideCalendar);
    }
    calendarModal.addEventListener('mouseleave', hideCalendar);
  }
  
  // Calendar manage events button
  const manageEventsBtn = document.getElementById('manageEventsBtn');
  if (manageEventsBtn) {
    manageEventsBtn.addEventListener('click', () => {
      window.location.href = 'event-management.html';
    });
  }
  
  // Grid modal close buttons
  const gridModal = document.getElementById('gridModal');
  if (gridModal) {
    const gridCloseBtn = gridModal.querySelector('.px-4.py-3 button');
    if (gridCloseBtn) {
      gridCloseBtn.addEventListener('click', hideGrid);
    }
    gridModal.addEventListener('mouseleave', hideGrid);
  }
  
  // Quick action buttons
  const quickActionCreateAudit = document.getElementById('quickActionCreateAudit');
  if (quickActionCreateAudit) {
    quickActionCreateAudit.addEventListener('click', () => {
      window.location.href = '/create-audit';
    });
  }
  
  const quickActionReports = document.getElementById('quickActionReports');
  if (quickActionReports) {
    quickActionReports.addEventListener('click', () => {
      window.location.href = 'audit-reports.html';
    });
  }
  
  const quickActionEvents = document.getElementById('quickActionEvents');
  if (quickActionEvents) {
    quickActionEvents.addEventListener('click', () => {
      window.location.href = 'event-management.html';
    });
  }
  
  const quickActionSettings = document.getElementById('quickActionSettings');
  if (quickActionSettings) {
    quickActionSettings.addEventListener('click', () => {
      window.location.href = 'settings.html';
    });
  }
  
  // User avatar
  const userAvatar = document.getElementById('userAvatar');
  if (userAvatar) {
    userAvatar.addEventListener('click', () => {
      window.location.href = 'profile.html';
    });
  }
  
  // Avatar logout menu mouseleave
  const avatarLogoutMenu = document.getElementById('avatarLogoutMenu');
  if (avatarLogoutMenu) {
    avatarLogoutMenu.addEventListener('mouseleave', hideAvatarLogout);
  }
  
  // Logout buttons (using class selector since we added .logout-btn class)
  const logoutBtns = document.querySelectorAll('.logout-btn');
  logoutBtns.forEach(btn => {
    btn.addEventListener('click', logout);
  });
  
  // Quick date filter buttons
  const todayBtn = document.getElementById('todayBtn');
  if (todayBtn) {
    todayBtn.addEventListener('click', () => applyQuickDateFilter('today'));
  }
  
  const yesterdayBtn = document.getElementById('yesterdayBtn');
  if (yesterdayBtn) {
    yesterdayBtn.addEventListener('click', () => applyQuickDateFilter('yesterday'));
  }
  
  const thisMonthBtn = document.getElementById('thisMonthBtn');
  if (thisMonthBtn) {
    thisMonthBtn.addEventListener('click', () => applyQuickDateFilter('thisMonth'));
  }
  
  const lastMonthBtn = document.getElementById('lastMonthBtn');
  if (lastMonthBtn) {
    lastMonthBtn.addEventListener('click', () => applyQuickDateFilter('lastMonth'));
  }
  
}

// Track if dashboard has been initialized to prevent duplicate initialization
let dashboardInitialized = false;

// Initialize Dashboard
document.addEventListener('DOMContentLoaded', async function() {
  // Setup CSP-compliant event listeners first
  setupEventListenersForCSP();
  
  // Then initialize dashboard
  await initializeDashboard();
  
  // Check if initialization was successful (user email was found)
  if (currentUserEmail) {
    dashboardInitialized = true;
  } else {
    // If no user email found, set up retry mechanism for first-login scenario
    
    let retryCount = 0;
    const maxRetries = 10; // Try for up to 5 seconds (10 * 500ms)
    const retryInterval = setInterval(async () => {
      retryCount++;
      
      // Check if userInfo is now available in localStorage
      const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
      if (userInfo.email) {
        clearInterval(retryInterval);
        if (!dashboardInitialized) {
          await initializeDashboard();
          dashboardInitialized = true;
        }
        return;
      }
      
      // Also try to get from Supabase session
      if (window.supabaseClient && !dashboardInitialized) {
        try {
          const { data: { user }, error: userError } = await window.supabaseClient.auth.getUser();
          if (user && !userError && user.email) {
            clearInterval(retryInterval);
            if (!dashboardInitialized) {
              await initializeDashboard();
              dashboardInitialized = true;
            }
            return;
          }
        } catch (error) {
          // Continue retrying
        }
      }
      
      // Stop retrying after max attempts
      if (retryCount >= maxRetries) {
        console.warn(' Max retries reached, dashboard initialization failed');
        clearInterval(retryInterval);
      }
    }, 500); // Check every 500ms
  }
  
  // Listen for storage events (fires when localStorage is updated in other tabs)
  window.addEventListener('storage', async function(e) {
    if (e.key === 'userInfo' && e.newValue && !dashboardInitialized) {
      if (!dashboardInitialized) {
        await initializeDashboard();
        dashboardInitialized = true;
      }
    }
  });
  
  // Listen for custom event that might be dispatched when userInfo is set
  window.addEventListener('userInfoUpdated', async function() {
    if (!dashboardInitialized) {
      const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
      if (userInfo.email) {
        await initializeDashboard();
        dashboardInitialized = true;
      }
    }
  });
});

// Wait for Supabase with better strategy (updated to match new initialization pattern)
async function waitForSupabase(maxWait = 10000) {
  // OPTIMIZATION: Check if already ready immediately (instant return)
  if (window.supabaseClient && window.supabaseReady) {
    return true;
  }
  
  // Wait for supabaseReady event with optimized polling
  return new Promise((resolve) => {
    const startTime = Date.now();
    
    // Double-check if already ready
    if (window.supabaseClient && window.supabaseReady) {
      resolve(true);
      return;
    }
    
    // OPTIMIZATION: Use both event listener AND fast polling for quicker detection
    // Polling every 50ms catches ready state faster than waiting for event
    let pollInterval;
    
    const checkReady = () => {
      if (window.supabaseClient && window.supabaseReady) {
        if (pollInterval) clearInterval(pollInterval);
        window.removeEventListener('supabaseReady', onReady);
        resolve(true);
        return true;
      }
      return false;
    };
    
    // Listen for supabaseReady event
    const onReady = () => {
      if (checkReady()) return;
    };
    
    window.addEventListener('supabaseReady', onReady, { once: true });
    
    // Fast polling for quicker detection (50ms intervals)
    pollInterval = setInterval(() => {
      if (checkReady()) return;
      // Timeout check
      if (Date.now() - startTime >= maxWait) {
        clearInterval(pollInterval);
        window.removeEventListener('supabaseReady', onReady);
        resolve(window.supabaseClient && window.supabaseReady);
      }
    }, 50);
    
    // Fallback timeout (backup, polling should handle this)
    setTimeout(() => {
      if (pollInterval) clearInterval(pollInterval);
      window.removeEventListener('supabaseReady', onReady);
      if (window.supabaseClient && window.supabaseReady) {
        resolve(true);
      } else {
        console.warn('Timeout waiting for Supabase client');
        resolve(false);
      }
    }, maxWait);
  });
}

// Helper function to get authenticated Supabase client for database operations
// This is used as a fallback if the proxy wrapper isn't ready yet
let getAuthenticatedDbFn = null;
async function getAuthenticatedDb() {
  if (!getAuthenticatedDbFn) {
    const module = await import('/js/utils/authenticated-supabase.js');
    getAuthenticatedDbFn = module.getAuthenticatedSupabase;
  }
  return await getAuthenticatedDbFn();
}

async function initializeDashboard() {
  try {
    // OPTIMIZATION: Start multiple operations in parallel for faster first load
    const startTime = performance.now();
    
    // Ensure date dropdown is closed on initialization
    const dateDropdown = document.getElementById('dateDropdown');
    if (dateDropdown) {
      dateDropdown.classList.remove('active');
      dateDropdown.style.display = 'none';
    }
    
    // OPTIMIZATION: Start module preloading in parallel with Supabase wait
    // This saves ~200-500ms on first load by loading modules while waiting for auth
    const modulePreloadPromise = Promise.all([
      import('/js/features/home/infrastructure/unified-data-service.js').catch(() => null),
      import('/js/features/home/infrastructure/cache-aware-loader.js').catch(() => null),
      import('/js/features/home/infrastructure/persistent-cache-service.js').catch(() => null),
      import('/js/utils/authenticated-supabase.js').catch(() => null)
    ]);
    
    // Wait for Supabase authenticated client to be ready
    // OPTIMIZATION: Reduced timeout to 3s for faster failure detection
    const supabaseReady = await waitForSupabase(3000);
    if (!supabaseReady) {
      console.error('Supabase client not ready after timeout');
      return;
    }

    // Get current user - try Supabase session first (works on first login), then fallback to localStorage
    let userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
    
    // On first login, localStorage might not have userInfo yet, so get it from Supabase session
    if (!userInfo.email && window.supabaseClient) {
      try {
        const { data: { user }, error: userError } = await window.supabaseClient.auth.getUser();
        if (user && !userError && user.email) {
          // Got user from Supabase session - use it and optionally update localStorage
          currentUserEmail = user.email.toLowerCase().trim();
          
          // Try to get role from people table or use default
          try {
            const { getAuthenticatedSupabase } = await import('/js/utils/authenticated-supabase.js');
            const supabase = await getAuthenticatedSupabase();
            const { data: peopleData } = await supabase
              .from('people')
              .select('role, department, designation, team')
              .eq('email', currentUserEmail)
              .maybeSingle();
            
            currentUserRole = peopleData?.role || 'Employee';
            
            // Update userInfo with data from Supabase and people table
            userInfo = {
              ...userInfo,
              id: user.id,
              email: user.email,
              name: user.user_metadata?.full_name || user.email?.split('@')[0] || 'User',
              avatar: user.user_metadata?.avatar_url || user.user_metadata?.picture || null,
              picture: user.user_metadata?.avatar_url || user.user_metadata?.picture || null,
              avatar_url: user.user_metadata?.avatar_url || null,
              role: currentUserRole,
              department: peopleData?.department || null,
              designation: peopleData?.designation || null,
              team: peopleData?.team || null,
            };
            
            // Save to localStorage for future loads
            localStorage.setItem('userInfo', JSON.stringify(userInfo));
          } catch (peopleError) {
            console.warn('Could not fetch people data, using default role:', peopleError);
            currentUserRole = 'Employee';
            userInfo = {
              ...userInfo,
              id: user.id,
              email: user.email,
              name: user.user_metadata?.full_name || user.email?.split('@')[0] || 'User',
              role: 'Employee',
            };
            localStorage.setItem('userInfo', JSON.stringify(userInfo));
          }
        }
      } catch (error) {
        console.warn(' Error getting user from Supabase session, trying localStorage:', error);
      }
    }
    
    // Fallback to localStorage if Supabase session didn't work
    if (!currentUserEmail) {
      currentUserEmail = (userInfo.email || '').toLowerCase().trim();
      currentUserRole = userInfo.role || '';
    }
    
    isAgent = currentUserRole === 'Employee';

    if (!currentUserEmail) {
      console.error('No user logged in - cannot load dashboard');
      return;
    }

    // Initialize UI immediately
    initializeDateFilter();
    setupEventListeners();
    // Ensure week display is properly initialized after event listeners are set up
    updateWeekDisplay();
    updateUserAvatar(userInfo);

    // Section title is "Recents" for all roles (set in HTML)
    if (isAgent) {
      const createAuditBtn = document.getElementById('createAuditBtn');
      if (createAuditBtn) createAuditBtn.style.display = 'none';
      // Hide Create Audit and Settings from Quick Actions for employees
      const quickActionCreateAudit = document.getElementById('quickActionCreateAudit');
      if (quickActionCreateAudit) quickActionCreateAudit.style.display = 'none';
      const quickActionSettings = document.getElementById('quickActionSettings');
      if (quickActionSettings) quickActionSettings.style.display = 'none';
      const inProgressCard = document.getElementById('inProgressCard');
      if (inProgressCard) inProgressCard.style.display = 'none';
      const avgDurationCard = document.getElementById('avgDurationCard');
      if (avgDurationCard) avgDurationCard.style.display = 'none';
      const auditsConductedCard = document.getElementById('auditsConductedCard');
      if (auditsConductedCard) auditsConductedCard.style.display = 'none';
      const remainingCard = document.getElementById('remainingCard');
      if (remainingCard) remainingCard.style.display = 'none';
      // Hide average quality score card for agents
      const avgQualityScoreCard = document.getElementById('avgQualityScoreCard');
      if (avgQualityScoreCard) avgQualityScoreCard.style.display = 'none';
      // Show pass rate card for agents
      const passRateCard = document.getElementById('passRateCard');
      if (passRateCard) passRateCard.style.display = 'block';
      // Show acknowledgment card for agents
      const requiresAcknowledgmentCard = document.getElementById('requiresAcknowledgmentCard');
      if (requiresAcknowledgmentCard) requiresAcknowledgmentCard.style.display = 'block';
    } else if (currentUserRole === 'Admin' || currentUserRole === 'Super Admin') {
      // Hide pass rate card for admins
      const passRateCard = document.getElementById('passRateCard');
      if (passRateCard) passRateCard.style.display = 'none';
      // Hide acknowledgment card for admins
      const requiresAcknowledgmentCard = document.getElementById('requiresAcknowledgmentCard');
      if (requiresAcknowledgmentCard) requiresAcknowledgmentCard.style.display = 'none';
      // Ensure avgDuration card is visible for admins
      const avgDurationCard = document.getElementById('avgDurationCard');
      if (avgDurationCard) avgDurationCard.style.display = 'block';
      // Ensure average quality score card is visible for admins
      const avgQualityScoreCard = document.getElementById('avgQualityScoreCard');
      if (avgQualityScoreCard) avgQualityScoreCard.style.display = 'block';
      const auditsConductedCard = document.getElementById('auditsConductedCard');
      if (auditsConductedCard) auditsConductedCard.style.display = 'block';
      const remainingCard = document.getElementById('remainingCard');
      if (remainingCard) remainingCard.style.display = 'block';
    } else if (currentUserRole === 'Quality Analyst') {
      // Hide pass rate card for quality analysts
      const passRateCard = document.getElementById('passRateCard');
      if (passRateCard) passRateCard.style.display = 'none';
      // Hide acknowledgment card for quality analysts
      const requiresAcknowledgmentCard = document.getElementById('requiresAcknowledgmentCard');
      if (requiresAcknowledgmentCard) requiresAcknowledgmentCard.style.display = 'none';
      // Ensure avgDuration card is visible
      const avgDurationCard = document.getElementById('avgDurationCard');
      if (avgDurationCard) avgDurationCard.style.display = 'block';
      // Ensure average quality score card is visible
      const avgQualityScoreCard = document.getElementById('avgQualityScoreCard');
      if (avgQualityScoreCard) avgQualityScoreCard.style.display = 'block';
      const auditsConductedCard = document.getElementById('auditsConductedCard');
      if (auditsConductedCard) auditsConductedCard.style.display = 'block';
      const remainingCard = document.getElementById('remainingCard');
      if (remainingCard) remainingCard.style.display = 'block';
    } else {
      // Auditors
      // Hide pass rate card for auditors
      const passRateCard = document.getElementById('passRateCard');
      if (passRateCard) passRateCard.style.display = 'none';
      // Hide acknowledgment card for auditors
      const requiresAcknowledgmentCard = document.getElementById('requiresAcknowledgmentCard');
      if (requiresAcknowledgmentCard) requiresAcknowledgmentCard.style.display = 'none';
      // Ensure avgDuration card is visible for auditors
      const avgDurationCard = document.getElementById('avgDurationCard');
      if (avgDurationCard) avgDurationCard.style.display = 'block';
      // Ensure average quality score card is visible for auditors
      const avgQualityScoreCard = document.getElementById('avgQualityScoreCard');
      if (avgQualityScoreCard) avgQualityScoreCard.style.display = 'block';
      const auditsConductedCard = document.getElementById('auditsConductedCard');
      if (auditsConductedCard) auditsConductedCard.style.display = 'block';
      const remainingCard = document.getElementById('remainingCard');
      if (remainingCard) remainingCard.style.display = 'block';
    }
    
    // Update sort options
    const statusAscOption = document.getElementById('statusAscOption');
    const statusDescOption = document.getElementById('statusDescOption');
    if (statusAscOption) statusAscOption.textContent = 'Status (Pending  In Progress)';
    if (statusDescOption) statusDescOption.textContent = 'Status (In Progress  Pending)';
    if (!isAgent) {
      sortBy = 'status_desc';
      const auditSortBy = document.getElementById('auditSortBy');
      if (auditSortBy) auditSortBy.value = 'status_desc';
    }

    // Supabase client is already ready (waited at start of function)
    // All database operations will now use authenticated client with RLS enforcement

    // OPTIMIZATION: Use preloaded modules (already loading in parallel with Supabase wait)
    // This avoids sequential module loading which adds ~200-500ms
    const preloadedModules = await modulePreloadPromise;
    const [unifiedDataModule, cacheLoaderModule, persistentCacheModule, authSupabaseModule] = preloadedModules;
    
    // Load data in optimized order - users first, then everything in parallel
    // Use persistent cache for instant display
    try {
      const unifiedDataService = unifiedDataModule?.unifiedDataService;
      const getCachedSync = cacheLoaderModule?.getCachedSync;
      const buildCacheKey = cacheLoaderModule?.buildCacheKey;
      
      // Try to get cached users immediately from sessionStorage (faster than IndexedDB)
      const cachedUsers = sessionStorage.getItem('cachedUsers');
      const cachedUsersTime = sessionStorage.getItem('cachedUsersTime');
      const cacheAge = cachedUsersTime ? Date.now() - parseInt(cachedUsersTime) : Infinity;
      
      if (cachedUsers && cacheAge < 120000) { // 2 minutes cache
        allUsers = JSON.parse(cachedUsers);
      } else if (getCachedSync) {
        // Fallback to persistent cache
        const cachedUsersData = await getCachedSync('users_all');
        if (cachedUsersData) {
          allUsers = cachedUsersData;
        }
      }
      
      // OPTIMIZATION: Load cached data in parallel for instant display (stale-while-revalidate)
      if (getCachedSync && buildCacheKey) {
        const period = getCurrentPeriodDates();
        const statsCacheKey = buildCacheKey('stats', currentUserEmail, JSON.stringify(period), JSON.stringify(currentFilters));
        const auditsCacheKey = buildCacheKey('assignedAudits', currentUserEmail, JSON.stringify(period), JSON.stringify(currentFilters), sortBy);
        const updatesCacheKey = buildCacheKey('recentUpdates', currentUserEmail, JSON.stringify(period), JSON.stringify(currentFilters));
        
        // Load all cached data in parallel
        const [cachedStats, cachedAudits, cachedUpdates] = await Promise.all([
          getCachedSync(statsCacheKey),
          getCachedSync(auditsCacheKey),
          getCachedSync(updatesCacheKey)
        ]);
        
        // Render cached data immediately if available
        if (cachedStats && typeof renderStatsFromData === 'function') {
          renderStatsFromData(cachedStats);
        }
        if (cachedAudits) {
          assignedAudits = cachedAudits;
          if (typeof renderAssignedAudits === 'function') {
            renderAssignedAudits();
          }
        }
        if (cachedUpdates && typeof renderRecentUpdatesFromData === 'function') {
          renderRecentUpdatesFromData(cachedUpdates);
        }
      }
      
      // Load users if not cached (non-blocking, in background)
      if (!allUsers || allUsers.length === 0) {
        // Load users using HTML function (home-data-loader.js module removed)
        (async () => {
          try {
            if (typeof loadAllUsers === 'function') {
              await loadAllUsers();
            }
          } catch (error) {
            console.warn('Failed to load users:', error);
          }
        })();
      }
    } catch (error) {
      console.warn('Failed to use persistent cache, falling back to sessionStorage:', error);
      // Fallback to sessionStorage
      const cachedUsers = sessionStorage.getItem('cachedUsers');
      const cachedUsersTime = sessionStorage.getItem('cachedUsersTime');
      const cacheAge = cachedUsersTime ? Date.now() - parseInt(cachedUsersTime) : Infinity;
      
      if (cachedUsers && cacheAge < 120000) { // 2 minutes cache
        allUsers = JSON.parse(cachedUsers);
      } else {
        // Load users in background (non-blocking)
        (async () => {
          try {
            if (typeof loadAllUsers === 'function') {
              await loadAllUsers();
            }
          } catch (error) {
            console.warn('Failed to load users:', error);
          }
        })();
      }
    }

    // OPTIMIZATION: Show loading indicators immediately for better perceived performance
    // These appear while data is being fetched from the server
    if (typeof showStatsLoader === 'function') showStatsLoader();
    if (typeof showLoader === 'function') {
      showLoader('assignedAuditsList');
      showLoader('updatesFeed');
    }

    // OPTIMIZATION: Load ALL data in parallel for maximum speed
    // All data sections load simultaneously for faster perceived performance
    const dataLoadStart = performance.now();
    
    // Use HTML functions with parallel loading
    // Each function has its own error handling to prevent one failure from blocking others
    const promises = [];
    
    if (typeof updateYourStats === 'function') {
      promises.push(updateYourStats().catch(err => console.error('Error loading stats:', err)));
    }
    if (typeof loadUnifiedAuditData === 'function') {
      promises.push(loadUnifiedAuditData().catch(err => console.error('Error loading unified audit data:', err)));
    }
    if (typeof loadNotifications === 'function') {
      promises.push(loadNotifications().catch(err => console.error('Error loading notifications:', err)));
    }
    if (typeof loadUpcomingEvents === 'function') {
      promises.push(loadUpcomingEvents().catch(err => console.error('Error loading events:', err)));
    }
    
    await Promise.all(promises);

    // Populate filter options after loading data (non-blocking)
    populateFilters().catch(err => console.error('Error populating filters:', err));

    // Initialize intelligent data refresh service
    // This replaces full page reloads with selective section updates
    (async () => {
      try {
        const { dataRefreshService } = await import('/js/features/home/infrastructure/data-refresh-service.js');
        
        // Register refresh functions for each section
        dataRefreshService.registerSection('stats', updateYourStats);
        dataRefreshService.registerSection('assignedAudits', loadAssignedAudits);
        dataRefreshService.registerSection('recentUpdates', loadRecentUpdates);
        dataRefreshService.registerSection('notifications', loadNotifications);
        dataRefreshService.registerSection('events', loadUpcomingEvents);
        
        // Start automatic refresh (every 2 minutes)
        dataRefreshService.start(120000);
      } catch (err) {
        console.warn('Data refresh service not available, using fallback:', err);
        // Fallback to simple interval refresh
        setInterval(() => {
          if (!document.hidden) {
            Promise.all([
              updateYourStats().catch(err => console.warn('Error refreshing stats:', err)),
              loadUnifiedAuditData().catch(err => console.warn('Error refreshing unified audit data:', err))
            ]);
          }
        }, 120000);
      }
    })();

    // Listen for real-time audit assignments (subscription is set up globally by sidebar)
    setupAuditAssignmentReceivedListener();

  } catch (error) {
    console.error('Error initializing dashboard:', error);
  }
}

// Listen for auditAssignmentReceived (dispatched by shared realtime module when assignments change)
function setupAuditAssignmentReceivedListener() {
  if (isAgent) return;

  document.addEventListener('auditAssignmentReceived', async () => {
    try {
      const { buildCacheKey } = await import('/js/features/home/infrastructure/cache-aware-loader.js');
      const period = getCurrentPeriodDates();
      const cacheKey = buildCacheKey('assignedAudits', currentUserEmail, JSON.stringify(period), JSON.stringify(currentFilters), sortBy);
      const { persistentCacheService } = await import('/js/features/home/infrastructure/persistent-cache-service.js');
      await persistentCacheService.delete(cacheKey);
      const sessionCacheKey = `assignedAudits_${currentUserEmail}_${JSON.stringify(period)}_${JSON.stringify(currentFilters)}_${sortBy}`;
      sessionStorage.removeItem(sessionCacheKey);
      sessionStorage.removeItem(sessionCacheKey + '_time');
    } catch (cacheError) {
      console.warn('Error clearing cache:', cacheError);
    }
    if (typeof loadAssignedAudits === 'function') {
      loadAssignedAudits().catch(err => console.error('Error refreshing assigned audits:', err));
    }
    // Refresh notification bell so "Audit assigned" appears in the dropdown
    const notificationsCacheKey = `notifications_${currentUserEmail}`;
    sessionStorage.removeItem(notificationsCacheKey);
    sessionStorage.removeItem(notificationsCacheKey + '_time');
    sessionStorage.removeItem(notificationsCacheKey + '_unread');
    if (typeof loadNotifications === 'function') {
      loadNotifications().catch(err => console.warn('Error refreshing notifications:', err));
    }
  });
}

function setupEventListeners() {
  // Week navigation buttons
  const prevWeekBtn = document.getElementById('prevWeekBtn');
  const nextWeekBtn = document.getElementById('nextWeekBtn');
  const weekDisplay = document.getElementById('weekDisplay');
  
  if (prevWeekBtn) {
    prevWeekBtn.addEventListener('click', () => navigateWeek(-1));
  }
  if (nextWeekBtn) {
    nextWeekBtn.addEventListener('click', () => navigateWeek(1));
  }
  
  // Make week display clickable to switch to week view when in month/date range view
  if (weekDisplay) {
    weekDisplay.addEventListener('click', function(e) {
      e.stopPropagation();
      if (!useWeekFilter) {
        switchToWeekView();
      }
    });
    // Ensure it's clickable
    weekDisplay.style.pointerEvents = 'auto';
  }

  // Date button - toggle dropdown
  const dateBtn = document.getElementById('dateBtn');
  if (dateBtn) {
    dateBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      const dropdown = document.getElementById('dateDropdown');
      if (dropdown) {
        const isActive = dropdown.classList.contains('active');
        // Close all other dropdowns first
        document.querySelectorAll('.date-dropdown-menu.active').forEach(menu => {
          menu.classList.remove('active');
          menu.style.display = 'none';
        });
        // Toggle this dropdown
        if (isActive) {
          dropdown.classList.remove('active');
          dropdown.style.display = 'none';
        } else {
          dropdown.classList.add('active');
          dropdown.style.display = 'block';
        }
      }
    });
  }
  
  // Close dropdown when clicking outside (with proper event handling)
  // Use a separate listener with higher priority to ensure it runs
  document.addEventListener('click', (e) => {
    const dropdown = document.getElementById('dateDropdown');
    if (!dropdown) return;
    
    const datePickerDropdown = e.target.closest('.date-picker-dropdown');
    const isDateButton = e.target.closest('#dateBtn');
    const isDateInput = e.target.closest('#dateDropdown input');
    const isDateButtonInside = e.target.closest('#dateDropdown button');
    
    // Close if clicking outside the date picker dropdown
    // But don't close if clicking on the button, inputs, or buttons inside the dropdown
    if (!datePickerDropdown && !isDateButton && !isDateInput && !isDateButtonInside) {
      if (dropdown.classList.contains('active')) {
        dropdown.classList.remove('active');
        dropdown.style.display = 'none';
      }
    }
  }, true); // Use capture phase to run before other handlers

  // Filter button
  const filterBtn = document.getElementById('filterBtn');
  if (filterBtn) {
    filterBtn.addEventListener('click', () => {
      const panel = document.getElementById('filterPanel');
      if (panel) {
        panel.classList.toggle('active');
        filterBtn.classList.toggle('active');
      }
    });
  }

  // Date filter buttons
  const applyDateFilterBtn = document.getElementById('applyDateFilterBtn');
  const clearDateFilterBtn = document.getElementById('clearDateFilterBtn');
  if (applyDateFilterBtn) {
    applyDateFilterBtn.addEventListener('click', applyDateFilter);
  }
  if (clearDateFilterBtn) {
    clearDateFilterBtn.addEventListener('click', clearDateFilter);
  }

  // Quick date filter buttons
  const todayBtn = document.getElementById('todayBtn');
  const yesterdayBtn = document.getElementById('yesterdayBtn');
  const thisMonthBtn = document.getElementById('thisMonthBtn');
  const lastMonthBtn = document.getElementById('lastMonthBtn');
  
  if (todayBtn) {
    todayBtn.addEventListener('click', () => applyQuickDateFilter('today'));
  }
  if (yesterdayBtn) {
    yesterdayBtn.addEventListener('click', () => applyQuickDateFilter('yesterday'));
  }
  if (thisMonthBtn) {
    thisMonthBtn.addEventListener('click', () => applyQuickDateFilter('thisMonth'));
  }
  if (lastMonthBtn) {
    lastMonthBtn.addEventListener('click', () => applyQuickDateFilter('lastMonth'));
  }

  // Apply filters button
  const applyFiltersBtn = document.getElementById('applyFiltersBtn');
  if (applyFiltersBtn) {
    applyFiltersBtn.addEventListener('click', applyFilters);
  }

  // View all button
  const viewAllBtn = document.getElementById('viewAllBtn');
  if (viewAllBtn) {
    viewAllBtn.addEventListener('click', () => {
      window.location.href = 'audit-reports.html';
    });
  }
}

function updateUserAvatar(userInfo) {
  const avatarEl = document.getElementById('userAvatar');
  if (!avatarEl) return;

  if (userInfo.avatar) {
    avatarEl.innerHTML = `<img src="${userInfo.avatar}" alt="${userInfo.name || 'User'}" class="w-full h-full rounded-full object-cover">`;
  } else if (userInfo.name) {
    const initials = userInfo.name.split(' ').map(n => n.charAt(0)).join('').toUpperCase().slice(0, 2);
    avatarEl.innerHTML = `<span class="text-xs font-semibold">${initials}</span>`;
  }
  
  // Populate the premium dashboard
  populatePremiumDashboard();
}

// Populate the elegant profile dashboard
async function populatePremiumDashboard() {
  const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
  
  // Populate basic info
  const dashboardUserName = document.getElementById('dashboardUserName');
  const dashboardUserEmail = document.getElementById('dashboardUserEmail');
  const dashboardUserRole = document.getElementById('dashboardUserRole');
  const dashboardAvatar = document.getElementById('dashboardAvatar');
  
  if (dashboardUserName) dashboardUserName.textContent = userInfo.name || 'Unknown User';
  if (dashboardUserEmail) dashboardUserEmail.textContent = userInfo.email || '';
  if (dashboardUserRole) dashboardUserRole.textContent = userInfo.role || 'User';
  
  // Update dashboard avatar
  if (dashboardAvatar) {
    if (userInfo.avatar) {
      dashboardAvatar.innerHTML = `<img src="${userInfo.avatar}" class="w-full h-full rounded-full object-cover">`;
    } else if (userInfo.name) {
      const initials = userInfo.name.split(' ').map(n => n.charAt(0)).join('').toUpperCase().slice(0, 2);
      dashboardAvatar.innerHTML = `<span class="text-sm font-bold">${initials}</span>`;
    }
  }
  
  // Fetch full user details from database (using people table)
  try {
    const { getAuthenticatedSupabase } = await import('/js/utils/authenticated-supabase.js');
    const supabase = await getAuthenticatedSupabase();
    const { data: userData, error } = await supabase
      .from('people')
      .select('email, name, role, channel, team, team_supervisor, quality_mentor, employee_id, intercom_admin_id, intercom_admin_alias')
      .eq('email', currentUserEmail)
      .maybeSingle();
    
    if (error) {
      console.error('Error fetching user data from people table:', error);
    }
    
    if (!error && userData) {
      const isEmployee = userData.role === 'Employee';
      const isAdmin = userData.role === 'Admin' || userData.role === 'Super Admin' || userData.role === 'Quality Analyst';
      
      // Show Intercom pill only if there's a valid value (not null or empty)
      const pillIntercomAlias = document.getElementById('pillIntercomAlias');
      if (pillIntercomAlias) {
        const displayIntercomAlias = document.getElementById('displayIntercomAlias');
        if (displayIntercomAlias) {
          // Show intercom_admin_alias if available, otherwise intercom_admin_id
          const intercomValue = userData.intercom_admin_alias || userData.intercom_admin_id || null;
          
          // Only show the pill if there's a valid (non-null, non-empty) value
          if (intercomValue !== null && intercomValue !== undefined && String(intercomValue).trim() !== '') {
            pillIntercomAlias.classList.remove('hidden');
            displayIntercomAlias.textContent = String(intercomValue);
          } else {
            // Keep it hidden if no valid value
            pillIntercomAlias.classList.add('hidden');
          }
        }
      }
      
      // Show employee pills if user has employee-related data (not just for "Employee" role)
      // This allows showing data for users with other roles who have employee fields populated
      const hasEmployeeData = userData.employee_id || userData.channel || userData.team || userData.team_supervisor;
      if (isEmployee || hasEmployeeData) {
        const pillEmployeeId = document.getElementById('pillEmployeeId');
        const pillTeam = document.getElementById('pillTeam');
        const pillSupervisor = document.getElementById('pillSupervisor');
        
        // Show ID pill if employee_id exists in query result (even if null/empty)
        if (pillEmployeeId) {
          pillEmployeeId.classList.remove('hidden');
          const displayEmployeeId = document.getElementById('displayEmployeeId');
          if (displayEmployeeId) {
            // Show the value even if it's null/empty (will show "-")
            displayEmployeeId.textContent = userData.employee_id || '-';
          }
        }
        
        // Show Team pill if team exists in query result (even if null/empty)
        if (pillTeam) {
          pillTeam.classList.remove('hidden');
          const displayTeam = document.getElementById('displayTeam');
          if (displayTeam) {
            displayTeam.textContent = userData.team || '-';
          }
        }
        
        // Show Supervisor pill if team_supervisor exists in query result (even if null/empty)
        if (pillSupervisor) {
          pillSupervisor.classList.remove('hidden');
          const displaySupervisor = document.getElementById('displaySupervisor');
          
          if (userData.team_supervisor) {
            // Fetch supervisor name from people table (not users table, as supervisor should be in people table)
            try {
              const { data: supervisorData, error: supervisorError } = await window.supabaseClient
                .from('people')
                .select('name')
                .eq('email', userData.team_supervisor)
                .maybeSingle();
              
              if (!supervisorError && supervisorData && supervisorData.name) {
                if (displaySupervisor) displaySupervisor.textContent = supervisorData.name;
              } else {
                // Fallback to email if name not found
                if (displaySupervisor) displaySupervisor.textContent = userData.team_supervisor || '-';
              }
            } catch (err) {
              console.warn('Could not fetch supervisor name:', err);
              if (displaySupervisor) displaySupervisor.textContent = userData.team_supervisor || '-';
            }
          } else {
            // Show "-" if no supervisor
            if (displaySupervisor) displaySupervisor.textContent = '-';
          }
        }
      }
      
      // Show/hide admin pills
      if (isAdmin) {
        if (pillAdminChannel) {
          pillAdminChannel.classList.remove('hidden');
          const displayAdminChannel = document.getElementById('displayAdminChannel');
          if (displayAdminChannel) displayAdminChannel.textContent = userData.channel || 'All Channels';
        }
      }
    } else if (!error && !userData) {
      console.warn('No user data found in people table for email:', currentUserEmail);
    }
  } catch (error) {
    console.error('Error loading profile dashboard:', error);
    console.error('Error details:', {
      message: error?.message,
      stack: error?.stack,
      currentUserEmail
    });
  }
}

// Removed toggleUserProfile() - Avatar now navigates directly to profile.html
// Removed populateUserProfile() - No longer needed

// Logout function - uses current system's auth utilities
async function logout() {
  try {
    // Use current system's signOut function
    try {
      const authModule = await import('/js/utils/auth.js');
      if (authModule?.signOut) {
        await authModule.signOut();
        // signOut() handles redirect, so we don't need to do it here
        return;
      }
    } catch (importError) {
      console.warn('Error importing auth module, using fallback:', importError);
    }
    
    // Fallback: Use Supabase client directly
    if (window.supabaseClient && window.supabaseClient.auth) {
      await window.supabaseClient.auth.signOut();
    }
    
    // Clear all auth data
    localStorage.removeItem('userInfo');
    localStorage.removeItem('sessionToken');
    localStorage.removeItem('lastLoginUpdate');
    localStorage.removeItem('supabase.auth.token');
    
    // Redirect to auth page
    window.location.href = '/src/auth/presentation/auth-page.html';
  } catch (error) {
    console.error('Error during logout:', error);
    // Force cleanup and redirect on error
    localStorage.removeItem('userInfo');
    localStorage.removeItem('sessionToken');
    localStorage.removeItem('lastLoginUpdate');
    localStorage.removeItem('supabase.auth.token');
    window.location.href = '/src/auth/presentation/auth-page.html';
  }
}

async function loadAllUsers() {
  try {
    const { getAuthenticatedSupabase } = await import('/js/utils/authenticated-supabase.js');
    const supabase = await getAuthenticatedSupabase();
    // Use people table instead of users table
    const { data, error } = await supabase
      .from('people')
      .select('email, name, role, channel, quality_mentor')
      .order('name', { ascending: true });
    
    if (error) throw error;
    // Map people table data (uses 'name' instead of 'full_name')
    allUsers = (data || []).map(person => ({
      email: person.email,
      name: person.name,
      role: person.role,
      channel: person.channel,
      quality_mentor: person.quality_mentor
    }));
  } catch (error) {
    console.error('Error loading users from people table:', error);
    allUsers = [];
  }
}

async function loadRecentUpdates() {
  // Use request deduplication to prevent multiple simultaneous calls
  // Define period at function scope to ensure it's accessible in catch blocks
  let period;
  try {
    period = getCurrentPeriodDates();
  } catch (error) {
    console.error('Error getting period dates:', error);
    period = getCurrentPeriodDates(); // Fallback attempt
  }
  
  const requestKey = `loadRecentUpdates_${currentUserEmail}_${JSON.stringify(period)}_${JSON.stringify(currentFilters)}`;
  
  return deduplicateRequest(requestKey, async () => {
    // Ensure period is available in this scope
    const currentPeriod = period || getCurrentPeriodDates();
    
    try {
      const updatesFeed = document.getElementById('updatesFeed');
      if (!updatesFeed) return;

      // Use persistent cache with stale-while-revalidate
      const { unifiedDataService } = await import('/js/features/home/infrastructure/unified-data-service.js');
      const { buildCacheKey } = await import('/js/features/home/infrastructure/cache-aware-loader.js');
      
      const cacheKey = buildCacheKey('recentUpdates', currentUserEmail, JSON.stringify(currentPeriod), JSON.stringify(currentFilters));
      
      // Use persistent cache (stale-while-revalidate pattern)
      const updatesData = await unifiedDataService.get(
        cacheKey,
        async () => {
          // Fetch function - show loader only if no cached data
          showLoader('updatesFeed');
          const data = await fetchAndCacheRecentUpdates(currentPeriod);
          return data;
        },
        3 * 60 * 1000, // 3 minutes TTL
        {
          usePersistentCache: true,
          staleWhileRevalidate: true
        }
      );
      
      // Render the updates (from cache or fresh)
      if (updatesData && typeof renderRecentUpdatesFromData === 'function') {
        renderRecentUpdatesFromData(updatesData);
      }
    } catch (error) {
      console.error('Error loading recent updates:', error);
      // Try fallback to sessionStorage
      try {
        // Use currentPeriod to ensure it's available
        const fallbackPeriod = period || getCurrentPeriodDates();
        const cacheKey = `recentUpdates_${currentUserEmail}_${JSON.stringify(fallbackPeriod)}_${JSON.stringify(currentFilters)}`;
        const cachedData = sessionStorage.getItem(cacheKey);
        const cachedTime = sessionStorage.getItem(cacheKey + '_time');
        const cacheAge = cachedTime ? Date.now() - parseInt(cachedTime) : Infinity;
        
        if (cachedData && cacheAge < 120000) {
          const allUpdates = JSON.parse(cachedData);
          renderRecentUpdatesFromData(allUpdates);
          return;
        }
      } catch (fallbackError) {
        console.error('Fallback cache also failed:', fallbackError);
      }
      
      const updatesFeed = document.getElementById('updatesFeed');
      if (updatesFeed) {
        updatesFeed.innerHTML = `
          <div class="px-4 py-8 text-center text-red-500 text-xs">
            <p class="font-medium mb-1">Error loading updates</p>
            <p class="text-gray-500">Please try again</p>
          </div>
        `;
      }
    }
  });
}

// Unified data loading function that combines updates and audits
async function loadUnifiedAuditData() {
  const period = getCurrentPeriodDates();
  const requestKey = `loadUnifiedAuditData_${currentUserEmail}_${JSON.stringify(period)}_${JSON.stringify(currentFilters)}_${sortBy}`;
  
  return deduplicateRequest(requestKey, async () => {
    try {
      showLoader('updatesFeed');
      
      // Load both updates and audits in parallel
      const [updatesData, auditsData] = await Promise.all([
        fetchAndCacheRecentUpdates(period),
        fetchAndCacheAssignedAudits(period)
      ]);
      
      // Organize data by type and role
      const unifiedData = {
        updates: updatesData || [],
        pendingAudits: [],
        completedAudits: auditsData || []
      };
      
      // Separate pending and completed audits based on role
      if (!isAgent) {
        // For auditors/admins: separate pending assignments from completed audits
        unifiedData.pendingAudits = (auditsData || []).filter(audit => 
          audit._isAssignment === true && (audit.status === 'pending' || audit.status === 'in_progress')
        );
        unifiedData.completedAudits = (auditsData || []).filter(audit => 
          audit._isAssignment !== true || audit.status === 'completed'
        );
      } else {
        // For employees: all audits are completed
        unifiedData.completedAudits = auditsData || [];
      }
      
      // For Admins/Super Admins: load all audits across system
      if (currentUserRole === 'Admin' || currentUserRole === 'Super Admin') {
        const { getAuthenticatedSupabase } = await import('/js/utils/authenticated-supabase.js');
        const supabase = await getAuthenticatedSupabase();
        
        // Load all pending audits system-wide
        const { data: allAssignments, error } = await supabase
          .from('audit_assignments')
          .select(`
            id, employee_email, employee_name, auditor_email, scorecard_id, status, scheduled_date, week, created_at, assigned_by, completed_at, audit_id, conversation_id, intercom_alias, source_type,
            scorecards:scorecard_id (
              id,
              name,
              table_name
            )
          `)
          .in('status', ['pending', 'in_progress'])
          .order('created_at', { ascending: false });
        
        if (!error && allAssignments) {
          // Apply filters
          let filtered = allAssignments;
          if (currentFilters.channel) {
            filtered = filtered.filter(a => a.channel === currentFilters.channel);
          }
          if (currentFilters.agent) {
            filtered = filtered.filter(a => a.employee_email === currentFilters.agent);
          }
          
          // Filter by date range
          filtered = filtered.filter(assignment => {
            const assignmentDate = assignment.scheduled_date 
              ? new Date(assignment.scheduled_date + 'T00:00:00')
              : assignment.created_at;
            if (!assignmentDate) return false;
            return isDateInRange(assignmentDate, period.start, period.end);
          });
          
          unifiedData.pendingAudits = filtered.map(assignment => ({
            ...assignment,
            _scorecard_id: assignment.scorecard_id,
            _scorecard_name: assignment.scorecards?.name || 'Unknown Scorecard',
            _scorecard_table: assignment.scorecards?.table_name || '',
            _isAssignment: true,
            id: assignment.id,
            employee_name: assignment.employee_name,
            employee_email: assignment.employee_email,
            auditor_email: assignment.auditor_email,
            status: assignment.status,
            created_at: assignment.created_at,
            scheduled_date: assignment.scheduled_date
          }));
        }
        
        // Also load all completed audits system-wide for admins
        const scorecards = await getCachedScorecards(supabase, 'id, name, table_name, scoring_type');
        if (scorecards && scorecards.length > 0) {
          const auditPromises = scorecards.map(async (scorecard) => {
            try {
              let query = supabase
                .from(scorecard.table_name)
                .select('id, employee_email, employee_name, auditor_email, auditor_name, interaction_id, created_at, submitted_at, passing_status, average_score, total_errors_count, audit_duration, channel, reversal_requested_at, reversal_approved, acknowledgement_status')
                .order('submitted_at', { ascending: false })
                .limit(200);
              
              // Apply filters
              if (currentFilters.channel) {
                query = query.eq('channel', currentFilters.channel);
              }
              if (currentFilters.agent) {
                query = query.ilike('employee_email', currentFilters.agent.toLowerCase().trim());
              }
              
              const { data, error } = await query;
              
              if (error) {
                console.warn(`Error loading from ${scorecard.table_name}:`, error);
                return [];
              }
              
              if (!data || data.length === 0) {
                return [];
              }
              
              // Filter by date range
              const filteredAudits = data.filter(audit => {
                const auditDate = audit.submitted_at || audit.created_at;
                if (!auditDate) return false;
                return isDateInRange(auditDate, period.start, period.end);
              });
              
              return filteredAudits.map(audit => ({
                ...audit,
                _scorecard_id: scorecard.id,
                _scorecard_name: scorecard.name,
                _scorecard_table: scorecard.table_name,
                _scoring_type: scorecard.scoring_type,
                _isAssignment: false
              }));
            } catch (err) {
              console.warn(`Exception loading from ${scorecard.table_name}:`, err);
              return [];
            }
          });
          
          const auditResults = await Promise.all(auditPromises);
          const allCompletedAudits = auditResults.flat();
          
          // Merge with existing completed audits
          unifiedData.completedAudits = [...unifiedData.completedAudits, ...allCompletedAudits];
          
          // Sort by submitted_at descending
          unifiedData.completedAudits.sort((a, b) => {
            const dateA = new Date(a.submitted_at || a.created_at || 0);
            const dateB = new Date(b.submitted_at || b.created_at || 0);
            return dateB - dateA;
          });
        }
      }
      
      // Render unified view
      renderUnifiedAuditView(unifiedData);
      
      return unifiedData;
    } catch (error) {
      console.error('Error loading unified audit data:', error);
      throw error;
    }
  });
}

async function fetchAndCacheRecentUpdates(period) {
  try {
    // Safety check: ensure period is defined and has required properties
    if (!period || !period.start || !period.end) {
      console.warn('fetchAndCacheRecentUpdates: period not properly defined, using current period');
      period = getCurrentPeriodDates();
    }
    
    let allUpdates = [];

    // Use unified query service for better performance
    let queryService;
    try {
      const serviceModule = await import('/js/features/home/infrastructure/scorecard-query-service.js');
      queryService = serviceModule.scorecardQueryService;
    } catch (err) {
      console.warn('Query service not available, using fallback:', err);
      queryService = null;
    }

    if (isAgent) {
      // For agents: Only show reversals (completed audits are handled by unified approach via fetchAndCacheAssignedAudits)
      
      // Load scorecards for reversal queries
      const { getAuthenticatedSupabase } = await import('/js/utils/authenticated-supabase.js');
      const supabase = await getAuthenticatedSupabase();
      
      let scorecards;
      if (queryService) {
        scorecards = await queryService.getScorecards(supabase);
      } else {
        const { data, error: scError } = await supabase
          .from('scorecards')
          .select('id, name, table_name')
          .eq('is_active', true);
        if (scError) {
          console.error('Error loading scorecards:', scError);
          return allUpdates;
        }
        scorecards = data || [];
      }
      
      // Load reversals (both requested and responded) - using query service
      if (scorecards && scorecards.length > 0) {
        const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
        
        if (queryService) {
          const results = await queryService.queryReversals(supabase, scorecards, {
            limit: 30,
            emailFilter: {
              field: 'employee_email',
              email: currentUserEmail
            },
            reversalFilterField: 'employee_email'
          });
          
          // Process query service results - need to preserve scorecard info and create update objects
          const processedUpdates = [];
          for (const result of results) {
            if (!result.data || result.data.length === 0) continue;
            
            const scorecard = result.scorecard;
            let reversals = result.data;
            
            // Sort reversals: prioritize those with recent responses
            reversals.sort((a, b) => {
              const aResponded = a.reversal_responded_at ? new Date(a.reversal_responded_at).getTime() : 0;
              const bResponded = b.reversal_responded_at ? new Date(b.reversal_responded_at).getTime() : 0;
              if (aResponded !== bResponded) {
                return bResponded - aResponded;
              }
              const aRequested = new Date(a.reversal_requested_at).getTime();
              const bRequested = new Date(b.reversal_requested_at).getTime();
              return bRequested - aRequested;
            });
            
            // Filter for agents: Show reversals that need acknowledgement
            let filteredReversals = reversals.filter(reversal => {
              const acknowledgementStatus = reversal.acknowledgement_status || reversal.acknowledgementStatus || '';
              const isAcknowledged = acknowledgementStatus && (
                acknowledgementStatus.toLowerCase().includes('acknowledged') || 
                acknowledgementStatus === 'Acknowledged'
              );
              const isPending = reversal.reversal_approved === null;
              const isApproved = reversal.reversal_approved === true || reversal.reversal_approved === 'true' || reversal.reversal_approved === 1 || reversal.reversal_approved === '1';
              const isRejected = reversal.reversal_approved === false || reversal.reversal_approved === 'false' || reversal.reversal_approved === 0 || reversal.reversal_approved === '0';
              return !isAcknowledged && (isPending || isApproved || isRejected);
            });
            
            // Create update objects for each reversal
            filteredReversals.forEach(reversal => {
              const interactionId = reversal.interaction_id || 'N/A';
              const acknowledgementStatus = reversal.acknowledgement_status || reversal.acknowledgementStatus;
              const isAcknowledged = acknowledgementStatus && (
                acknowledgementStatus.toLowerCase().includes('acknowledged') || 
                acknowledgementStatus === 'Acknowledged'
              );
              
              let status = null;
              if (acknowledgementStatus === 'Acknowledged') {
                status = 'Acknowledged';
              } else if (reversal.reversal_responded_at) {
                const approved = reversal.reversal_approved;
                if (approved === true || approved === 'true' || approved === 1 || approved === '1') {
                  status = 'Approved';
                } else if (approved === false || approved === 'false' || approved === 0 || approved === '0') {
                  status = 'Rejected';
                } else {
                  status = 'Pending';
                }
              } else if (reversal.reversal_requested_at && !reversal.reversal_responded_at) {
                status = 'Pending';
              }
              
              // Add reversal request update (for pending reversals)
              if (status === 'Pending' && reversal.reversal_requested_at) {
                processedUpdates.push({
                  id: `reversal-request-${reversal.id}`,
                  type: 'reversal_requested',
                  displayName: null,
                  displayEmail: null,
                  timestamp: reversal.reversal_requested_at,
                  status: 'reversal_requested',
                  interactionId: interactionId,
                  scorecardId: scorecard.id,
                  scorecardTable: scorecard.table_name,
                  auditId: reversal.id
                });
              }
              
              // Add status change update when reversal has been approved/rejected but NOT yet acknowledged
              if (status && (status === 'Approved' || status === 'Rejected') && !isAcknowledged) {
                const statusText = status === 'Approved' ? 'approved' : 'rejected';
                const statusTimestamp = reversal.reversal_responded_at || reversal.reversal_requested_at;
                
                processedUpdates.push({
                  id: `reversal-status-${reversal.id}`,
                  type: 'reversal_status_update',
                  displayName: null,
                  displayEmail: null,
                  timestamp: statusTimestamp,
                  status: status,
                  statusText: statusText,
                  interactionId: interactionId,
                  scorecardId: scorecard.id,
                  scorecardTable: scorecard.table_name,
                  auditId: reversal.id
                });
              }
            });
          }
          
          allUpdates.push(...processedUpdates);
        } else {
          // Fallback to original implementation
          const reversalPromises = scorecards.map(async (scorecard) => {
            try {
              const thirtyDaysAgo = new Date();
              thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
              const { data: reversals, error } = await supabase
                .from(scorecard.table_name)
                .select('id, employee_email, auditor_email, reversal_requested_at, reversal_responded_at, reversal_approved, acknowledgement_status, interaction_id, submitted_at')
                .eq('employee_email', currentUserEmail)
                .not('reversal_requested_at', 'is', null)
                .gte('reversal_requested_at', thirtyDaysAgo.toISOString())
                .order('reversal_requested_at', { ascending: false })
                .limit(30);
            
            if (!error && reversals && reversals.length > 0) {
              // Sort reversals: prioritize those with recent responses
              reversals.sort((a, b) => {
                const aResponded = a.reversal_responded_at ? new Date(a.reversal_responded_at).getTime() : 0;
                const bResponded = b.reversal_responded_at ? new Date(b.reversal_responded_at).getTime() : 0;
                if (aResponded !== bResponded) {
                  return bResponded - aResponded; // Most recent responses first
                }
                // If both have no response or same response time, sort by request time
                const aRequested = new Date(a.reversal_requested_at).getTime();
                const bRequested = new Date(b.reversal_requested_at).getTime();
                return bRequested - aRequested;
              });
              
              // No email filtering needed - already filtered server-side
              let filteredReversals = reversals;
              
              // For agents: Apply the same filtering logic as reversal.html
              // Show reversals that need acknowledgement (pending, approved but not acknowledged, rejected but not acknowledged)
              if (isAgent) {
                filteredReversals = filteredReversals.filter(reversal => {
                  const acknowledgementStatus = reversal.acknowledgement_status || reversal.acknowledgementStatus || '';
                  const isAcknowledged = acknowledgementStatus && (
                    acknowledgementStatus.toLowerCase().includes('acknowledged') || 
                    acknowledgementStatus === 'Acknowledged'
                  );
                  
                  // Show if:
                  // 1. Not approved yet (pending) AND not acknowledged
                  // 2. Approved but not acknowledged
                  // 3. Rejected but not acknowledged
                  const isPending = reversal.reversal_approved === null;
                  const isApproved = reversal.reversal_approved === true || reversal.reversal_approved === 'true' || reversal.reversal_approved === 1 || reversal.reversal_approved === '1';
                  const isRejected = reversal.reversal_approved === false || reversal.reversal_approved === 'false' || reversal.reversal_approved === 0 || reversal.reversal_approved === '0';
                  
                  return !isAcknowledged && (isPending || isApproved || isRejected);
                });
              }
              
              const updates = [];
              filteredReversals.forEach(reversal => {
                // Don't fetch auditor info for agents - they shouldn't see it
                const interactionId = reversal.interaction_id || 'N/A';
                
                // Determine reversal status - check if it's been responded to first, then check acknowledgement
                const acknowledgementStatus = reversal.acknowledgement_status || reversal.acknowledgementStatus;
                const isAcknowledged = acknowledgementStatus && (
                  acknowledgementStatus.toLowerCase().includes('acknowledged') || 
                  acknowledgementStatus === 'Acknowledged'
                );
                
                let status = null;
                
                // Determine status from reversal_approved and acknowledgement_status
                // Check acknowledgement first
                if (acknowledgementStatus === 'Acknowledged') {
                  status = 'Acknowledged';
                }
                // If reversal was responded to, check approval status
                else if (reversal.reversal_responded_at) {
                  const approved = reversal.reversal_approved;
                  if (approved === true || approved === 'true' || approved === 1 || approved === '1') {
                    status = 'Approved';
                  } else if (approved === false || approved === 'false' || approved === 0 || approved === '0') {
                    status = 'Rejected';
                  } else {
                    status = 'Pending';
                  }
                }
                // If reversal was requested but not responded to yet
                else if (reversal.reversal_requested_at && !reversal.reversal_responded_at) {
                  status = 'Pending';
                }
                
                // For agents: Show all reversals that appear in reversal.html
                // This includes: pending reversals, approved but not acknowledged, rejected but not acknowledged
                // Since we've already filtered to only show these, we should add updates for all of them
                
                // Add reversal request update (for pending reversals)
                if (status === 'Pending' && reversal.reversal_requested_at) {
                  updates.push({
                    id: `reversal-request-${reversal.id}`,
                    type: 'reversal_requested',
                    displayName: null, // Don't show auditor name for agents
                    displayEmail: null, // Don't show auditor email for agents
                    timestamp: reversal.reversal_requested_at,
                    status: 'reversal_requested',
                    interactionId: interactionId,
                    scorecardId: scorecard.id,
                    scorecardTable: scorecard.table_name,
                    auditId: reversal.id
                  });
                }
                
                // Add status change update when reversal has been approved/rejected but NOT yet acknowledged
                // For employees, we want to show when their reversal has been approved or rejected (so they can acknowledge it)
                if (status && (status === 'Approved' || status === 'Rejected') && !isAcknowledged) {
                  const statusText = status === 'Approved' ? 'approved' : 'rejected';
                  
                  // Use reversal_responded_at if available, otherwise use reversal_requested_at
                  const statusTimestamp = reversal.reversal_responded_at || reversal.reversal_requested_at;
                    
                    updates.push({
                      id: `reversal-status-${reversal.id}`,
                      type: 'reversal_status_update',
                      displayName: null, // Don't show auditor name for agents
                      displayEmail: null, // Don't show auditor email for agents
                    timestamp: statusTimestamp,
                      status: status,
                      statusText: statusText,
                      interactionId: interactionId,
                      scorecardId: scorecard.id,
                      scorecardTable: scorecard.table_name,
                      auditId: reversal.id
                    });
                }
              });
              return updates;
            }
            return [];
          } catch (err) {
            console.warn(`Error loading reversals from ${scorecard.table_name}:`, err);
            return [];
          }
        });
        
        const reversalResults = await Promise.all(reversalPromises);
        allUpdates.push(...reversalResults.flat());
      }
    }
      
    } else {
      // For auditors: Show all assignment status changes (pending, in_progress, completed) from audit tables
      const { data: scorecards, error: scError } = await window.supabaseClient
        .from('scorecards')
        .select('id, name, table_name')
        .eq('is_active', true);
      
      if (!scError && scorecards) {
        const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
        
        const assignmentPromises = scorecards.map(async (scorecard) => {
          try {
            // Query scorecard tables (all audits in scorecard tables are completed by default)
            // Use submitted_at for ordering since assignment_created_at doesn't exist in scorecard tables
            // Add date range filter at database level to reduce data transfer
            const periodStartISO = period.start.toISOString();
            const periodEndISO = new Date(period.end.getTime() + 24 * 60 * 60 * 1000).toISOString(); // Add 1 day to include end date
            let { data: audits, error } = await window.supabaseClient
              .from(scorecard.table_name)
              .select('*')
              .eq('auditor_email', currentUserEmail)
              .gte('submitted_at', periodStartISO)
              .lte('submitted_at', periodEndISO)
              .order('submitted_at', { ascending: false })
              .limit(20);
            
            if (error) {
              // If error, table might not have auditor_email column - skip this table silently
              // Don't log warning as this is expected for some tables
              return [];
            }
            
            if (!error && audits) {
              return audits.map(audit => ({
                ...audit,
                status: 'completed', // All audits in scorecard tables are completed by default
                created_at: audit.created_at,
                completed_at: audit.submitted_at
              }));
            }
            return [];
          } catch (err) {
            console.warn(`Error loading from ${scorecard.table_name}:`, err);
            return [];
          }
        });
        
        const assignmentResults = await Promise.all(assignmentPromises);
        const filteredAssignments = assignmentResults.flat().filter(assignment => {
          const auditorEmail = (assignment.auditor_email || '').toLowerCase().trim();
          return auditorEmail === normalizedCurrentEmail;
        });
        
        filteredAssignments.forEach(assignment => {
          const employeeEmail = (assignment.employee_email || '').toLowerCase().trim();
          const employeeUser = allUsers.find(u => (u.email || '').toLowerCase().trim() === employeeEmail);
          const employeeName = employeeUser?.name || assignment.employee_name || assignment.employee_email?.split('@')[0] || 'Unknown';
          
          allUpdates.push({
            id: `assignment-${assignment.id}`,
            type: 'assignment',
            displayName: employeeName,
            displayEmail: assignment.employee_email,
            timestamp: assignment.status === 'completed' && assignment.completed_at 
              ? assignment.completed_at 
              : (assignment.scheduled_date ? new Date(assignment.scheduled_date + 'T00:00:00').toISOString() : assignment.created_at),
            status: assignment.status,
            assignmentId: assignment.id
          });
        });
      }
      
      // Also load reversals for auditors - parallelized
      // For auditors: Show only unprocessed reversals (same as reversal.html)
      const { data: reversalScorecards, error: reversalScError } = await window.supabaseClient
        .from('scorecards')
        .select('id, name, table_name')
        .eq('is_active', true);
      
      if (!reversalScError && reversalScorecards) {
        const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
        const reversalFilterField = 'auditor_email';
        
        // Parallelize all reversal queries
        // First, try loading from new reversal_requests table
        // Include reversals where the employee is either:
        // 1. The requester (requested_by_email matches), OR
        // 2. The subject of the audit (employee_email matches)
        let newStructureReversals = [];
        try {
          const { data: reversalRequests, error: rrError } = await window.supabaseClient
            .from('reversal_requests')
            .select('*')
            .or(`requested_by_email.eq.${normalizedCurrentEmail},employee_email.eq.${normalizedCurrentEmail}`)
            .order('requested_at', { ascending: false })
            .limit(50);
          
          if (!rrError && reversalRequests && reversalRequests.length > 0) {
            // Get workflow states to filter for pending
            const reversalIds = reversalRequests.map(rr => rr.id);
            const { data: workflowStates } = await window.supabaseClient
              .from('reversal_workflow_states')
              .select('reversal_request_id, state')
              .in('reversal_request_id', reversalIds)
              .eq('is_current', true);
            
            const wsMap = new Map();
            if (workflowStates) {
              workflowStates.forEach(ws => wsMap.set(ws.reversal_request_id, ws.state));
            }
            
            // Filter for pending reversals only
            const pendingStates = ['submitted', 'team_lead_review', 'qa_review', 'cqc_review', 'cqc_sent_back', 'agent_re_review'];
            const pendingReversals = reversalRequests.filter(rr => {
              const state = wsMap.get(rr.id) || 'submitted';
              return pendingStates.includes(state);
            });
            
            // Get audit data for each pending reversal
            for (const rr of pendingReversals) {
              try {
                const { data: auditData } = await window.supabaseClient
                  .from(rr.scorecard_table_name)
                  .select('id, employee_email, auditor_email, interaction_id')
                  .eq('id', rr.audit_id)
                  .single();
                
                if (auditData) {
                  newStructureReversals.push({
                    id: auditData.id,
                    employee_email: auditData.employee_email,
                    auditor_email: auditData.auditor_email,
                    reversal_requested_at: rr.requested_at,
                    reversal_responded_at: rr.final_decision_at,
                    reversal_approved: rr.final_decision === 'approved' ? true : rr.final_decision === 'rejected' ? false : null,
                    interaction_id: auditData.interaction_id
                  });
                }
              } catch (err) {
                console.warn(`Error loading audit for reversal ${rr.id}:`, err);
              }
            }
          }
        } catch (err) {
          console.warn('Error loading from reversal_requests table:', err);
        }
        
        const reversalPromises = reversalScorecards.map(async (scorecard) => {
          try {
            // For auditors: Only get unprocessed reversals (reversal_approved is null) - same as reversal.html
            // Try query with reversal filters first
            let { data: reversals, error } = await window.supabaseClient
              .from(scorecard.table_name)
              .select('id, employee_email, auditor_email, reversal_requested_at, reversal_responded_at, reversal_approved, interaction_id')
              .not('reversal_requested_at', 'is', null)
              .is('reversal_approved', null) // Only unprocessed reversals
              .order('reversal_requested_at', { ascending: false })
              .limit(50);
            
            // If error, try without reversal_approved filter (some tables may not have this column)
            if (error) {
              const retryQuery = await window.supabaseClient
                .from(scorecard.table_name)
                .select('id, employee_email, auditor_email, reversal_requested_at, reversal_responded_at, reversal_approved, interaction_id')
                .not('reversal_requested_at', 'is', null)
                .order('reversal_requested_at', { ascending: false })
                .limit(50);
              
              if (!retryQuery.error && retryQuery.data) {
                reversals = retryQuery.data;
                error = null;
                // Filter client-side for unprocessed reversals (reversal_approved is null)
                if (reversals && reversals.some(r => r.reversal_approved !== undefined)) {
                  reversals = reversals.filter(r => r.reversal_approved === null);
                }
              } else {
                // If still error, table might not have reversal columns - skip this table silently
                return [];
              }
            }
            
            // Filter out reversals already loaded from new structure
            if (newStructureReversals.length > 0) {
              const newStructureIds = new Set(newStructureReversals.map(r => r.id));
              if (reversals) {
                reversals = reversals.filter(r => !newStructureIds.has(r.id));
              }
            }
            
            if (!error && reversals && reversals.length > 0) {
              // Filter by email
              const filteredReversals = reversals.filter(rev => {
                const emailToCheck = rev[reversalFilterField];
                if (!emailToCheck) return false;
                return emailToCheck.toLowerCase().trim() === normalizedCurrentEmail;
              });
              
              const updates = [];
              // For auditors: These are all unprocessed reversals (same as what appears in reversal.html)
              filteredReversals.forEach(reversal => {
                const employeeEmail = (reversal.employee_email || '').toLowerCase().trim();
                const employeeUser = allUsers.find(u => (u.email || '').toLowerCase().trim() === employeeEmail);
                const employeeName = employeeUser?.name || reversal.employee_email?.split('@')[0] || 'Unknown';
                const interactionId = reversal.interaction_id || 'N/A';
                
                // Add update for unprocessed reversal request (these appear in reversal.html)
                if (reversal.reversal_requested_at) {
                  updates.push({
                    id: `reversal-request-${reversal.id}`,
                    type: 'reversal_requested',
                    displayName: employeeName,
                    displayEmail: reversal.employee_email,
                    timestamp: reversal.reversal_requested_at,
                    status: 'reversal_requested',
                    interactionId: interactionId,
                    scorecardId: scorecard.id,
                    scorecardTable: scorecard.table_name,
                    auditId: reversal.id
                  });
                }
              });
              return updates;
            }
            return [];
          } catch (err) {
            console.warn(`Error loading reversals from ${scorecard.table_name}:`, err);
            return [];
          }
        });
        
        const reversalResults = await Promise.all(reversalPromises);
        allUpdates.push(...reversalResults.flat());
      }
    }

    // Apply date filter to updates (but always include recent reversal status updates for agents)
    // This code runs for both agents and auditors, outside the if/else but inside the try
    // Use the period parameter that was passed to the function (already validated at the start)
    const now = new Date();
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    
    allUpdates = allUpdates.filter(update => {
      if (!update.timestamp) return false;
      
      // For agents, always include reversal status updates from the last 7 days
      if (isAgent && update.type === 'reversal_status_update') {
        const updateDate = new Date(update.timestamp);
        if (updateDate >= sevenDaysAgo) {
          return true; // Always show recent reversal status updates
        }
      }
      
      return isDateInRange(update.timestamp, period.start, period.end);
    });
    
    // Sort all updates by timestamp (most recent first)
    allUpdates.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    
    // Limit to 15 most recent
    allUpdates = allUpdates.slice(0, 15);
    
    // Cache the results in persistent cache
    try {
      const { persistentCacheService } = await import('/js/features/home/infrastructure/persistent-cache-service.js');
      const { buildCacheKey } = await import('/js/features/home/infrastructure/cache-aware-loader.js');
      const cacheKey = buildCacheKey('recentUpdates', currentUserEmail, JSON.stringify(period), JSON.stringify(currentFilters));
      await persistentCacheService.set(cacheKey, allUpdates, 3 * 60 * 1000); // 3 minutes
    } catch (cacheError) {
      console.warn('Failed to cache in persistent storage, using sessionStorage:', cacheError);
      // Fallback to sessionStorage
      const cacheKey = `recentUpdates_${currentUserEmail}_${JSON.stringify(period)}_${JSON.stringify(currentFilters)}`;
      sessionStorage.setItem(cacheKey, JSON.stringify(allUpdates));
      sessionStorage.setItem(cacheKey + '_time', Date.now().toString());
    }
    
    // Don't render here - unified loader will handle rendering
    return allUpdates;
  } catch (error) {
    console.error('Error fetching recent updates:', error);
    throw error; // Re-throw so caller can handle
  }
}

// Unified renderer: single feed for everyone (same UI for agents and auditors)
function renderUnifiedAuditView(unifiedData) {
  const { updates, pendingAudits, completedAudits } = unifiedData;
  
  const allActivityItems = [];
  
  // For auditors: convert pending assignments to update format and add to feed (merged with completed + reversals)
  if (!isAgent && pendingAudits && Array.isArray(pendingAudits)) {
    const pendingUpdates = pendingAudits.map(assignment => convertPendingAssignmentToUpdate(assignment));
    allActivityItems.push(...pendingUpdates);
  }
  
  // Convert completed audits to update format and create a map for deduplication
  const completedAuditMap = new Map();
  if (completedAudits && Array.isArray(completedAudits)) {
    assignedAudits = completedAudits;
    const auditUpdates = completedAudits
      .filter(audit => audit._isAssignment !== true) // Only actual completed audits, not assignments
      .filter(audit => {
        // Filter out incomplete audits - must have submitted_at or at least interaction_id/employee_email
        // An audit without submitted_at and without interaction_id is likely incomplete/corrupted
        const hasSubmittedAt = audit.submitted_at != null;
        const hasInteractionId = audit.interaction_id != null && audit.interaction_id !== 'N/A';
        const hasEmployeeEmail = audit.employee_email != null && audit.employee_email.trim() !== '';
        
        // Include if it has submitted_at OR (has both interaction_id and employee_email)
        return hasSubmittedAt || (hasInteractionId && hasEmployeeEmail);
      })
      .map(audit => convertCompletedAuditToUpdate(audit));
    
    auditUpdates.forEach(auditUpdate => {
      if (auditUpdate.auditId) {
        completedAuditMap.set(auditUpdate.auditId, auditUpdate);
      }
    });
    allActivityItems.push(...auditUpdates);
  }
  
  // Add regular updates (reversals, etc.), filter out audit_completed that we already have as completed_audit
  if (updates && Array.isArray(updates)) {
    const filteredUpdates = updates.filter(update => {
      if (update.type === 'audit_completed' && update.auditId) {
        return !completedAuditMap.has(update.auditId);
      }
      return true;
    });
    allActivityItems.push(...filteredUpdates);
  }
  
  // Sort by timestamp (most recent first)
  allActivityItems.sort((a, b) => {
    const dateA = new Date(a.timestamp || a.submitted_at || a.created_at || 0);
    const dateB = new Date(b.timestamp || b.submitted_at || b.created_at || 0);
    return dateB - dateA;
  });
  
  renderRecentUpdatesFromData(allActivityItems);
}

// Convert completed audit to update format for unified display
function convertCompletedAuditToUpdate(audit) {
  // For agents, don't show auditor info; for auditors, show employee info (who was audited) and auditor info (who performed the audit)
  let displayUser, displayName, displayEmail, auditorDisplayName;
  if (isAgent) {
    displayName = null;
    displayEmail = null;
    auditorDisplayName = null;
  } else {
    const employeeEmail = (audit.employee_email || '').toLowerCase().trim();
    displayUser = allUsers.find(u => (u.email || '').toLowerCase().trim() === employeeEmail);
    displayName = audit.employee_name || displayUser?.name || audit.employee_email?.split('@')[0] || 'Unknown';
    displayEmail = audit.employee_email || '';
    const auditorUser = allUsers.find(u => (u.email || '').toLowerCase().trim() === (audit.auditor_email || '').toLowerCase().trim());
    auditorDisplayName = audit.auditor_name || auditorUser?.name || audit.auditor_email?.split('@')[0] || 'Unknown';
  }
  
  const interactionId = audit.interaction_id || 'N/A';
  const channel = audit.channel || 'No Channel';
  const averageScore = audit.average_score || audit.averageScore || '0';
  const totalErrors = audit.total_errors_count || audit.totalErrorsCount || '0';
  const passingStatus = audit.passing_status || audit.passingStatus || 'Unknown';
  const normalizedStatus = passingStatus === 'Passing' ? 'Passed' : (passingStatus === 'Not Passing' ? 'Not Passed' : passingStatus);
  
  return {
    id: `audit-${audit.id}`,
    type: 'completed_audit',
    auditId: audit.id,
    scorecardId: audit._scorecard_id || '',
    scorecardTable: audit._scorecard_table || '',
    scorecardName: audit._scorecard_name || 'Unknown Scorecard',
    displayName: displayName,
    displayEmail: displayEmail,
    auditorDisplayName: auditorDisplayName,
    timestamp: audit.submitted_at || audit.created_at,
    interactionId: interactionId,
    channel: channel,
    averageScore: averageScore,
    totalErrors: totalErrors,
    passingStatus: normalizedStatus,
    reversalStatus: audit.reversal_status,
    acknowledgmentStatus: audit.acknowledgement_status || audit.acknowledgment_status,
    // Store full audit object for rendering
    _audit: audit
  };
}

// Convert pending assignment to update format for unified feed (auditors only)
function convertPendingAssignmentToUpdate(assignment) {
  const employeeEmail = (assignment.employee_email || '').toLowerCase().trim();
  const displayUser = allUsers.find(u => (u.email || '').toLowerCase().trim() === employeeEmail);
  const displayName = assignment.employee_name || displayUser?.name || assignment.employee_email?.split('@')[0] || 'Unknown';
  const timestamp = assignment.created_at || (assignment.scheduled_date ? new Date(assignment.scheduled_date + 'T00:00:00').toISOString() : null);
  return {
    id: `assignment-${assignment.id}`,
    type: 'assignment',
    displayName,
    displayEmail: assignment.employee_email || '',
    timestamp: timestamp || new Date().toISOString(),
    status: assignment.status || 'pending',
    assignmentId: assignment.id
  };
}

// Render pending audits for auditors/admins (legacy: section hidden; pending items now in unified feed)
function renderPendingAudits(pendingAudits) {
  const list = document.getElementById('pendingAuditsList');
  if (!list) return;
  
  if (pendingAudits.length === 0) {
    list.innerHTML = `
      <div class="px-4 py-6 text-center text-gray-500 text-xs">
        <p>No pending audits</p>
      </div>
    `;
    return;
  }
  
  // Sort pending audits
  const sorted = [...pendingAudits];
  sortAudits(sorted);
  
  list.innerHTML = sorted.map(audit => {
    const employeeEmail = (audit.employee_email || '').toLowerCase().trim();
    const displayUser = allUsers.find(u => (u.email || '').toLowerCase().trim() === employeeEmail);
    const displayName = audit.employee_name || displayUser?.name || audit.employee_email?.split('@')[0] || 'Unknown';
    const displayEmail = audit.employee_email || '';
    const scorecardName = audit._scorecard_name || 'Unknown Scorecard';
    const initials = getInitials(displayName);
    
    let statusBadge = '';
    if (audit.status === 'in_progress') {
      statusBadge = '<span class="inline-flex items-center px-2 py-0.5 rounded text-[10px] font-semibold bg-yellow-100 text-yellow-800">In Progress</span>';
    } else {
      statusBadge = '<span class="inline-flex items-center px-2 py-0.5 rounded text-[10px] font-semibold bg-gray-100 text-gray-800">Pending</span>';
    }
    
    const requestDate = formatTimestamp(audit.created_at);
    
    return `
      <div class="px-4 py-2.5 hover:bg-gray-50 transition-colors cursor-pointer border-b border-gray-100 last:border-0" data-action="create-audit">
        <div class="flex items-center justify-between gap-3">
          <div class="flex items-center gap-2.5 flex-1 min-w-0">
            <div class="w-8 h-8 rounded bg-primary text-white flex items-center justify-center text-xs font-semibold flex-shrink-0">
              ${initials}
            </div>
            <div class="flex-1 min-w-0">
              <div class="flex items-center gap-1.5 mb-0.5">
                <h4 class="text-xs font-semibold text-gray-900 truncate">
                  ${escapeHtml(displayName)}
                </h4>
              </div>
              <p class="text-[10px] text-gray-600 flex items-center gap-1 flex-wrap">
                <span class="truncate">${escapeHtml(displayEmail)}</span>
                <span class="text-gray-300"></span>
                <span class="font-medium text-gray-700">${escapeHtml(scorecardName)}</span>
                <span class="text-gray-300"></span>
                <span>${requestDate}</span>
              </p>
            </div>
          </div>
          <div class="flex items-center gap-2 flex-shrink-0">
            ${statusBadge}
            <button data-action="create-audit" class="px-2.5 py-1 bg-primary text-white text-[10px] font-semibold rounded hover:bg-primary-dark transition-colors flex-shrink-0">Get Started</button>
          </div>
        </div>
      </div>
    `;
  }).join('');
}

// Render completed audits (refactored from renderAssignedAudits)
function renderCompletedAudits(completedAudits) {
  const list = document.getElementById('assignedAuditsList');
  if (!list) return;
  
  if (completedAudits.length === 0) {
    const emptyMessage = isAgent 
      ? 'Your completed audits will appear here'
      : 'No completed audits';
    list.innerHTML = `
      <div class="px-4 py-8 text-center text-gray-500 text-xs">
        <svg class="w-12 h-12 mx-auto mb-2 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
        </svg>
        <p class="font-medium text-gray-700 mb-1">No audits found</p>
        <p class="text-gray-500">${emptyMessage}</p>
      </div>
    `;
    return;
  }
  
  // Sort audits
  const sorted = [...completedAudits];
  sortAudits(sorted);
  
  // Pagination: only show first N items
  const toDisplay = sorted.slice(0, assignedAuditsDisplayed);
  const hasMore = sorted.length > assignedAuditsDisplayed;
  
  list.innerHTML = toDisplay.map(audit => {
    // Check if this is an assignment (pending audit) or a completed audit
    const isAssignment = audit._isAssignment === true;
    
    if (isAssignment) {
      // This shouldn't appear in completed audits, but handle it just in case
      return '';
    } else {
      // Render completed audit
      if (isAgent) {
        const auditEmployeeEmail = (audit.employee_email || '').toLowerCase().trim();
        if (auditEmployeeEmail !== currentUserEmail) {
          console.error('CRITICAL: Audit does not belong to current user!', {
            auditId: audit.id,
            auditEmployeeEmail,
            currentUserEmail,
            audit
          });
        }
      }
      
      // For agents, don't show auditor info; for auditors, show employee info
      let displayUser, displayName, displayEmail;
      if (isAgent) {
        displayName = null;
        displayEmail = null;
      } else {
        const employeeEmail = (audit.employee_email || '').toLowerCase().trim();
        displayUser = allUsers.find(u => (u.email || '').toLowerCase().trim() === employeeEmail);
        displayName = audit.employee_name || displayUser?.name || audit.employee_email?.split('@')[0] || 'Unknown';
        displayEmail = audit.employee_email || '';
      }
      
      const scorecardName = audit._scorecard_name || 'Unknown Scorecard';
      const initials = isAgent ? null : getInitials(displayName);
      
      // Get passing status
      const passingStatus = audit.passing_status || audit.passingStatus || 'Unknown';
      const normalizedStatus = passingStatus === 'Passing' ? 'Passed' : (passingStatus === 'Not Passing' ? 'Not Passed' : passingStatus);
      const statusColor = normalizedStatus === 'Passed' ? 'bg-primary/10 text-primary' : 'bg-red-100 text-red-800';
      const statusIcon = normalizedStatus === 'Passed' ? '' : '';
      
      const submittedDate = formatTimestamp(audit.submitted_at);
      const averageScore = audit.average_score || audit.averageScore || '0';
      const totalErrors = audit.total_errors_count || audit.totalErrorsCount || '0';
      const interactionId = audit.interaction_id || 'N/A';
      const channel = audit.channel || 'No Channel';
      
      const reversalStatusChip = getReversalStatusChip(audit);
      const acknowledgmentStatusChip = getAcknowledgmentStatusChip(audit);

      return `
        <div class="px-4 py-2.5 hover:bg-gray-50 transition-colors cursor-pointer border-b border-gray-100 last:border-0" data-action="view-details" data-audit-id="${audit.id}" data-scorecard-id="${audit._scorecard_id || ''}" data-scorecard-table="${audit._scorecard_table || ''}">
          <div class="flex items-center justify-between gap-3">
            <div class="flex items-center gap-2.5 flex-1 min-w-0">
              ${isAgent ? `
                <div class="w-8 h-8 rounded bg-success/10 flex items-center justify-center flex-shrink-0">
                  <svg class="w-4 h-4 text-success" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                  </svg>
                </div>
              ` : `
                <div class="w-8 h-8 rounded bg-primary text-white flex items-center justify-center text-xs font-semibold flex-shrink-0">
                  ${initials}
                </div>
              `}
              <div class="flex-1 min-w-0">
                ${isAgent ? `
                  <div class="flex items-center gap-1.5 mb-0.5 flex-wrap">
                    <h4 class="text-xs font-semibold text-gray-900 truncate">
                      ${escapeHtml(interactionId)}
                    </h4>
                    ${audit._scorecard_name ? `
                      <span class="inline-flex items-center px-2 py-0.5 rounded text-[10px] font-semibold bg-gray-100 text-gray-700">
                        ${escapeHtml(audit._scorecard_name)}
                      </span>
                    ` : ''}
                    <span class="inline-flex items-center px-2 py-0.5 rounded text-[9px] font-semibold ${statusColor}">
                      ${statusIcon} ${normalizedStatus}
                    </span>
                  </div>
                  <p class="text-[10px] text-gray-600 flex items-center gap-1 flex-wrap">
                    <span>${escapeHtml(channel)}</span>
                    <span class="text-gray-300"></span>
                    <span class="font-medium text-gray-700">${averageScore}%</span>
                    <span class="text-gray-300"></span>
                    <span>${totalErrors} errors</span>
                    <span class="text-gray-300"></span>
                    <span>${submittedDate}</span>
                  </p>
                ` : `
                  <div class="flex items-center gap-1.5 mb-0.5 flex-wrap">
                    <h4 class="text-xs font-semibold text-gray-900 truncate">
                      ${escapeHtml(displayName)}
                    </h4>
                    ${audit._scorecard_name ? `
                      <span class="inline-flex items-center px-2 py-0.5 rounded text-[10px] font-semibold bg-gray-100 text-gray-700">
                        ${escapeHtml(audit._scorecard_name)}
                      </span>
                    ` : ''}
                  </div>
                  <p class="text-[10px] text-gray-600 flex items-center gap-1 flex-wrap">
                    <span>${escapeHtml(interactionId)}</span>
                    <span class="text-gray-300"></span>
                    <span>${escapeHtml(channel)}</span>
                    <span class="text-gray-300"></span>
                    <span class="flex flex-col items-start">
                      <span class="font-medium text-gray-700">${averageScore}%</span>
                      <span class="inline-flex items-center px-2 py-0.5 rounded text-[9px] font-semibold ${statusColor} mt-0.5">
                        ${statusIcon} ${normalizedStatus}
                      </span>
                    </span>
                    <span class="text-gray-300"></span>
                    <span>${totalErrors} errors</span>
                    <span class="text-gray-300"></span>
                    <span>${submittedDate}</span>
                  </p>
                `}
              </div>
            </div>
            <div class="flex items-center gap-2 flex-shrink-0">
              ${acknowledgmentStatusChip}
              ${reversalStatusChip}
              <button data-action="view-details" data-audit-id="${audit.id}" data-scorecard-id="${audit._scorecard_id || ''}" data-scorecard-table="${audit._scorecard_table || ''}" class="px-2.5 py-1 bg-primary text-white text-[10px] font-semibold rounded hover:bg-primary-dark transition-colors">
                View Details
              </button>
            </div>
          </div>
        </div>
      `;
    }
  }).filter(html => html !== '').join('') + (hasMore ? `
    <div class="px-4 py-3 border-t border-gray-200">
      <button onclick="loadMoreAssignedAudits()" class="w-full px-4 py-2 text-xs font-medium text-primary hover:bg-primary/10 rounded transition-colors">
        Load More (${sorted.length - assignedAuditsDisplayed} remaining)
      </button>
    </div>
  ` : '');
}

function renderRecentUpdatesFromData(allUpdates) {
  const updatesFeed = document.getElementById('updatesFeed');
  if (!updatesFeed) return;
  
  // Count reversal status updates for agents
  if (isAgent) {
    const reversalStatusUpdates = allUpdates.filter(u => u.type === 'reversal_status_update');
    const reversalCountEl = document.getElementById('reversalUpdatesCount');
    if (reversalCountEl) {
      if (reversalStatusUpdates.length > 0) {
        reversalCountEl.textContent = reversalStatusUpdates.length;
        reversalCountEl.style.display = 'inline-flex';
      } else {
        reversalCountEl.style.display = 'none';
      }
    }
  }

  if (allUpdates.length === 0) {
    updatesFeed.innerHTML = `
      <div class="px-4 py-6 text-center text-gray-500 text-xs">
        <p>No recent activity</p>
      </div>
    `;
    return;
  }

  updatesFeed.innerHTML = allUpdates.map(update => {
      // Handle completed_audit type with rich display
      if (update.type === 'completed_audit') {
        return renderCompletedAuditItem(update);
      }
      
      // Skip audit_completed updates - they should have been filtered out or converted to completed_audit
      // If they slip through, skip them to avoid showing the old simple view
      if (update.type === 'audit_completed') {
        return '';
      }
      
      // Handle regular update types (reversals, assignments, etc.)
      const timestamp = formatTimestamp(update.timestamp);
      const initials = getInitials(update.displayName);
      
      let statusText = '';
      if (update.type === 'reversal_requested') {
        statusText = isAgent 
          ? `Reversal requested for conversation ${update.interactionId || ''}`
          : `Requested reversal for conversation ${update.interactionId || ''}`;
      } else if (update.type === 'reversal_status_update') {
        const statusDisplay = update.status === 'Approved' ? 'approved' : update.status === 'Rejected' ? 'rejected' : update.status === 'Acknowledged' ? 'acknowledged' : 'updated';
        statusText = isAgent
          ? `Reversal request ${statusDisplay}`
          : `Reversal ${statusDisplay} for conversation ${update.interactionId || ''}`;
      } else if (update.type === 'reversal_responded') {
        statusText = isAgent ? 'Reversal response received' : 'Reversal response sent';
      } else {
        statusText = getStatusText(update.status, isAgent);
      }
      
      // Use data attributes instead of onclick for CSP compliance
      let onClickAction = false;
      let dataAttributes = '';
      if (update.type === 'reversal_requested' || update.type === 'reversal_responded' || update.type === 'reversal_status_update') {
        onClickAction = true;
        dataAttributes = `data-action="view-details" data-audit-id="${update.auditId}" data-scorecard-id="${update.scorecardId || ''}" data-scorecard-table="${update.scorecardTable || ''}"`;
      } else if (update.assignmentId) {
        onClickAction = true;
        dataAttributes = `data-action="view-assignment" data-audit-id="${update.assignmentId}"`;
      }

      // Determine styling for different update types
      let bgColor = 'bg-primary/10';
      let textColor = 'text-primary';
      if (update.type === 'reversal_status_update') {
        if (update.status === 'Approved') {
          bgColor = 'bg-success/10';
          textColor = 'text-success';
        } else if (update.status === 'Rejected') {
          bgColor = 'bg-error/10';
          textColor = 'text-error';
        } else if (update.status === 'Acknowledged') {
          bgColor = 'bg-primary/10';
          textColor = 'text-primary';
        } else {
          bgColor = 'bg-warning/10';
          textColor = 'text-warning';
        }
      } else if (update.type === 'reversal_requested') {
        bgColor = 'bg-warning/10';
        textColor = 'text-warning';
      }

      // For employees viewing any updates, use generic icon instead of auditor initials/names
      const useGenericIcon = isAgent && (update.type === 'reversal_requested' || update.type === 'reversal_status_update');
      const iconContent = useGenericIcon 
        ? `<svg class="w-4 h-4 ${textColor}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
          </svg>`
        : `<span class="text-xs font-semibold ${textColor}">${initials}</span>`;

      // Assignment items (auditors): show Get Started button; others no button
      const viewButton = update.assignmentId
        ? `<button data-action="view-assignment" data-audit-id="${update.assignmentId}" class="px-2.5 py-1 bg-primary text-white text-[10px] font-semibold rounded hover:bg-primary-dark transition-colors flex-shrink-0">Get Started</button>`
        : '';

      return `
        <div class="px-4 py-2.5 hover:bg-gray-50 transition-colors ${onClickAction ? 'cursor-pointer' : ''}" ${dataAttributes}>
          <div class="flex items-start gap-2.5">
            <div class="w-7 h-7 rounded-full ${bgColor} flex items-center justify-center flex-shrink-0">
              ${iconContent}
            </div>
            <div class="flex-1 min-w-0">
              <p class="text-xs text-gray-900 leading-snug">
                ${update.displayName && !isAgent
                  ? `<span class="font-medium">${escapeHtml(update.displayName)}</span>  ${statusText}`
                  : statusText
                }
              </p>
              <p class="text-[10px] text-gray-500 mt-0.5">${timestamp}</p>
            </div>
            ${viewButton}
          </div>
        </div>
      `;
    }).filter(html => html !== '').join('');
}

// Render completed audit item with rich information
function renderCompletedAuditItem(update) {
  const audit = update._audit || update;
  const timestamp = formatTimestamp(update.timestamp);
  
  // For agents, don't show auditor info; for auditors, show employee info
  let displayUser, displayName, displayEmail;
  if (isAgent) {
    displayName = null;
    displayEmail = null;
  } else {
    displayName = update.displayName;
    displayEmail = update.displayEmail;
  }
  
  const scorecardName = update.scorecardName || 'Unknown Scorecard';
  const initials = isAgent ? null : getInitials(displayName);
  
  // Get passing status
  const passingStatus = update.passingStatus || 'Unknown';
  const statusColor = passingStatus === 'Passed' ? 'bg-primary/10 text-primary' : 'bg-red-100 text-red-800';
  const statusIcon = passingStatus === 'Passed' ? '' : '';
  
  const interactionId = update.interactionId || 'N/A';
  const channel = update.channel || 'No Channel';
  const averageScore = update.averageScore || '0';
  const totalErrors = update.totalErrors || '0';
  // "audited by" = person who performed the audit (auditor), not the agent who was audited
  const auditedByLabel = isAgent ? null : (escapeHtml(update.auditorDisplayName || displayName) || 'Unknown');
  const titleText = isAgent ? `#${escapeHtml(interactionId)} audited` : `#${escapeHtml(interactionId)} audited by ${auditedByLabel}`;

  // Use the full audit object for status chips (they expect the audit format)
  const fullAudit = update._audit || audit;
  const reversalStatusChip = (update.reversalStatus || fullAudit.reversal_status) ? getReversalStatusChip(fullAudit) : '';
  // Always show acknowledgment status chip (function handles empty status by showing "Pending")
  const acknowledgmentStatusChip = getAcknowledgmentStatusChip(fullAudit);

  const dataAttributes = `data-action="view-details" data-audit-id="${update.auditId}" data-scorecard-id="${update.scorecardId || ''}" data-scorecard-table="${update.scorecardTable || ''}"`;

  return `
    <div class="px-4 py-2.5 hover:bg-gray-50 transition-colors cursor-pointer border-b border-gray-100 last:border-0" ${dataAttributes}>
      <div class="flex items-center justify-between gap-3">
        <div class="flex items-center gap-2.5 flex-1 min-w-0">
          ${isAgent ? `
            <div class="w-8 h-8 rounded bg-success/10 flex items-center justify-center flex-shrink-0">
              <svg class="w-4 h-4 text-success" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
              </svg>
            </div>
          ` : `
            <div class="w-8 h-8 rounded bg-primary text-white flex items-center justify-center text-xs font-semibold flex-shrink-0">
              ${initials}
            </div>
          `}
          <div class="flex-1 min-w-0">
            ${isAgent ? `
              <div class="flex items-center gap-1.5 mb-0.5 flex-wrap">
                <h4 class="text-xs font-semibold text-gray-900">
                  ${titleText}
                </h4>
                <span class="inline-flex items-center px-2 py-0.5 rounded text-[9px] font-semibold ${statusColor}">
                  ${statusIcon} ${passingStatus}
                </span>
              </div>
              <p class="text-[10px] text-gray-600 flex items-center gap-1 flex-wrap">
                <span>${escapeHtml(channel)}</span>
                <span class="text-gray-300"></span>
                <span class="font-medium text-gray-700">${averageScore}%</span>
                <span class="text-gray-300"></span>
                <span>${totalErrors} errors</span>
                <span class="text-gray-300"></span>
                <span>${timestamp}</span>
              </p>
            ` : `
              <div class="flex items-center gap-1.5 mb-0.5 flex-wrap">
                <h4 class="text-xs font-semibold text-gray-900">
                  ${titleText}
                </h4>
                <span class="inline-flex items-center px-2 py-0.5 rounded text-[9px] font-semibold ${statusColor}">
                  ${statusIcon} ${passingStatus}
                </span>
              </div>
              <p class="text-[10px] text-gray-600 flex items-center gap-1 flex-wrap">
                <span>${escapeHtml(channel)}</span>
                <span class="text-gray-300"></span>
                <span class="font-medium text-gray-700">${averageScore}%</span>
                <span class="text-gray-300"></span>
                <span>${totalErrors} errors</span>
                <span class="text-gray-300"></span>
                <span>${timestamp}</span>
              </p>
            `}
          </div>
        </div>
        <div class="flex items-center gap-2 flex-shrink-0">
          ${acknowledgmentStatusChip}
          ${reversalStatusChip}
          <button data-action="view-details" data-audit-id="${update.auditId}" data-scorecard-id="${update.scorecardId || ''}" data-scorecard-table="${update.scorecardTable || ''}" class="px-2.5 py-1 bg-primary text-white text-[10px] font-semibold rounded hover:bg-primary-dark transition-colors">
            View Details
          </button>
        </div>
      </div>
    </div>
  `;
}

async function loadAssignedAudits() {
  // Redirect to unified loader since everything is now in one view
  return loadUnifiedAuditData();
}

async function fetchAndCacheAssignedAudits(period) {
  try {
    if (isAgent) {
      // For employees: Load completed audits from scorecard tables
      await loadCompletedAuditsForEmployee();
    } else {
      // For auditors: Load pending/in-progress assignments from audit_assignments
      await loadPendingAssignmentsForAuditor();
    }

    // Cache the results in persistent cache
    try {
      const { persistentCacheService } = await import('/js/features/home/infrastructure/persistent-cache-service.js');
      const { buildCacheKey } = await import('/js/features/home/infrastructure/cache-aware-loader.js');
      const cacheKey = buildCacheKey('assignedAudits', currentUserEmail, JSON.stringify(period), JSON.stringify(currentFilters), sortBy);
      await persistentCacheService.set(cacheKey, assignedAudits, 5 * 60 * 1000); // 5 minutes
    } catch (cacheError) {
      console.warn('Failed to cache in persistent storage, using sessionStorage:', cacheError);
      // Fallback to sessionStorage
      const cacheKey = `assignedAudits_${currentUserEmail}_${JSON.stringify(period)}_${JSON.stringify(currentFilters)}_${sortBy}`;
      sessionStorage.setItem(cacheKey, JSON.stringify(assignedAudits));
      sessionStorage.setItem(cacheKey + '_time', Date.now().toString());
    }
    
    // Don't render here - unified loader will handle rendering
    return assignedAudits;
  } catch (error) {
    console.error('Error fetching assigned audits:', error);
    document.getElementById('assignedAuditsList').innerHTML = `
      <div class="px-4 py-8 text-center text-red-500 text-xs">
        <p>Error loading audits</p>
      </div>
    `;
    throw error; // Re-throw so caller can handle
  }
}

async function loadCompletedAuditsForEmployee() {
  // Load all scorecards to query audit tables (using cache)
  const { getAuthenticatedSupabase } = await import('/js/utils/authenticated-supabase.js');
  const supabase = await getAuthenticatedSupabase();
  const scorecards = await getCachedScorecards(supabase, 'id, name, table_name, scoring_type');
  
  if (!scorecards) throw new Error('Failed to load scorecards');
  
  let combinedAudits = [];
  const auditFilterField = 'employee_email';
  
  // Load audits from all scorecard tables in parallel (performance optimization)
  const period = getCurrentPeriodDates();
  const auditPromises = (scorecards || []).map(async (scorecard) => {
    try {
      // For agents: Filter by employee_email server-side
      // Use field whitelist - select only needed fields
      // Use .ilike() for case-insensitive email matching to handle any case variations in the database
      // Note: Removed 'status' from select as it doesn't exist in all scorecard tables
      const normalizedEmail = currentUserEmail.toLowerCase().trim();
      const { data, error } = await supabase
        .from(scorecard.table_name)
        .select('id, employee_email, employee_name, auditor_email, auditor_name, interaction_id, created_at, submitted_at, passing_status, average_score, total_errors_count, audit_duration, reversal_requested_at, reversal_approved, acknowledgement_status')
        .ilike('employee_email', normalizedEmail)
        .order('submitted_at', { ascending: false })
        .limit(100); // Reduced from 500 to 100 for better performance
      
      if (error) {
        console.warn(`Error loading from ${scorecard.table_name}:`, error);
        return [];
      }
      
      if (!data || data.length === 0) {
        return [];
      }
      
      // Additional client-side normalization filter as safety measure (case-insensitive)
      const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
      const filteredByEmail = (data || []).filter(audit => {
        const auditEmail = (audit.employee_email || '').toLowerCase().trim();
        return auditEmail === normalizedCurrentEmail;
      });
      
      // Apply date filter (week or date range)
      // Use submitted_at as primary date, fallback to created_at if submitted_at is missing
      let filteredAudits = filteredByEmail.filter(audit => {
        // Use submitted_at if available, otherwise fallback to created_at
        const auditDate = audit.submitted_at || audit.created_at;
        if (!auditDate) {
          console.warn(`Audit ${audit.id} has no submitted_at or created_at date, skipping`);
          return false;
        }
        return isDateInRange(auditDate, period.start, period.end);
      });
      
      // Apply channel filter
      if (currentFilters.channel) {
        filteredAudits = filteredAudits.filter(audit => audit.channel === currentFilters.channel);
      }
      
      // Add scorecard info to each audit
      return filteredAudits.map(audit => ({
        ...audit,
        _scorecard_id: scorecard.id,
        _scorecard_name: scorecard.name,
        _scorecard_table: scorecard.table_name,
        _scoring_type: scorecard.scoring_type,
        _isAssignment: false
      }));
    } catch (err) {
      console.warn(`Exception loading from ${scorecard.table_name}:`, err);
      return [];
    }
  });
  
  // Wait for all queries to complete in parallel
  const auditResults = await Promise.all(auditPromises);
  combinedAudits = auditResults.flat();
    
    // Sort by submitted_at descending (fallback to created_at if submitted_at is missing)
    combinedAudits.sort((a, b) => {
      const dateA = new Date(a.submitted_at || a.created_at || 0);
      const dateB = new Date(b.submitted_at || b.created_at || 0);
      return dateB - dateA;
    });
    
    // No need for verification - already filtered server-side
    
    // Limit total results
    combinedAudits = combinedAudits.slice(0, 50);
    
    assignedAudits = combinedAudits;
    allAssignments = combinedAudits;
}

async function loadPendingAssignmentsForAuditor() {
  // Load pending and in-progress assignments from audit_assignments table
  const { getAuthenticatedSupabase } = await import('/js/utils/authenticated-supabase.js');
  const supabase = await getAuthenticatedSupabase();
  const { data, error } = await supabase
    .from('audit_assignments')
    .select(`
      id, employee_email, employee_name, auditor_email, scorecard_id, status, scheduled_date, week, created_at, assigned_by, completed_at, audit_id, conversation_id, intercom_alias, source_type,
      scorecards:scorecard_id (
        id,
        name,
        table_name
      )
    `)
    .eq('auditor_email', currentUserEmail)
    .in('status', ['pending', 'in_progress'])
    .order('created_at', { ascending: false });
  
  if (error) {
    console.error('Error loading assignments:', error);
    throw error;
  }
  
  // Normalize and filter client-side for exact match
  const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
  let filteredAssignments = (data || []).filter(assignment => {
    const auditorEmail = (assignment.auditor_email || '').toLowerCase().trim();
    return auditorEmail === normalizedCurrentEmail;
  });
  
  // Apply date filter (week or date range) - use scheduled_date if available, otherwise created_at
  const period = getCurrentPeriodDates();
  filteredAssignments = filteredAssignments.filter(assignment => {
    // Use scheduled_date if available, otherwise fall back to created_at date
    const assignmentDate = assignment.scheduled_date 
      ? new Date(assignment.scheduled_date + 'T00:00:00') // Convert DATE to Date object
      : assignment.created_at;
    if (!assignmentDate) return false;
    return isDateInRange(assignmentDate, period.start, period.end);
  });
  
  // Apply channel filter
  if (currentFilters.channel) {
    filteredAssignments = filteredAssignments.filter(assignment => assignment.channel === currentFilters.channel);
  }
  
  // Apply status filter
  if (currentFilters.status) {
    filteredAssignments = filteredAssignments.filter(assignment => assignment.status === currentFilters.status);
  }
  
  // Apply agent filter
  if (currentFilters.agent) {
    filteredAssignments = filteredAssignments.filter(assignment => assignment.employee_email === currentFilters.agent);
  }
  
  // Map assignments to a format similar to audits for rendering
  assignedAudits = filteredAssignments.map(assignment => ({
    ...assignment,
    _scorecard_id: assignment.scorecard_id,
    _scorecard_name: assignment.scorecards?.name || 'Unknown Scorecard',
    _scorecard_table: assignment.scorecards?.table_name || '',
    _isAssignment: true,
    // Map assignment fields to audit-like fields for rendering
    id: assignment.id,
    employee_name: assignment.employee_name,
    employee_email: assignment.employee_email,
    auditor_email: assignment.auditor_email,
    status: assignment.status,
    created_at: assignment.created_at,
    scheduled_date: assignment.scheduled_date
  }));
  
  allAssignments = assignedAudits;
}

// Pagination state for assigned audits
let assignedAuditsPageSize = 20;
let assignedAuditsDisplayed = assignedAuditsPageSize;

function renderAssignedAudits() {
  const list = document.getElementById('assignedAuditsList');
  const countEl = document.getElementById('pendingCount');

  if (!list) return;

  // Update count
  if (countEl) countEl.textContent = assignedAudits.length;

  if (assignedAudits.length === 0) {
    const emptyMessage = isAgent 
      ? 'Your completed audits will appear here'
      : 'No pending audits assigned';
    list.innerHTML = `
      <div class="px-4 py-8 text-center text-gray-500 text-xs">
        <svg class="w-12 h-12 mx-auto mb-2 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
        </svg>
        <p class="font-medium text-gray-700 mb-1">No audits found</p>
        <p class="text-gray-500">${emptyMessage}</p>
      </div>
    `;
    return;
  }

  // Sort audits
  const sorted = [...assignedAudits];
  sortAudits(sorted);

  // Pagination: only show first N items
  const toDisplay = sorted.slice(0, assignedAuditsDisplayed);
  const hasMore = sorted.length > assignedAuditsDisplayed;

  list.innerHTML = toDisplay.map(audit => {
    // Check if this is an assignment (pending audit) or a completed audit
    const isAssignment = audit._isAssignment === true;
    
    if (isAssignment) {
      // Render assignment (pending audit) for auditors
      const employeeEmail = (audit.employee_email || '').toLowerCase().trim();
      const displayUser = allUsers.find(u => (u.email || '').toLowerCase().trim() === employeeEmail);
      const displayName = audit.employee_name || displayUser?.name || audit.employee_email?.split('@')[0] || 'Unknown';
      const displayEmail = audit.employee_email || '';
      const scorecardName = audit._scorecard_name || 'Unknown Scorecard';
      const initials = getInitials(displayName);
      
      let statusBadge = '';
      if (audit.status === 'in_progress') {
        statusBadge = '<span class="inline-flex items-center px-2 py-0.5 rounded text-[10px] font-semibold bg-yellow-100 text-yellow-800">In Progress</span>';
      } else {
        statusBadge = '<span class="inline-flex items-center px-2 py-0.5 rounded text-[10px] font-semibold bg-gray-100 text-gray-800">Pending</span>';
      }
      
      const requestDate = formatTimestamp(audit.created_at);

      return `
        <div class="px-4 py-2.5 hover:bg-gray-50 transition-colors cursor-pointer border-b border-gray-100 last:border-0" data-action="create-audit">
          <div class="flex items-center justify-between gap-3">
            <div class="flex items-center gap-2.5 flex-1 min-w-0">
              <div class="w-8 h-8 rounded bg-primary text-white flex items-center justify-center text-xs font-semibold flex-shrink-0">
                ${initials}
              </div>
              <div class="flex-1 min-w-0">
                <div class="flex items-center gap-1.5 mb-0.5">
                  <h4 class="text-xs font-semibold text-gray-900 truncate">
                    ${escapeHtml(displayName)}
                  </h4>
                </div>
                <p class="text-[10px] text-gray-600 flex items-center gap-1 flex-wrap">
                  <span class="truncate">${escapeHtml(displayEmail)}</span>
                  <span class="text-gray-300"></span>
                  <span class="font-medium text-gray-700">${escapeHtml(scorecardName)}</span>
                  <span class="text-gray-300"></span>
                  <span>${requestDate}</span>
                </p>
              </div>
            </div>
            <div class="flex items-center gap-2 flex-shrink-0">
              ${statusBadge}
              <button data-action="create-audit" class="px-2.5 py-1 bg-primary text-white text-[10px] font-semibold rounded hover:bg-primary-dark transition-colors">
                Get Started
              </button>
            </div>
          </div>
        </div>
      `;
    } else {
      // Render completed audit for employees
      // Verify the audit belongs to the current user (for debugging)
      if (isAgent) {
        const auditEmployeeEmail = (audit.employee_email || '').toLowerCase().trim();
        if (auditEmployeeEmail !== currentUserEmail) {
          console.error('CRITICAL: Audit does not belong to current user!', {
            auditId: audit.id,
            auditEmployeeEmail,
            currentUserEmail,
            audit
          });
        }
      }
      
      // For agents, don't show auditor info; for auditors, show employee info
      let displayUser, displayName, displayEmail;
      if (isAgent) {
        // For employees, don't show auditor info - use generic icon instead
        displayName = null; // Don't show auditor name
        displayEmail = null; // Don't show auditor email
      } else {
        // For auditors, show who they audited (the employee)
        const employeeEmail = (audit.employee_email || '').toLowerCase().trim();
        displayUser = allUsers.find(u => (u.email || '').toLowerCase().trim() === employeeEmail);
        displayName = audit.employee_name || displayUser?.name || audit.employee_email?.split('@')[0] || 'Unknown';
        displayEmail = audit.employee_email || '';
      }
      
      const scorecardName = audit._scorecard_name || 'Unknown Scorecard';
      // For agents, use generic icon instead of initials; for auditors, use employee initials
      const initials = isAgent ? null : getInitials(displayName);
      
      // Get passing status
      const passingStatus = audit.passing_status || audit.passingStatus || 'Unknown';
      const normalizedStatus = passingStatus === 'Passing' ? 'Passed' : (passingStatus === 'Not Passing' ? 'Not Passed' : passingStatus);
      const statusColor = normalizedStatus === 'Passed' ? 'bg-primary/10 text-primary' : 'bg-red-100 text-red-800';
      const statusIcon = normalizedStatus === 'Passed' ? '' : '';
      
      const submittedDate = formatTimestamp(audit.submitted_at);
      const averageScore = audit.average_score || audit.averageScore || '0';
      const totalErrors = audit.total_errors_count || audit.totalErrorsCount || '0';
      const interactionId = audit.interaction_id || 'N/A';
      const channel = audit.channel || 'No Channel';
      
      const reversalStatusChip = getReversalStatusChip(audit);
      const acknowledgmentStatusChip = getAcknowledgmentStatusChip(audit);

      return `
        <div class="px-4 py-2.5 hover:bg-gray-50 transition-colors cursor-pointer border-b border-gray-100 last:border-0" data-action="view-details" data-audit-id="${audit.id}" data-scorecard-id="${audit._scorecard_id || ''}" data-scorecard-table="${audit._scorecard_table || ''}">
          <div class="flex items-center justify-between gap-3">
            <div class="flex items-center gap-2.5 flex-1 min-w-0">
              ${isAgent ? `
                <!-- For agents: Use generic icon instead of auditor avatar -->
                <div class="w-8 h-8 rounded bg-success/10 flex items-center justify-center flex-shrink-0">
                  <svg class="w-4 h-4 text-success" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                  </svg>
                </div>
              ` : `
                <!-- For auditors: Show employee avatar -->
                <div class="w-8 h-8 rounded bg-primary text-white flex items-center justify-center text-xs font-semibold flex-shrink-0">
                  ${initials}
                </div>
              `}
              <div class="flex-1 min-w-0">
                ${isAgent ? `
                  <!-- For employees: 2 rows, info compact -->
                  <!-- Row 1: Interaction ID + Scorecard + Passing Status -->
                  <div class="flex items-center gap-1.5 mb-0.5 flex-wrap">
                    <h4 class="text-xs font-semibold text-gray-900 truncate">
                      ${escapeHtml(interactionId)}
                    </h4>
                    ${audit._scorecard_name ? `
                      <span class="inline-flex items-center px-2 py-0.5 rounded text-[10px] font-semibold bg-gray-100 text-gray-700">
                        ${escapeHtml(audit._scorecard_name)}
                      </span>
                    ` : ''}
                    <span class="inline-flex items-center px-2 py-0.5 rounded text-[9px] font-semibold ${statusColor}">
                      ${statusIcon} ${normalizedStatus}
                    </span>
                  </div>
                  <!-- Row 2: Channel  Score  Errors  Date -->
                  <p class="text-[10px] text-gray-600 flex items-center gap-1 flex-wrap">
                    <span>${escapeHtml(channel)}</span>
                    <span class="text-gray-300"></span>
                    <span class="font-medium text-gray-700">${averageScore}%</span>
                    <span class="text-gray-300"></span>
                    <span>${totalErrors} errors</span>
                    <span class="text-gray-300"></span>
                    <span>${submittedDate}</span>
                  </p>
                ` : `
                  <!-- For auditors: 2 rows, info compact -->
                  <!-- Row 1: Employee name + Scorecard -->
                  <div class="flex items-center gap-1.5 mb-0.5 flex-wrap">
                    <h4 class="text-xs font-semibold text-gray-900 truncate">
                      ${escapeHtml(displayName)}
                    </h4>
                    ${audit._scorecard_name ? `
                      <span class="inline-flex items-center px-2 py-0.5 rounded text-[10px] font-semibold bg-gray-100 text-gray-700">
                        ${escapeHtml(audit._scorecard_name)}
                      </span>
                    ` : ''}
                  </div>
                  <!-- Row 2: Interaction ID  Channel  Score  Errors  Date -->
                  <p class="text-[10px] text-gray-600 flex items-center gap-1 flex-wrap">
                    <span>${escapeHtml(interactionId)}</span>
                    <span class="text-gray-300"></span>
                    <span>${escapeHtml(channel)}</span>
                    <span class="text-gray-300"></span>
                    <span class="flex flex-col items-start">
                      <span class="font-medium text-gray-700">${averageScore}%</span>
                      <span class="inline-flex items-center px-2 py-0.5 rounded text-[9px] font-semibold ${statusColor} mt-0.5">
                        ${statusIcon} ${normalizedStatus}
                      </span>
                    </span>
                    <span class="text-gray-300"></span>
                    <span>${totalErrors} errors</span>
                    <span class="text-gray-300"></span>
                    <span>${submittedDate}</span>
                  </p>
                `}
              </div>
            </div>
            <div class="flex items-center gap-2 flex-shrink-0">
              ${acknowledgmentStatusChip}
              ${reversalStatusChip}
              <button data-action="view-details" data-audit-id="${audit.id}" data-scorecard-id="${audit._scorecard_id || ''}" data-scorecard-table="${audit._scorecard_table || ''}" class="px-2.5 py-1 bg-primary text-white text-[10px] font-semibold rounded hover:bg-primary-dark transition-colors">
                View Details
              </button>
            </div>
          </div>
        </div>
      `;
    }
  }).join('') + (hasMore ? `
    <div class="px-4 py-3 border-t border-gray-200">
      <button onclick="loadMoreAssignedAudits()" class="w-full px-4 py-2 text-xs font-medium text-primary hover:bg-primary/10 rounded transition-colors">
        Load More (${sorted.length - assignedAuditsDisplayed} remaining)
      </button>
    </div>
  ` : '');
}

function loadMoreAssignedAudits() {
  assignedAuditsDisplayed += assignedAuditsPageSize;
  renderAssignedAudits();
}

function sortAudits(audits) {
  audits.sort((a, b) => {
    const isAssignmentA = a._isAssignment === true;
    const isAssignmentB = b._isAssignment === true;
    
    switch (sortBy) {
      case 'name_asc':
        // For agents, sort by auditor; for auditors, sort by employee
        const nameA = (isAgent ? (a.auditor_name || a.auditor_email || '') : (a.employee_name || a.employee_email || '')).toLowerCase();
        const nameB = (isAgent ? (b.auditor_name || b.auditor_email || '') : (b.employee_name || b.employee_email || '')).toLowerCase();
        return nameA.localeCompare(nameB);
      case 'name_desc':
        const nameA2 = (isAgent ? (a.auditor_name || a.auditor_email || '') : (a.employee_name || a.employee_email || '')).toLowerCase();
        const nameB2 = (isAgent ? (b.auditor_name || b.auditor_email || '') : (b.employee_name || b.employee_email || '')).toLowerCase();
        return nameB2.localeCompare(nameA2);
      case 'status_asc':
        // For assignments, sort by assignment status; for audits, sort by passing status
        if (isAssignmentA && isAssignmentB) {
          const statusOrder = { 'pending': 0, 'in_progress': 1 };
          return (statusOrder[a.status] || 0) - (statusOrder[b.status] || 0);
        }
        const statusA = (a.passing_status || a.passingStatus || '').toLowerCase();
        const statusB = (b.passing_status || b.passingStatus || '').toLowerCase();
        return statusA.localeCompare(statusB);
      case 'status_desc':
        if (isAssignmentA && isAssignmentB) {
          const statusOrder = { 'pending': 0, 'in_progress': 1 };
          return (statusOrder[b.status] || 0) - (statusOrder[a.status] || 0);
        }
        const statusA2 = (a.passing_status || a.passingStatus || '').toLowerCase();
        const statusB2 = (b.passing_status || b.passingStatus || '').toLowerCase();
        return statusB2.localeCompare(statusA2);
      case 'date_asc':
        const dateA = new Date(a.submitted_at || a.created_at || 0);
        const dateB = new Date(b.submitted_at || b.created_at || 0);
        return dateA - dateB;
      case 'date_desc':
      default:
        const dateA2 = new Date(a.submitted_at || a.created_at || 0);
        const dateB2 = new Date(b.submitted_at || b.created_at || 0);
        return dateB2 - dateA2;
    }
  });
}

function sortUnifiedAudits() {
  const sortSelect = document.getElementById('auditSortBy');
  if (sortSelect) {
    sortBy = sortSelect.value;
    // Clear cache when sort changes
    clearCache(`assignedAudits_${currentUserEmail}_`);
    clearCache(`recentUpdates_${currentUserEmail}_`);
    // Reload unified data with new sort
    loadUnifiedAuditData();
  }
}

// Keep old function name for backward compatibility
function sortAssignedAudits() {
  sortUnifiedAudits();
}

function toggleSortMenu() {
  const menu = document.getElementById('sortMenu');
  if (menu) {
    menu.classList.toggle('hidden');
  }
}

// Removed event listener for closing user profile dropdown - no longer needed

// Request deduplication: prevent multiple simultaneous calls to the same function
const activeRequests = new Map();

function deduplicateRequest(key, requestFn) {
  // If there's already an active request for this key, return the existing promise
  if (activeRequests.has(key)) {
    return activeRequests.get(key);
  }
  
  // Create new request and store it
  const promise = requestFn()
    .finally(() => {
      // Remove from active requests when done
      activeRequests.delete(key);
    });
  
  activeRequests.set(key, promise);
  return promise;
}

// Update your stats (assignment progress)
async function updateYourStats() {
  // Use request deduplication to prevent multiple simultaneous calls
  if (!currentUserEmail) {
    return;
  }
  
  const period = getCurrentPeriodDates();
  const requestKey = `updateYourStats_${currentUserEmail}_${JSON.stringify(period)}_${JSON.stringify(currentFilters)}`;
  
  return deduplicateRequest(requestKey, async () => {
    try {
      // Use persistent cache with stale-while-revalidate
      const { unifiedDataService } = await import('/js/features/home/infrastructure/unified-data-service.js');
      const { buildCacheKey } = await import('/js/features/home/infrastructure/cache-aware-loader.js');
      
      const cacheKey = buildCacheKey('stats', currentUserEmail, JSON.stringify(period), JSON.stringify(currentFilters));
      
      // Use persistent cache (stale-while-revalidate pattern)
      const statsData = await unifiedDataService.get(
        cacheKey,
        async () => {
          // Fetch function - show loader only if no cached data
          showStatsLoader();
          const data = await fetchAndCacheStats(period);
          return data;
        },
        5 * 60 * 1000, // 5 minutes TTL
        {
          usePersistentCache: true,
          staleWhileRevalidate: true
        }
      );
      
      // Render the stats (from cache or fresh)
      if (statsData && typeof renderStatsFromData === 'function') {
        renderStatsFromData(statsData);
      }
    } catch (error) {
      console.error('Error loading stats:', error);
      // Try fallback to sessionStorage
      try {
        const cacheKey = `stats_${currentUserEmail}_${JSON.stringify(period)}_${JSON.stringify(currentFilters)}`;
        const cachedData = sessionStorage.getItem(cacheKey);
        const cachedTime = sessionStorage.getItem(cacheKey + '_time');
        const cacheAge = cachedTime ? Date.now() - parseInt(cachedTime) : Infinity;
        
        if (cachedData && cacheAge < 60000) {
          const statsData = JSON.parse(cachedData);
          renderStatsFromData(statsData);
          return;
        }
      } catch (fallbackError) {
        console.error('Fallback cache also failed:', fallbackError);
      }
      // Show error state in stats
      showStatsLoader();
      const errorMsg = document.createElement('div');
      errorMsg.className = 'text-xs text-red-500 text-center mt-2';
      errorMsg.textContent = 'Error loading stats';
    }
  });
}

async function fetchAndCacheStats(period) {
  try {
    if (!currentUserEmail) {
      return;
    }
    
    // OPTIMIZATION: Fetch scorecards and assignments in parallel at the start
    const { getAuthenticatedSupabase } = await import('/js/utils/authenticated-supabase.js');
    const supabase = await getAuthenticatedSupabase();
    const filterField = isAgent ? 'employee_email' : 'auditor_email';
    const auditFilterField = isAgent ? 'employee_email' : 'auditor_email';
    const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
    const currentPeriod = getCurrentPeriodDates();
    
    // Parallel fetch: scorecards + assignments
    const [scorecardsResult, assignmentsResult] = await Promise.all([
      supabase.from('scorecards').select('id, name, table_name, scoring_type').eq('is_active', true),
      supabase.from('audit_assignments').select('*').eq(filterField, currentUserEmail).order('created_at', { ascending: false })
    ]);
    
    const scorecards = scorecardsResult.data || [];
    const assignments = assignmentsResult.data || [];
    
    if (assignmentsResult.error) {
      console.error('Error loading assignments for stats:', assignmentsResult.error);
    }
    
    // Apply date filter to assignments
    let allAssignments = assignments.filter(assignment => {
      const assignmentDate = assignment.scheduled_date 
        ? new Date(assignment.scheduled_date + 'T00:00:00')
        : assignment.created_at;
      if (!assignmentDate) return false;
      return isDateInRange(assignmentDate, currentPeriod.start, currentPeriod.end);
    });
    
    const totalAssigned = allAssignments.length;
    const inProgress = allAssignments.filter(a => a.status === 'in_progress').length;
    const pending = allAssignments.filter(a => a.status === 'pending').length;
    
    // Initialize stats variables
    let completed = 0;
    let avgDuration = 0;
    let avgDurationText = '-';
    let totalAuditsConducted = 0;
    let totalScoreSum = 0;
    let totalAuditsWithScore = 0;
    let avgQualityScore = 0;
    let avgQualityScoreText = '-';
    let passingCount = 0;
    let notPassingCount = 0;
    let requiresAcknowledgment = 0;
    
    // OPTIMIZATION: Run ALL scorecard queries in parallel instead of sequential loops
    if (scorecards.length > 0) {
      // Create unified queries for each scorecard that fetch all needed data at once
      const unifiedQueryPromises = scorecards.map(async (scorecard) => {
        try {
          // Single query per scorecard with all fields needed for stats
          const selectFields = isAgent 
            ? 'id, submitted_at, audit_duration, average_score, passing_status, acknowledgement_status'
            : 'id, submitted_at, audit_duration, average_score, passing_status, auditor_email';
          
          let query = supabase
            .from(scorecard.table_name)
            .select(selectFields)
            .eq(auditFilterField, currentUserEmail)
            .not('submitted_at', 'is', null);
          
          // Apply date filters server-side
          if (currentPeriod.start && window.dhakaDateToUTCISO) {
            query = query.gte('submitted_at', window.dhakaDateToUTCISO(currentPeriod.start));
          } else if (currentPeriod.start) {
            query = query.gte('submitted_at', currentPeriod.start.toISOString());
          }
          if (currentPeriod.end && window.dhakaDateToUTCISO) {
            query = query.lte('submitted_at', window.dhakaDateToUTCISO(currentPeriod.end));
          } else if (currentPeriod.end) {
            query = query.lte('submitted_at', currentPeriod.end.toISOString());
          }
          
          const { data, error } = await query.limit(500);
          
          if (error) {
            // Fallback: try without date filter and apply client-side
            const retryResult = await supabase
              .from(scorecard.table_name)
              .select(selectFields)
              .eq(auditFilterField, currentUserEmail)
              .not('submitted_at', 'is', null)
              .limit(500);
            
            if (retryResult.error) {
              console.warn(`Error querying ${scorecard.table_name}:`, retryResult.error);
              return { scorecard, audits: [] };
            }
            
            // Filter client-side by date
            const filteredAudits = (retryResult.data || []).filter(audit => {
              if (!audit.submitted_at) return false;
              const auditDate = toDhakaTime(audit.submitted_at);
              return (!currentPeriod.start || auditDate >= currentPeriod.start) && 
                     (!currentPeriod.end || auditDate <= currentPeriod.end);
            });
            return { scorecard, audits: filteredAudits };
          }
          
          return { scorecard, audits: data || [] };
        } catch (err) {
          console.warn(`Error in unified query for ${scorecard.table_name}:`, err);
          return { scorecard, audits: [] };
        }
      });
      
      // Execute all queries in parallel
      const queryResults = await Promise.all(unifiedQueryPromises);
      
      // Process results from unified queries
      let allDurations = [];
      
      queryResults.forEach(({ scorecard, audits }) => {
        // Count completed audits
        completed += audits.length;
        totalAuditsConducted += audits.length;
        
        // Process each audit for stats
        audits.forEach(audit => {
          // Duration calculation
          if (audit.audit_duration != null) {
            let durationInMinutes = 0;
            if (typeof audit.audit_duration === 'number') {
              durationInMinutes = audit.audit_duration / 60;
            } else if (typeof audit.audit_duration === 'string') {
              const asInt = parseInt(audit.audit_duration);
              if (!isNaN(asInt)) {
                durationInMinutes = asInt / 60;
              } else {
                const timeParts = audit.audit_duration.split(':');
                if (timeParts.length === 2) {
                  durationInMinutes = (parseInt(timeParts[0]) || 0) + ((parseInt(timeParts[1]) || 0) / 60);
                } else if (timeParts.length === 3) {
                  durationInMinutes = ((parseInt(timeParts[0]) || 0) * 60) + (parseInt(timeParts[1]) || 0) + ((parseInt(timeParts[2]) || 0) / 60);
                }
              }
            }
            if (durationInMinutes > 0) {
              allDurations.push(durationInMinutes);
            }
          }
          
          // Score calculation
          const score = parseFloat(audit.average_score || 0);
          if (!isNaN(score) && score > 0) {
            totalScoreSum += score;
            totalAuditsWithScore++;
          }
          
          // Passing status
          const passingStatus = audit.passing_status || '';
          const normalizedStatus = normalizePassingStatus(passingStatus);
          if (normalizedStatus === 'Passed') {
            passingCount++;
          } else {
            notPassingCount++;
          }
          
          // Acknowledgment count (for agents only)
          if (isAgent) {
            const ackStatus = audit.acknowledgement_status || '';
            if (ackStatus.toLowerCase() === 'pending') {
              requiresAcknowledgment++;
            }
          }
        });
      });
      
      // Calculate average duration
      if (allDurations.length > 0) {
        const totalDuration = allDurations.reduce((sum, d) => sum + d, 0);
        avgDuration = totalDuration / allDurations.length;
        if (avgDuration >= 60) {
          const hours = Math.floor(avgDuration / 60);
          const minutes = Math.round(avgDuration % 60);
          avgDurationText = minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
        } else {
          avgDurationText = `${Math.round(avgDuration)}m`;
        }
      }
      
      // Calculate average quality score
      if (totalAuditsWithScore > 0) {
        avgQualityScore = totalScoreSum / totalAuditsWithScore;
        avgQualityScoreText = `${Math.round(avgQualityScore)}%`;
      }
    } else {
      // Fallback to assignment-based count if no scorecards
      completed = allAssignments.filter(a => a.status === 'completed').length;
    }
    
    const remaining = pending + inProgress;
    const percentage = totalAssigned > 0 ? Math.round((completed / totalAssigned) * 100) : 0;
    
    // Calculate working days remaining
    const today = new Date();
    const endOfWeek = new Date(today);
    endOfWeek.setDate(today.getDate() + (5 - today.getDay()));
    const daysRemaining = Math.max(0, Math.ceil((endOfWeek - today) / (1000 * 60 * 60 * 24)));
    
    // Calculate reversal counts (active and resolved)
    let activeReversals = 0;
    let resolvedReversals = 0;
    let totalReversals = 0;
    
    // For agents who need acknowledgment count beyond what we already calculated
    if (isAgent && scorecards.length > 0) {
      // Acknowledgment already calculated above in the unified query
    }
    
    // Skip the old sequential acknowledgment query since it's now handled above
    // This block is kept for compatibility but the work is already done
    if (false) { // Disabled - acknowledgment now calculated in unified query
      try {
        const { data: oldScorecards, error: scError } = await window.supabaseClient
          .from('scorecards')
          .select('table_name')
          .eq('is_active', true);
        
        if (!scError && oldScorecards) {
          const normalizedOldEmail = currentUserEmail.toLowerCase().trim();
          
          // Parallelize all audit count queries
          const auditPromises = oldScorecards.map(async (scorecard) => {
            try {
              // For agents: Filter by employee_email server-side
              const { data: allAudits, error: auditError } = await window.supabaseClient
                .from(scorecard.table_name)
                .select('id, employee_email, acknowledgement_status, submitted_at')
                .eq('employee_email', currentUserEmail)
                .limit(1000);
              
              if (!auditError && allAudits) {
                // Filter by acknowledgement_status client-side (since status values may vary)
                let pendingAudits = allAudits.filter(audit => {
                  const ackStatus = audit.acknowledgement_status || audit.acknowledgementStatus || '';
                  const isPending = ackStatus && (
                    ackStatus.toLowerCase() === 'pending' || 
                    ackStatus === 'Pending'
                  );
                  
                  return isPending;
                });
                
                // Apply date filter (week or date range)
                const period = getCurrentPeriodDates();
                pendingAudits = pendingAudits.filter(audit => {
                  const auditDate = audit.submitted_at;
                  if (!auditDate) return false;
                  return isDateInRange(auditDate, period.start, period.end);
                });
                
                return pendingAudits.length;
              }
              return 0;
            } catch (err) {
              console.warn(`Error counting pending audits in ${scorecard.table_name}:`, err);
              return 0;
            }
          });
          
          const auditCounts = await Promise.all(auditPromises);
          requiresAcknowledgment = auditCounts.reduce((sum, count) => sum + count, 0);
          
        }
      } catch (error) {
        console.error('Error calculating acknowledgment count:', error);
      }
    }
    
    // Calculate reversal counts (for reversal card stats)
    // OPTIMIZATION: Reuse scorecards fetched at the beginning instead of fetching again
    try {
      if (scorecards.length > 0) {
        const reversalFilterField = isAgent ? 'employee_email' : 'auditor_email';
        
        // Parallelize all reversal count queries
        const reversalPromises = scorecards.map(async (scorecard) => {
          try {
            // For agents: Filter by employee_email server-side; for auditors: filter by auditor_email
            let query = window.supabaseClient
              .from(scorecard.table_name)
              .select('reversal_requested_at, reversal_responded_at, ' + reversalFilterField)
              .not('reversal_requested_at', 'is', null);
            
            // Add email filter server-side
            if (isAgent) {
              query = query.eq('employee_email', currentUserEmail);
            } else {
              query = query.eq('auditor_email', currentUserEmail);
            }
            
            let { data: allReversals, error: allError } = await query.limit(30); // Reduced from 500 to 30 for better performance
            
            // If error, table might not have reversal_requested_at column - skip this table silently
            if (allError) {
              // Don't log warning as this is expected for some tables
              return [];
            }
            
            if (!allError && allReversals) {
              // No email filtering needed - already filtered server-side
              // Apply date filter based on reversal_requested_at (using currentPeriod from outer scope)
              const filteredReversals = allReversals.filter(reversal => {
                const reversalDate = reversal.reversal_requested_at;
                if (!reversalDate) return false;
                return isDateInRange(reversalDate, currentPeriod.start, currentPeriod.end);
              });
              
              return filteredReversals.map(reversal => {
                const active = reversal.reversal_requested_at && !reversal.reversal_responded_at;
                const resolved = !!reversal.reversal_responded_at;
                return { active, resolved };
              });
            }
            return [];
          } catch (err) {
            console.warn(`Error counting reversals in ${scorecard.table_name}:`, err);
            return [];
          }
        });
        
        const reversalResults = await Promise.all(reversalPromises);
        const allReversalsData = reversalResults.flat();
        
        // Count all reversals for total/active/resolved stats
        allReversalsData.forEach(reversal => {
          totalReversals++;
          if (reversal.active) activeReversals++;
          if (reversal.resolved) resolvedReversals++;
        });
      }
    } catch (error) {
      console.error('Error calculating reversal counts:', error);
    }
    
    // Collect all stats into an object for caching
    const statsData = {
      totalAssigned,
      completed,
      inProgress,
      pending,
      remaining,
      percentage,
      daysRemaining,
      avgDuration,
      avgDurationText,
      totalAuditsConducted,
      totalScoreSum,
      totalAuditsWithScore,
      avgQualityScore,
      avgQualityScoreText,
      passingCount,
      notPassingCount,
      activeReversals,
      resolvedReversals,
      totalReversals,
      requiresAcknowledgment
    };
    
    // Cache the results in persistent cache
    try {
      const { persistentCacheService } = await import('/js/features/home/infrastructure/persistent-cache-service.js');
      const { buildCacheKey } = await import('/js/features/home/infrastructure/cache-aware-loader.js');
      const cacheKey = buildCacheKey('stats', currentUserEmail, JSON.stringify(currentPeriod), JSON.stringify(currentFilters));
      await persistentCacheService.set(cacheKey, statsData, 5 * 60 * 1000); // 5 minutes
    } catch (cacheError) {
      console.warn('Failed to cache in persistent storage, using sessionStorage:', cacheError);
      // Fallback to sessionStorage
      const cacheKey = `stats_${currentUserEmail}_${JSON.stringify(currentPeriod)}_${JSON.stringify(currentFilters)}`;
      sessionStorage.setItem(cacheKey, JSON.stringify(statsData));
      sessionStorage.setItem(cacheKey + '_time', Date.now().toString());
    }
    
    // Update UI with fresh data
    renderStatsFromData(statsData);
    
    // Return data for caching
    return statsData;
    
  } catch (error) {
    console.error('Error updating your stats:', error);
    throw error; // Re-throw so caller can handle
  }
}

function renderStatsFromData(stats) {
  const {
    totalAssigned,
    completed,
    inProgress,
    pending,
    remaining,
    percentage,
    daysRemaining,
    avgDurationText,
    totalAuditsConducted,
    totalAuditsWithScore,
    avgQualityScoreText,
    passingCount,
    notPassingCount,
    activeReversals,
    resolvedReversals,
    totalReversals,
    requiresAcknowledgment
  } = stats;
  
  // Update stat cards
  const statsAuditsConductedCount = document.getElementById('statsAuditsConductedCount');
  const statsRemainingText = document.getElementById('statsRemainingText');
  const statsRemainingProgress = document.getElementById('statsRemainingProgress');
  const statsAvgQualityScore = document.getElementById('statsAvgQualityScore');
  const statsAvgScoreSubtitle = document.getElementById('statsAvgScoreSubtitle');
  const statsPassingCount = document.getElementById('statsPassingCount');
  const statsNotPassingCount = document.getElementById('statsNotPassingCount');
  const statsRemainingCount = document.getElementById('statsRemainingCount');
  const statsInProgressCount = document.getElementById('statsInProgressCount');
  const statsDaysRemaining = document.getElementById('statsDaysRemaining');
  const statsReversalTotalCount = document.getElementById('statsReversalTotalCount');
  const statsReversalActiveCount = document.getElementById('statsReversalActiveCount');
  const statsReversalResolvedCount = document.getElementById('statsReversalResolvedCount');
  const statsRequiresAcknowledgmentCount = document.getElementById('statsRequiresAcknowledgmentCount');
  const requiresAcknowledgmentCard = document.getElementById('requiresAcknowledgmentCard');
  const statsAvgDuration = document.getElementById('statsAvgDuration');
  const statsAvgDurationSubtitle = document.getElementById('statsAvgDurationSubtitle');
  
  // Update Audits Conducted card
  if (statsAuditsConductedCount) statsAuditsConductedCount.textContent = totalAuditsConducted;
  if (statsRemainingText) statsRemainingText.textContent = `${remaining} remaining`;
  
  // Calculate progress bar percentage (completed / total assigned, showing completed portion in green)
  const completedCount = totalAssigned - remaining;
  const progressPercentage = totalAssigned > 0 ? Math.round((completedCount / totalAssigned) * 100) : 0;
  if (statsRemainingProgress) {
    statsRemainingProgress.style.width = `${Math.min(100, progressPercentage)}%`;
    if (progressPercentage > 0) {
      statsRemainingProgress.classList.remove('bg-warning');
      statsRemainingProgress.classList.add('bg-success');
    } else {
      statsRemainingProgress.classList.remove('bg-success');
      statsRemainingProgress.classList.add('bg-warning');
    }
  }
  
  // Update Average Quality Score card
  if (statsAvgQualityScore) statsAvgQualityScore.textContent = avgQualityScoreText;
  if (statsAvgScoreSubtitle) {
    statsAvgScoreSubtitle.textContent = totalAuditsConducted > 0 ? `from ${totalAuditsConducted} audits` : 'No audits yet';
  }
  
  // Update passing and not passing count chips
  if (statsPassingCount) {
    const loadingSpan = statsPassingCount.querySelector('span.inline-block');
    if (loadingSpan) {
      loadingSpan.remove();
    }
    const svg = statsPassingCount.querySelector('svg');
    const textSpan = statsPassingCount.querySelector('span:last-child');
    if (svg && textSpan) {
      let nextSibling = svg.nextSibling;
      while (nextSibling && nextSibling !== textSpan) {
        const toRemove = nextSibling;
        nextSibling = nextSibling.nextSibling;
        toRemove.remove();
      }
      textSpan.textContent = `${passingCount} Passed`;
    }
  }
  if (statsNotPassingCount) {
    const loadingSpan = statsNotPassingCount.querySelector('span.inline-block');
    if (loadingSpan) {
      loadingSpan.remove();
    }
    const svg = statsNotPassingCount.querySelector('svg');
    const textSpan = statsNotPassingCount.querySelector('span:last-child');
    if (svg && textSpan) {
      let nextSibling = svg.nextSibling;
      while (nextSibling && nextSibling !== textSpan) {
        const toRemove = nextSibling;
        nextSibling = nextSibling.nextSibling;
        toRemove.remove();
      }
      textSpan.textContent = `${notPassingCount} Not Passed`;
    }
  }
  
  // Calculate and update Pass Rate (for employees)
  const passRate = totalAuditsConducted > 0 ? Math.round((passingCount / totalAuditsConducted) * 100) : 0;
  const statsPassRate = document.getElementById('statsPassRate');
  const statsPassRateChange = document.getElementById('statsPassRateChange');
  if (statsPassRate) {
    const loadingDiv = statsPassRate.querySelector('div');
    if (loadingDiv) loadingDiv.remove();
    statsPassRate.textContent = `${passRate}%`;
  }
  if (statsPassRateChange) {
    // Hide the "X passed" text since we're showing counts as chips in the Pass Rate card
    statsPassRateChange.style.display = 'none';
  }
  
  // Update other cards
  if (statsRemainingCount) statsRemainingCount.textContent = remaining;
  if (statsInProgressCount) statsInProgressCount.textContent = inProgress;
  if (statsDaysRemaining) statsDaysRemaining.textContent = `${daysRemaining} working day${daysRemaining !== 1 ? 's' : ''} remaining`;
  
  // Update Reversal card
  if (statsReversalTotalCount) statsReversalTotalCount.textContent = totalReversals;
  if (statsReversalActiveCount) statsReversalActiveCount.textContent = activeReversals;
  if (statsReversalResolvedCount) statsReversalResolvedCount.textContent = resolvedReversals;
  
  // Update Requires Acknowledgment card (agents only)
  if (isAgent && statsRequiresAcknowledgmentCount && requiresAcknowledgmentCard) {
    statsRequiresAcknowledgmentCount.textContent = requiresAcknowledgment;
    requiresAcknowledgmentCard.style.display = 'block';
  } else if (requiresAcknowledgmentCard) {
    requiresAcknowledgmentCard.style.display = 'none';
  }
  
  // Update Avg Duration card
  if (statsAvgDuration) {
    // Clear any loading placeholder and set the value directly
    statsAvgDuration.innerHTML = '';
    const displayValue = avgDurationText || '-';
    statsAvgDuration.textContent = displayValue;
    // Ensure element is visible (in case it was hidden)
    statsAvgDuration.style.display = '';
  } else {
    console.warn('statsAvgDuration element not found');
  }
  if (statsAvgDurationSubtitle) {
    statsAvgDurationSubtitle.textContent = 'per audit';
  }
}

function viewAudit(assignmentId) {
  const q = assignmentId ? `?assignment=${encodeURIComponent(assignmentId)}` : '';
  window.location.href = `/create-audit${q}`;
}

function viewAuditDetails(auditId, scorecardId, tableName) {
  window.location.href = `/audit-view.html?id=${auditId}&scorecard=${scorecardId || ''}&table=${tableName || ''}`;
}

function formatTimestamp(timestamp) {
  if (!timestamp) return 'N/A';
  
  const date = new Date(timestamp);
  const now = new Date();
  const diffMs = now - date;
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
  
  if (diffDays === 0) {
    return 'Today ' + date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
  } else if (diffDays === 1) {
    return 'Yesterday';
  } else if (diffDays < 7) {
    return date.toLocaleDateString('en-US', { weekday: 'long' });
  } else {
    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  }
}

function getStatusText(status, isAgentView = false) {
  if (isAgentView) {
    const statusMap = {
      'pending': 'New audit assigned to you',
      'in_progress': 'Your audit is in progress',
      'completed': 'Your audit was completed'
    };
    return statusMap[status] || 'Status updated';
  } else {
    const statusMap = {
      'pending': 'New assignment',
      'in_progress': 'Audit started',
      'completed': 'Audit completed'
    };
    return statusMap[status] || 'Status updated';
  }
}

// Helper function to normalize passing status (handles both old and new values)
function normalizePassingStatus(status) {
  if (!status) return status;
  // Convert old values to new ones for consistency
  if (status === 'Passing' || status === 'Pass') return 'Passed';
  if (status === 'Not Passing') return 'Not Passed';
  return status; // Return as-is if already normalized or unknown
}

function getInitials(name) {
  if (!name) return '?';
  return name.split(' ').map(n => n.charAt(0)).join('').toUpperCase().slice(0, 2);
}

function escapeHtml(text) {
  if (!text) return '';
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

function getAcknowledgmentStatusChip(audit) {
  const acknowledgementStatus = audit.acknowledgement_status || audit.acknowledgementStatus || '';
  
  // Check if acknowledged
  const isAcknowledged = acknowledgementStatus && (
    acknowledgementStatus.toLowerCase().includes('acknowledged') || 
    acknowledgementStatus === 'Acknowledged'
  );
  
  // Check if pending
  const isPending = acknowledgementStatus && (
    acknowledgementStatus.toLowerCase() === 'pending' || 
    acknowledgementStatus === 'Pending'
  );
  
  // If no status or empty, default to pending (since audits are created with pending by default)
  if (!acknowledgementStatus || acknowledgementStatus.trim() === '') {
    return `<span class="status-badge status-badge-pending">
      <svg class="icon-md" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
      </svg>
      Acknowledgement Pending
    </span>`;
  }
  
  if (isAcknowledged) {
    return `<span class="status-badge status-badge-approved">
      <svg class="icon-md" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
      </svg>
      Acknowledged
    </span>`;
  }
  
  if (isPending) {
    return `<span class="status-badge status-badge-pending">
      <svg class="icon-md" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
      </svg>
      Acknowledgement Pending
    </span>`;
  }
  
  // Default: show pending if status is unknown
  return `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded text-[10px] font-semibold" style="background-color: #fef3c7; color: #92400e;">
    <svg style="width: 0.75rem; height: 0.75rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
    </svg>
    Acknowledgement Pending
  </span>`;
}

function getReversalStatusChip(audit) {
  // Check if audit has reversal request
  const reversalRequestedAt = audit.reversal_requested_at || audit.reversalRequestedAt;
  const reversalRespondedAt = audit.reversal_responded_at || audit.reversalRespondedAt;
  const reversalApproved = audit.reversal_approved;
  const acknowledgementStatus = audit.acknowledgement_status || audit.acknowledgementStatus;
  
  // If no reversal was requested, return empty
  if (!reversalRequestedAt) return '';
  
  // Determine status from reversal_approved and acknowledgement_status
  let status = null;
  
  // Check acknowledgement first
  if (acknowledgementStatus === 'Acknowledged') {
    status = 'Acknowledged';
  } 
  // If reversal was requested but not responded to yet
  else if (reversalRequestedAt && !reversalRespondedAt) {
    status = 'Pending';
  }
  // If reversal was responded to, check approval status
  else if (reversalRespondedAt) {
    // Handle different possible formats for reversal_approved
    if (reversalApproved === true || reversalApproved === 'true' || reversalApproved === 1 || reversalApproved === '1') {
      status = 'Approved';
    } else if (reversalApproved === false || reversalApproved === 'false' || reversalApproved === 0 || reversalApproved === '0') {
      status = 'Rejected';
    } else {
      // If responded but approval status unclear, default to Pending
      status = 'Pending';
    }
  }
  
  // If no status determined, return empty string
  if (!status) return '';
  
  // Determine chip styling based on status
  let statusBgColor, statusTextColor, statusIcon;
  if (status === 'Pending') {
    statusBgColor = '#fef3c7';
    statusTextColor = '#92400e';
    statusIcon = `<svg style="width: 0.75rem; height: 0.75rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
    </svg>`;
    statusText = 'Pending';
  } else if (status === 'Approved') {
    statusBgColor = '#dcfce7';
    statusTextColor = '#166534';
    statusIcon = `<svg style="width: 0.75rem; height: 0.75rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
    </svg>`;
    statusText = 'Approved';
  } else if (status === 'Rejected') {
    statusBgColor = '#fee2e2';
    statusTextColor = '#991b1b';
    statusIcon = `<svg style="width: 0.75rem; height: 0.75rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
    </svg>`;
    statusText = 'Rejected';
  } else if (status === 'Acknowledged') {
    statusBgColor = '#dbeafe';
    statusTextColor = '#1e40af';
    statusIcon = `<svg style="width: 0.75rem; height: 0.75rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
    </svg>`;
    statusText = 'Acknowledged';
  } else {
    statusBgColor = '#f3f4f6';
    statusTextColor = '#374151';
    statusIcon = '';
    statusText = status;
  }
  
  return `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded text-[10px] font-semibold" style="background-color: ${statusBgColor}; color: ${statusTextColor};">
    ${statusIcon}
    ${statusText}
  </span>`;
}

// Notifications
async function loadNotifications() {
  try {
    if (!currentUserEmail) {
      const notificationsList = document.getElementById('notificationsList');
      if (notificationsList) {
        notificationsList.innerHTML = `
          <div class="notification-panel-empty">
            <p class="notification-panel-empty-title">No user logged in</p>
          </div>
        `;
      }
      return;
    }

    // Wait for Supabase to be ready
    if (!window.supabaseClient || !window.supabaseReady) {
      const ready = await waitForSupabase(3000);
      if (!ready) {
        const notificationsList = document.getElementById('notificationsList');
        if (notificationsList) {
          notificationsList.innerHTML = `
            <div class="notification-panel-empty">
              <p class="notification-panel-empty-title" style="color:#b91c1c;">Unable to load notifications</p>
              <p class="notification-panel-empty-text">Please refresh the page</p>
            </div>
          `;
        }
        return;
      }
    }

    // Check cache first
    const cacheKey = `notifications_${currentUserEmail}`;
    const cachedData = sessionStorage.getItem(cacheKey);
    const cachedTime = sessionStorage.getItem(cacheKey + '_time');
    const cacheAge = cachedTime ? Date.now() - parseInt(cachedTime) : Infinity;
    
    if (cachedData && cacheAge < 60000) { // 1 minute cache (extended from 30 seconds for better performance)
      notifications = JSON.parse(cachedData);
      const cachedUnread = sessionStorage.getItem(cacheKey + '_unread');
      if (cachedUnread) {
        unreadNotificationCount = parseInt(cachedUnread);
      }
      renderNotifications();
      updateNotificationBadge();
      return;
    }

    // Show loader
    const notificationsList = document.getElementById('notificationsList');
    if (notificationsList) {
      const loadingHtml = `
        <div class="notification-panel-empty">
          <svg class="animate-spin" width="40" height="40" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="color:#9ca3af;">
            <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="3" stroke-dasharray="32" stroke-dashoffset="12"></circle>
          </svg>
          <p class="notification-panel-empty-title">Loading notifications...</p>
        </div>
      `;
      showLoader('notificationsList', loadingHtml);
    }

    await fetchAndCacheNotifications();
  } catch (error) {
    console.error('Error loading notifications:', error);
    const notificationsList = document.getElementById('notificationsList');
    if (notificationsList) {
      notificationsList.innerHTML = `
        <div class="px-4 py-8 text-center text-red-500 text-xs">
          <p class="font-medium mb-1">Error loading notifications</p>
          <p class="text-gray-500">Please try again</p>
        </div>
      `;
    }
  }
}

async function fetchAndCacheNotifications() {
  try {
    if (!currentUserEmail) return;

    // Get recent audit assignments updates from audit tables
    // Filter by employee_email if agent, otherwise by auditor_email
    const notificationFilterField = isAgent ? 'employee_email' : 'auditor_email';
    
    const { getAuthenticatedSupabase } = await import('/js/utils/authenticated-supabase.js');
    const supabase = await getAuthenticatedSupabase();
    
    const { data: scorecards, error: scError } = await supabase
      .from('scorecards')
      .select('table_name')
      .eq('is_active', true);
    
    let assignments = [];
    if (!scError && scorecards) {
      const assignmentPromises = scorecards.map(async (scorecard) => {
        try {
          // Query scorecard tables (all audits in scorecard tables are completed by default)
          // Use submitted_at for ordering since assignment_created_at doesn't exist in scorecard tables
          // Use field whitelist - select only needed fields
          let { data: audits, error } = await supabase
            .from(scorecard.table_name)
            .select('id, employee_email, employee_name, auditor_email, auditor_name, interaction_id, created_at, submitted_at, passing_status')
            .eq(notificationFilterField, currentUserEmail)
            .order('submitted_at', { ascending: false })
            .limit(20);
          
          if (error) {
            // If error, table might not have the filter field column - skip this table silently
            // Don't log warning as this is expected for some tables
            return [];
          }
          
          if (!error && audits) {
            return audits.map(audit => ({
              ...audit,
              status: 'completed', // All audits in scorecard tables are completed by default
              created_at: audit.created_at,
              completed_at: audit.submitted_at
            }));
          }
          return [];
        } catch (err) {
          console.warn(`Error loading from ${scorecard.table_name}:`, err);
          return [];
        }
      });
      
      const assignmentResults = await Promise.all(assignmentPromises);
      assignments = assignmentResults.flat();
    }

    // For auditors: add pending/in_progress assignments from audit_assignments (so "Audit assigned" appears in the bell)
    if (!isAgent && currentUserEmail) {
      try {
        const { data: pendingAssignments, error: paError } = await supabase
          .from('audit_assignments')
          .select('id, employee_email, employee_name, auditor_email, status, scheduled_date, created_at')
          .eq('auditor_email', currentUserEmail)
          .in('status', ['pending', 'in_progress'])
          .order('created_at', { ascending: false })
          .limit(30);
        if (!paError && pendingAssignments && pendingAssignments.length > 0) {
          assignments = (pendingAssignments || []).concat(assignments);
        }
      } catch (err) {
        console.warn('Error loading pending audit assignments for notifications:', err);
      }
    }

    // Get reversals (audits with reversal requests)
    const { data: reversalScorecards, error: reversalScError } = await window.supabaseClient
      .from('scorecards')
      .select('table_name')
      .eq('is_active', true);

    let reversals = [];
    if (!reversalScError && reversalScorecards) {
      // Filter by employee_email if agent, otherwise by auditor_email
      const reversalNotificationFilterField = isAgent ? 'employee_email' : 'auditor_email';
      const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
      
      for (const scorecard of reversalScorecards) {
        try {
          // For agents: Filter by employee_email server-side; for auditors: filter by auditor_email
          let query = window.supabaseClient
            .from(scorecard.table_name)
            .select('id, employee_name, employee_email, auditor_email, reversal_requested_at, reversal_responded_at, reversal_approved, acknowledgement_status, interaction_id, submitted_at')
            .not('reversal_requested_at', 'is', null);
          
          // Add email filter server-side
          if (isAgent) {
            query = query.eq('employee_email', currentUserEmail);
          } else {
            query = query.eq('auditor_email', currentUserEmail);
          }
          
          let { data: auditReversals, error } = await query
            .order('reversal_requested_at', { ascending: false })
            .limit(30); // Reduced from 200 to 30 for better performance

          // If error, table might not have reversal_requested_at column - skip this table silently
          if (error) {
            // Don't log warning as this is expected for some tables
            continue;
          }

          if (!error && auditReversals && auditReversals.length > 0) {
            // No email filtering needed - already filtered server-side
            let filteredReversals = auditReversals;
            
            // Apply the same filtering logic as reversal.html
            if (isAgent) {
              // For agents: Show reversals that need acknowledgement
              filteredReversals = filteredReversals.filter(reversal => {
                const acknowledgementStatus = reversal.acknowledgement_status || reversal.acknowledgementStatus || '';
                const isAcknowledged = acknowledgementStatus && (
                  acknowledgementStatus.toLowerCase().includes('acknowledged') || 
                  acknowledgementStatus === 'Acknowledged'
                );
                
                const isPending = reversal.reversal_approved === null;
                const isApproved = reversal.reversal_approved === true || reversal.reversal_approved === 'true' || reversal.reversal_approved === 1 || reversal.reversal_approved === '1';
                const isRejected = reversal.reversal_approved === false || reversal.reversal_approved === 'false' || reversal.reversal_approved === 0 || reversal.reversal_approved === '0';
                
                return !isAcknowledged && (isPending || isApproved || isRejected);
              });
            } else {
              // For auditors: Only show unprocessed reversals (reversal_approved is null)
              filteredReversals = filteredReversals.filter(rev => rev.reversal_approved === null);
            }
            
            // Sort reversals: prioritize those with recent responses
            filteredReversals.sort((a, b) => {
              const aResponded = a.reversal_responded_at ? new Date(a.reversal_responded_at).getTime() : 0;
              const bResponded = b.reversal_responded_at ? new Date(b.reversal_responded_at).getTime() : 0;
              if (aResponded !== bResponded) {
                return bResponded - aResponded; // Most recent responses first
              }
              const aRequested = new Date(a.reversal_requested_at).getTime();
              const bRequested = new Date(b.reversal_requested_at).getTime();
              return bRequested - aRequested;
            });
            
            filteredReversals.forEach(rev => {
              // Determine reversal status - check if it's been responded to first, then check acknowledgement
              const acknowledgementStatus = rev.acknowledgement_status || rev.acknowledgementStatus;
              const isAcknowledged = acknowledgementStatus && (
                acknowledgementStatus.toLowerCase().includes('acknowledged') || 
                acknowledgementStatus === 'Acknowledged'
              );
              
              let status = null;
              
              // Determine status from reversal_approved and acknowledgement_status
              // Check acknowledgement first
              if (acknowledgementStatus === 'Acknowledged') {
                status = 'Acknowledged';
              }
              // If reversal was responded to, check approval status
              else if (rev.reversal_responded_at) {
                const approved = rev.reversal_approved;
                if (approved === true || approved === 'true' || approved === 1 || approved === '1') {
                  status = 'Approved';
                } else if (approved === false || approved === 'false' || approved === 0 || approved === '0') {
                  status = 'Rejected';
                } else {
                  status = 'Pending';
                }
              }
              // If reversal was requested but not responded to yet
              else if (rev.reversal_requested_at && !rev.reversal_responded_at) {
                status = 'Pending';
              }
              
              // For agents: Add notifications for all reversals that appear in reversal.html
              // For auditors: Only add notifications for unprocessed reversals (already filtered above)
              
              // Add notification for reversal request (for pending reversals)
              if (status === 'Pending') {
              reversals.push({
              ...rev,
              type: 'reversal',
                reversal_status: status,
              scorecard_table: scorecard.table_name
              });
              }
              
              // Add notification for status update if status is Approved or Rejected but NOT yet acknowledged
              if (status && (status === 'Approved' || status === 'Rejected') && !isAcknowledged) {
                const statusText = status === 'Approved' ? 'approved' : 'rejected';
                reversals.push({
                  ...rev,
                  type: 'reversal_status_update',
                  reversal_status: status,
                  status_text: statusText,
                  timestamp: rev.reversal_responded_at || rev.reversal_requested_at,
                  scorecard_table: scorecard.table_name
                });
              }
            });
          }
        } catch (err) {
          console.warn(`Error loading reversals from ${scorecard.table_name}:`, err);
        }
      }
    }

    // Combine and format notifications
    notifications = [];

    // Add assignment updates (only for auditors, or completed audits for agents)
    (assignments || []).forEach(assignment => {
      // For agents, only show completed audits, not pending/in_progress assignments
      if (isAgent && assignment.status !== 'completed') {
        return;
      }
      
      const employee = allUsers.find(u => u.email === assignment.employee_email);
      const employeeName = employee?.name || assignment.employee_name || assignment.employee_email?.split('@')[0] || 'Unknown';
      
      const displayName = assignment.employee_name || employeeName;
      const message = (employeeName === displayName || !assignment.employee_name)
        ? employeeName
        : `${employeeName}  ${displayName}`;
      notifications.push({
        id: `assignment-${assignment.id}`,
        type: 'assignment',
        title: `Audit ${assignment.status === 'completed' ? 'completed' : assignment.status === 'in_progress' ? 'started' : 'assigned'}`,
        message,
        timestamp: assignment.scheduled_date ? new Date(assignment.scheduled_date + 'T00:00:00').toISOString() : assignment.created_at,
        status: assignment.status,
        assignmentId: assignment.id
      });
    });

    // Add reversal notifications
    reversals.forEach(reversal => {
      if (reversal.type === 'reversal_status_update') {
        // Status update notification
        const statusDisplay = reversal.reversal_status === 'Approved' ? 'Approved' : reversal.reversal_status === 'Rejected' ? 'Rejected' : reversal.reversal_status === 'Acknowledged' ? 'Acknowledged' : 'Updated';
        const interactionId = reversal.interaction_id || '';
        notifications.push({
          id: `reversal-status-${reversal.id}`,
          type: 'reversal_status_update',
          title: `Reversal ${statusDisplay}`,
          message: isAgent 
            ? `Your reversal request has been ${reversal.status_text || 'updated'}`
            : `Reversal request${interactionId ? ` for ${interactionId}` : ''} has been ${reversal.status_text || 'updated'}`,
          timestamp: reversal.timestamp || reversal.reversal_responded_at,
          auditId: reversal.id,
          tableName: reversal.scorecard_table,
          status: reversal.reversal_status
        });
      } else {
        // Initial reversal request notification
      notifications.push({
        id: `reversal-${reversal.id}`,
        type: 'reversal',
        title: 'Reversal Requested',
        message: `${reversal.employee_name || reversal.employee_email || 'Audit'} - Reversal requested`,
        timestamp: reversal.reversal_requested_at,
        auditId: reversal.id,
        tableName: reversal.scorecard_table
      });
      }
    });

    // Sort by timestamp (most recent first)
    notifications.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

    // Limit to 20 most recent
    notifications = notifications.slice(0, 20);

    // Count unread notifications (last 7 days)
    // For agents, prioritize reversal status updates
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    const recentNotifications = notifications.filter(n => new Date(n.timestamp) >= sevenDaysAgo);
    
    if (isAgent) {
      // For agents, count reversal status updates separately
      const reversalStatusUpdates = recentNotifications.filter(n => n.type === 'reversal_status_update');
      unreadNotificationCount = reversalStatusUpdates.length > 0 ? reversalStatusUpdates.length : recentNotifications.length;
    } else {
      unreadNotificationCount = recentNotifications.length;
    }

    // Cache the results
    const cacheKey = `notifications_${currentUserEmail}`;
    sessionStorage.setItem(cacheKey, JSON.stringify(notifications));
    sessionStorage.setItem(cacheKey + '_time', Date.now().toString());
    sessionStorage.setItem(cacheKey + '_unread', unreadNotificationCount.toString());
    
    // Update UI with fresh data
    renderNotifications();
    updateNotificationBadge();

  } catch (error) {
    console.error('Error loading notifications:', error);
    document.getElementById('notificationsList').innerHTML = `
      <div class="notification-panel-empty">
        <p class="notification-panel-empty-title" style="color:#b91c1c;">Error loading notifications</p>
        <p class="notification-panel-empty-text">Please try again</p>
      </div>
    `;
  }
}

function getNotificationTimeGroup(timestamp) {
  if (!timestamp) return 'older';
  const date = new Date(timestamp);
  const now = new Date();
  const diffMs = now - date;
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
  if (diffDays === 0) return 'today';
  if (diffDays === 1) return 'yesterday';
  if (diffDays < 7) return 'this_week';
  return 'older';
}

function formatNotificationExactTime(timestamp) {
  if (!timestamp) return 'N/A';
  const date = new Date(timestamp);
  return date.toLocaleString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric',
    hour: 'numeric',
    minute: '2-digit',
    hour12: true
  });
}

const NOTIFICATION_GROUP_LABELS = { today: 'Today', yesterday: 'Yesterday', this_week: 'This week', older: 'Older' };

function renderNotifications() {
  const list = document.getElementById('notificationsList');
  if (!list) return;

  if (notifications.length === 0) {
    list.innerHTML = `
      <div class="notification-panel-empty">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"/>
        </svg>
        <p class="notification-panel-empty-title">No notifications</p>
        <p class="notification-panel-empty-text">You're all caught up.</p>
      </div>
    `;
    return;
  }

  const grouped = { today: [], yesterday: [], this_week: [], older: [] };
  notifications.forEach(n => {
    const group = getNotificationTimeGroup(n.timestamp);
    grouped[group].push(n);
  });

  // Track newest notifications (first 3 in "today" section)
  const newestNotificationIds = new Set();
  if (grouped.today.length > 0) {
    grouped.today.slice(0, 3).forEach(n => newestNotificationIds.add(n.id));
  }

  function renderItem(notification, isNew = false) {
    const exactTime = formatNotificationExactTime(notification.timestamp);
    let typeClass, categoryLabel, categoryClass, statusChipLabel = '', statusValue = '';
    if (notification.type === 'reversal_status_update') {
      typeClass = 'notification-type-reversal_status';
      categoryLabel = 'Status';
      categoryClass = 'category-status';
      if (notification.status) {
        statusChipLabel = notification.status;
        statusValue = notification.status;
      }
    } else if (notification.type === 'reversal') {
      typeClass = 'notification-type-reversal';
      categoryLabel = 'Reversal';
      categoryClass = 'category-reversal';
    } else {
      typeClass = 'notification-type-assignment';
      categoryLabel = 'Audit';
      categoryClass = 'category-audit';
      if (notification.status === 'completed') {
        statusChipLabel = 'Completed';
        statusValue = 'completed';
      } else if (notification.status === 'in_progress') {
        statusChipLabel = 'In progress';
        statusValue = 'in_progress';
      } else if (notification.status === 'pending') {
        statusChipLabel = 'Assigned';
        statusValue = 'pending';
      }
    }

    let iconPath = '';
    if (notification.type === 'reversal_status_update') {
      if (notification.status === 'Approved') {
        iconPath = 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z';
      } else if (notification.status === 'Rejected') {
        iconPath = 'M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z';
      } else {
        iconPath = 'M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z';
      }
    } else if (notification.type === 'reversal') {
      iconPath = 'M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z';
    } else if (notification.status === 'completed') {
      iconPath = 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z';
    } else if (notification.status === 'in_progress') {
      iconPath = 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z';
    } else {
      iconPath = 'M12 6v6m0 0v6m0-6h6m-6 0H6';
    }

    const chipsHtml = statusChipLabel
      ? `<span class="notification-panel-item-category ${categoryClass}">${escapeHtml(categoryLabel)}</span><span class="notification-panel-item-status-chip" data-status="${escapeHtml(statusValue)}">${escapeHtml(statusChipLabel)}</span>`
      : `<span class="notification-panel-item-category ${categoryClass}">${escapeHtml(categoryLabel)}</span>`;

    const newClass = isNew ? ' notification-new' : '';
    const statusAttr = statusValue ? ` data-status="${escapeHtml(statusValue)}"` : '';

    return `
      <div class="notification-panel-item ${typeClass}${newClass}" data-notification-id="${notification.id}"${statusAttr}>
        <div class="notification-panel-item-inner">
          <div class="notification-panel-item-icon">
            <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${iconPath}"/>
            </svg>
          </div>
          <div class="notification-panel-item-body">
            <div class="notification-panel-item-meta">
              <div class="notification-panel-item-chips">${chipsHtml}</div>
              <span class="notification-panel-item-time">${escapeHtml(exactTime)}</span>
            </div>
            <p class="notification-panel-item-title">${escapeHtml(notification.title)}</p>
            <p class="notification-panel-item-message">${escapeHtml(notification.message)}</p>
          </div>
        </div>
      </div>
    `;
  }

  const sections = ['today', 'yesterday', 'this_week', 'older'];
  list.innerHTML = sections.map(groupKey => {
    const items = grouped[groupKey];
    if (!items.length) return '';
    const label = NOTIFICATION_GROUP_LABELS[groupKey];
    const itemsHtml = items.map((item, index) => {
      const isNew = groupKey === 'today' && newestNotificationIds.has(item.id);
      return renderItem(item, isNew);
    }).join('');
    return `
      <div class="notification-panel-section">
        <div class="notification-panel-section-title">${label}</div>
        ${itemsHtml}
      </div>
    `;
  }).filter(Boolean).join('');
}

function updateNotificationBadge() {
  const badge = document.getElementById('notificationBadge');
  if (!badge) return;

  // Only show badge if there are unread notifications (count > 0)
  if (unreadNotificationCount > 0) {
    badge.classList.remove('hidden');
    badge.textContent = unreadNotificationCount > 9 ? '9+' : unreadNotificationCount;
    badge.classList.add('bg-error');
  } else {
    // Hide badge when no notifications
    badge.classList.add('hidden');
    badge.textContent = '';
  }
}

// Lazy loading flag for notifications
let notificationsLoaded = false;
let notificationsLoading = false;

function showNotifications() {
  const modal = document.getElementById('notificationsModal');
  if (!modal) return;
  
  // Clear unread count when viewing notifications
  unreadNotificationCount = 0;
  updateNotificationBadge();
  
  // Load notifications only once (lazy loading) - but allow retry if it failed
  if (!notificationsLoaded && !notificationsLoading) {
    notificationsLoading = true;
    loadNotifications()
      .then(() => {
        notificationsLoaded = true;
        notificationsLoading = false;
      })
      .catch(err => {
        console.error('Error loading notifications:', err);
        notificationsLoading = false;
        // Don't set notificationsLoaded = true on error, so it can retry
        const notificationsList = document.getElementById('notificationsList');
        if (notificationsList) {
          notificationsList.innerHTML = `
            <div class="notification-panel-empty">
              <p class="notification-panel-empty-title" style="color:#b91c1c;">Error loading notifications</p>
              <p class="notification-panel-empty-text">Please try again</p>
            </div>
          `;
        }
      });
  }
  
  modal.classList.add('visible');
}

function hideNotifications() {
  const modal = document.getElementById('notificationsModal');
  if (!modal) return;
  
  modal.classList.remove('visible');
}

// Show notifications on hover
document.addEventListener('DOMContentLoaded', function() {
  const notificationBtn = document.getElementById('notificationBtn');
  const notificationModal = document.getElementById('notificationsModal');
  
  if (notificationBtn && notificationModal) {
    let hoverTimeout;
    
    notificationBtn.addEventListener('mouseenter', function() {
      clearTimeout(hoverTimeout);
      showNotifications();
    });
    
    notificationBtn.addEventListener('mouseleave', function(e) {
      // Check if mouse is moving to modal
      const relatedTarget = e.relatedTarget;
      if (notificationModal.contains(relatedTarget)) {
        return; // Don't hide if moving to modal
      }
      
      hoverTimeout = setTimeout(() => {
        hideNotifications();
      }, 200); // Small delay to allow moving to modal
    });
    
    notificationModal.addEventListener('mouseenter', function() {
      clearTimeout(hoverTimeout);
    });
    
    notificationModal.addEventListener('mouseleave', function() {
      hideNotifications();
    });
  }
  
  // Calendar hover functionality
  const calendarBtn = document.getElementById('calendarBtn');
  const calendarModal = document.getElementById('calendarModal');
  
  if (calendarBtn && calendarModal) {
    let calendarHoverTimeout;
    
    calendarBtn.addEventListener('mouseenter', function() {
      clearTimeout(calendarHoverTimeout);
      showCalendar();
    });
    
    calendarBtn.addEventListener('mouseleave', function(e) {
      const relatedTarget = e.relatedTarget;
      if (calendarModal.contains(relatedTarget)) {
        return;
      }
      
      calendarHoverTimeout = setTimeout(() => {
        hideCalendar();
      }, 200);
    });
    
    calendarModal.addEventListener('mouseenter', function() {
      clearTimeout(calendarHoverTimeout);
    });
    
    calendarModal.addEventListener('mouseleave', function() {
      hideCalendar();
    });
  }
  
  // Grid hover functionality
  const gridBtn = document.getElementById('gridBtn');
  const gridModal = document.getElementById('gridModal');
  
  if (gridBtn && gridModal) {
    let gridHoverTimeout;
    
    gridBtn.addEventListener('mouseenter', function() {
      clearTimeout(gridHoverTimeout);
      showGrid();
    });
    
    gridBtn.addEventListener('mouseleave', function(e) {
      const relatedTarget = e.relatedTarget;
      if (gridModal.contains(relatedTarget)) {
        return;
      }
      
      gridHoverTimeout = setTimeout(() => {
        hideGrid();
      }, 200);
    });
    
    gridModal.addEventListener('mouseenter', function() {
      clearTimeout(gridHoverTimeout);
    });
    
    gridModal.addEventListener('mouseleave', function() {
      hideGrid();
    });
  }
  
  // Avatar logout menu hover functionality
  const userProfileContainer = document.getElementById('userProfileContainer');
  const avatarLogoutMenu = document.getElementById('avatarLogoutMenu');
  
  if (userProfileContainer && avatarLogoutMenu) {
    let avatarHoverTimeout;
    
    userProfileContainer.addEventListener('mouseenter', function() {
      clearTimeout(avatarHoverTimeout);
      avatarLogoutMenu.classList.remove('opacity-0', 'invisible');
      avatarLogoutMenu.classList.add('opacity-100', 'visible');
    });
    
    userProfileContainer.addEventListener('mouseleave', function(e) {
      const relatedTarget = e.relatedTarget;
      if (avatarLogoutMenu.contains(relatedTarget)) {
        return;
      }
      
      avatarHoverTimeout = setTimeout(() => {
        hideAvatarLogout();
      }, 200);
    });
    
    avatarLogoutMenu.addEventListener('mouseenter', function() {
      clearTimeout(avatarHoverTimeout);
    });
    
    avatarLogoutMenu.addEventListener('mouseleave', function() {
      hideAvatarLogout();
    });
  }
});

// Calendar modal functions
// Lazy loading flag for events
let eventsLoaded = false;

function showCalendar() {
  const modal = document.getElementById('calendarModal');
  if (!modal) return;
  
  // Load events only once (lazy loading)
  if (!eventsLoaded) {
    eventsLoaded = true;
    loadUpcomingEvents().catch(err => console.error('Error loading events:', err));
  }
  
  modal.classList.remove('opacity-0', 'invisible');
  modal.classList.add('opacity-100', 'visible');
}

function hideCalendar() {
  const modal = document.getElementById('calendarModal');
  if (!modal) return;
  
  modal.classList.remove('opacity-100', 'visible');
  modal.classList.add('opacity-0', 'invisible');
}

// Load upcoming events for calendar modal
async function loadUpcomingEvents() {
  try {
    const eventsList = document.getElementById('eventsList');
    if (!eventsList) return;

    // Get authenticated Supabase client
    const { getAuthenticatedSupabase } = await import('/js/utils/authenticated-supabase.js');
    const supabase = await getAuthenticatedSupabase();

    // Get current user info
    const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
    const currentUserEmail = (userInfo.email || '').toLowerCase().trim();
    const isSuperAdmin = userInfo.role === 'Super Admin';

    // Get today's date in YYYY-MM-DD format
    const today = getDhakaNow ? getDhakaNow() : new Date();
    const todayStr = today.toISOString().split('T')[0];
    const now = getDhakaNow ? getDhakaNow() : new Date();
    const currentTime = now.toTimeString().slice(0, 5); // HH:MM format

    let query = supabase
      .from('events')
      .select('id, title, type, date, start_time, end_time');

    // Filter: only upcoming events (date >= today)
    query = query.gte('date', todayStr);

    // If user is not Super Admin, show events where they are a participant or creator
    if (!isSuperAdmin && currentUserEmail) {
      // First get all events where user is creator
      const { data: createdEvents, error: createdError } = await supabase
        .from('events')
        .select('id, title, type, date, start_time, end_time')
        .eq('created_by', currentUserEmail)
        .gte('date', todayStr)
        .order('date', { ascending: true })
        .order('start_time', { ascending: true });

      if (createdError && createdError.code !== 'PGRST116' && !createdError.message.includes('does not exist')) {
        console.warn('Error loading created events:', createdError);
      }

      // Then get all events and filter client-side for participants
      const { data: allEvents, error: allError } = await supabase
        .from('events')
        .select('id, title, type, date, start_time, end_time, participants')
        .gte('date', todayStr)
        .order('date', { ascending: true })
        .order('start_time', { ascending: true });

      if (allError) {
        // If table doesn't exist, show empty state
        if (allError.code === 'PGRST116' || allError.message.includes('does not exist')) {
          renderEventsList([]);
          return;
        }
        throw allError;
      }

      // Filter events where user is a participant
      const participantEvents = (allEvents || []).filter(event => {
        if (!event.participants) return false;
        
        let participantEmails = [];
        if (Array.isArray(event.participants)) {
          participantEmails = event.participants;
        } else if (typeof event.participants === 'string') {
          try {
            const parsed = JSON.parse(event.participants);
            participantEmails = Array.isArray(parsed) ? parsed : [event.participants];
          } catch {
            participantEmails = event.participants.split(',').map(e => e.trim()).filter(e => e);
          }
        }
        
        return participantEmails.some(email => email.toLowerCase().trim() === currentUserEmail);
      });

      // Combine created and participant events, remove duplicates
      const combinedEvents = [...(createdEvents || []), ...participantEvents];
      const uniqueEvents = combinedEvents.filter((event, index, self) => 
        index === self.findIndex(e => e.id === event.id)
      );

      // Filter to only show truly upcoming events
      const upcomingEvents = uniqueEvents.filter(event => {
        const eventDate = new Date(event.date);
        const eventDateStr = eventDate.toISOString().split('T')[0];
        
        // If event is today, check if start time is in the future (or if no start time, include it)
        if (eventDateStr === todayStr) {
          if (!event.start_time) return true; // Include all-day events
          return event.start_time > currentTime;
        }
        // If event is in the future, include it
        return eventDateStr > todayStr;
      });

      renderEventsList(upcomingEvents);
      return;
    }

    const { data, error } = await query
      .order('date', { ascending: true })
      .order('start_time', { ascending: true })
      .limit(20);

    if (error) {
      console.error('Error loading events:', error);
      // If table doesn't exist, show empty state
      if (error.code === 'PGRST116' || error.message.includes('does not exist')) {
        renderEventsList([]);
        return;
      }
      eventsList.innerHTML = `
        <div class="px-4 py-8 text-center text-red-500 text-xs">
          <p>Error loading events</p>
        </div>
      `;
      return;
    }

    if (error) {
      throw error;
    }

    const events = data || [];
    
    // Filter to only show truly upcoming events (today's events must have start_time > current time)
    const upcomingEvents = events.filter(event => {
      const eventDate = new Date(event.date);
      const eventDateStr = eventDate.toISOString().split('T')[0];
      
      // If event is today, check if start time is in the future (or if no start time, include it)
      if (eventDateStr === todayStr) {
        if (!event.start_time) return true; // Include all-day events
        return event.start_time > currentTime;
      }
      // If event is in the future, include it
      return eventDateStr > todayStr;
    });

    renderEventsList(upcomingEvents);
  } catch (error) {
    console.error('Error loading upcoming events:', error);
    const eventsList = document.getElementById('eventsList');
    if (eventsList) {
      eventsList.innerHTML = `
        <div class="px-4 py-8 text-center text-red-500 text-xs">
          <p>Error loading events</p>
        </div>
      `;
    }
  }
}

function renderEventsList(events) {
  const eventsList = document.getElementById('eventsList');
  if (!eventsList) return;

  if (events.length === 0) {
    eventsList.innerHTML = `
      <div class="px-4 py-8 text-center text-gray-500 text-xs">
        <svg class="w-12 h-12 mx-auto mb-2 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
        </svg>
        <p class="font-medium text-gray-700 mb-1">No upcoming events</p>
        <p class="text-gray-500">Events will appear here when scheduled</p>
      </div>
    `;
    return;
  }

  const typeColors = {
    session: 'bg-blue-100 text-blue-800',
    meeting: 'bg-purple-100 text-purple-800',
    feedback: 'bg-primary/10 text-primary',
    training: 'bg-orange-100 text-orange-800'
  };

  const typeLabels = {
    session: 'Session',
    meeting: 'Meeting',
    feedback: 'Feedback',
    training: 'Training'
  };

  eventsList.innerHTML = events.map(event => {
    const eventDate = new Date(event.date);
    const today = new Date();
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    let dateDisplay = '';
    if (eventDate.toDateString() === today.toDateString()) {
      dateDisplay = 'Today';
    } else if (eventDate.toDateString() === tomorrow.toDateString()) {
      dateDisplay = 'Tomorrow';
    } else {
      dateDisplay = eventDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }

    const timeDisplay = event.start_time && event.end_time 
      ? `${event.start_time.substring(0, 5)} - ${event.end_time.substring(0, 5)}`
      : event.start_time 
        ? `${event.start_time.substring(0, 5)}`
        : '';

    return `
      <div class="px-4 py-3 hover:bg-gray-50 transition-colors">
        <div class="flex items-start gap-3">
          <div class="flex-shrink-0 mt-0.5">
            <div class="w-10 h-10 rounded-lg ${typeColors[event.type] || 'bg-gray-100 text-gray-800'} flex items-center justify-center">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
              </svg>
            </div>
          </div>
          <div class="flex-1 min-w-0">
            <div class="flex items-start justify-between gap-2 mb-1">
              <div class="flex-1 min-w-0">
                <h4 class="text-xs font-semibold text-gray-900 truncate">${escapeHtml(event.title)}</h4>
                <span class="inline-flex items-center px-2 py-0.5 rounded text-[10px] font-semibold mt-1 ${typeColors[event.type] || 'bg-gray-100 text-gray-800'}">
                  ${typeLabels[event.type] || event.type}
                </span>
              </div>
              ${event.meet_link ? `
                <a href="${escapeHtml(event.meet_link)}" target="_blank" rel="noopener noreferrer" 
                   class="flex-shrink-0 px-2 py-1 bg-blue-600 text-white text-[10px] font-semibold rounded hover:bg-blue-700 transition-colors flex items-center gap-1"
                   onclick="event.stopPropagation()"
                   title="Join Google Meet">
                  <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                  </svg>
                  Join
                </a>
              ` : ''}
            </div>
            <div class="flex items-center gap-3 text-[10px] text-gray-600 mt-1.5 flex-wrap">
              <span class="flex items-center gap-1">
                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                </svg>
                ${dateDisplay}
              </span>
              ${timeDisplay ? `
                <span class="flex items-center gap-1">
                  <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                  </svg>
                  ${timeDisplay}
                </span>
              ` : ''}
            </div>
            ${event.description ? `
              <p class="text-[10px] text-gray-500 mt-1.5 line-clamp-2">${escapeHtml(event.description)}</p>
            ` : ''}
          </div>
        </div>
      </div>
    `;
  }).join('');
}

// Grid modal functions
function showGrid() {
  const modal = document.getElementById('gridModal');
  if (!modal) return;
  
  modal.classList.remove('opacity-0', 'invisible');
  modal.classList.add('opacity-100', 'visible');
}

function hideGrid() {
  const modal = document.getElementById('gridModal');
  if (!modal) return;
  
  modal.classList.remove('opacity-100', 'visible');
  modal.classList.add('opacity-0', 'invisible');
}

// Avatar logout menu functions
function hideAvatarLogout() {
  const menu = document.getElementById('avatarLogoutMenu');
  if (!menu) return;
  
  menu.classList.remove('opacity-100', 'visible');
  menu.classList.add('opacity-0', 'invisible');
}

function handleNotificationClick(notificationId) {
  const notification = notifications.find(n => n.id === notificationId);
  if (!notification) return;

  // Hide modal
  hideNotifications();

  // Navigate based on type
  if (notification.type === 'assignment' && notification.assignmentId) {
    viewAudit(notification.assignmentId);
  } else if ((notification.type === 'reversal' || notification.type === 'reversal_status_update') && notification.auditId && notification.tableName) {
    // Navigate to audit view for reversal
    window.location.href = `/audit-view.html?id=${notification.auditId}&table=${notification.tableName}`;
  }
}

// Test notification function - can be called from browser console
// Usage: testNotification('info', 'Test Title', 'Test Body')
async function testNotification(type = 'info', title = 'Test Notification', body = 'This is a test notification') {
  try {
    const response = await fetch('/api/notifications/test', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        type,
        title,
        body,
      }),
    });

    if (!response.ok) {
      const error = await response.json();
      console.error('Failed to create test notification:', error);
      alert(`Failed to create notification: ${error.error || 'Unknown error'}`);
      return;
    }

    const result = await response.json();
    alert(` Test notification created successfully!\n\nTitle: ${result.data.title}\nType: ${result.data.type}`);
    
    // Reload notifications to show the new one
    notificationsLoaded = false;
    await loadNotifications();
  } catch (error) {
    console.error('Error creating test notification:', error);
    alert(`Error: ${error.message}`);
  }
}

// Make testNotification available globally for console access
window.testNotification = testNotification;
</script>

<!-- Notification Consent Modal -->
<script type="module">
  import { NotificationConsentManager } from '/js/features/notifications/presentation/notification-consent-manager.js';
  import { getSecureSupabase } from '/js/utils/secure-supabase.js';

  // Initialize notification consent manager after user is authenticated
  // IMPORTANT: This runs in the background and should NOT block data loading
  async function initializeNotificationConsent() {
    try {
      // Wait for Supabase to be ready (non-blocking check)
      if (!window.supabaseReady) {
        await new Promise((resolve) => {
          if (window.supabaseReady) {
            resolve(true);
          } else {
            window.addEventListener('supabaseReady', resolve, { once: true });
            setTimeout(resolve, 5000); // Timeout after 5 seconds
          }
        });
      }

      // Get authenticated user
      const supabase = await getSecureSupabase();
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        return;
      }

      // Check if this is a new device (using sessionStorage flag)
      const isNewDevice = sessionStorage.getItem('isNewDeviceLogin') === 'true' || 
                         !localStorage.getItem(`device_${user.id}`);

      // Initialize consent manager
      const consentManager = new NotificationConsentManager();
      
      // Check and show consent if needed (non-blocking - don't await)
      consentManager.checkAndShowConsent(user.id, isNewDevice)
        .then(() => {
          // Mark device as known after consent check completes
          if (isNewDevice) {
            localStorage.setItem(`device_${user.id}`, 'true');
          }
        })
        .catch(err => console.error('Error in notification consent check:', err));
      
    } catch (error) {
      console.error('Error initializing notification consent:', error);
      // Don't block page load on notification consent errors
    }
  }

  // Schedule notification consent to run AFTER data loading completes
  // Use requestIdleCallback if available, otherwise use a longer timeout
  function scheduleNotificationConsent() {
    // Wait for homepage data to load first (listen for custom event or use delay)
    // Using a 3-second delay ensures data loading has started/completed
    const runWhenIdle = () => {
      if (typeof requestIdleCallback === 'function') {
        // Run when browser is idle (data loading likely complete)
        requestIdleCallback(() => {
          initializeNotificationConsent();
        }, { timeout: 5000 }); // Max 5 second wait
      } else {
        // Fallback: run after short delay
        setTimeout(initializeNotificationConsent, 500);
      }
    };
    
    // Wait 3 seconds to ensure data loading has priority
    setTimeout(runWhenIdle, 3000);
  }

  // Initialize after DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', scheduleNotificationConsent);
  } else {
    scheduleNotificationConsent();
  }
</script>

<!-- Include notification consent modal HTML -->
<div id="notificationConsentModal" class="notification-consent-overlay">
  <div class="notification-consent-dialog">
    <div class="notification-consent-header">
      <div class="notification-consent-icon">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z" fill="currentColor"/>
        </svg>
      </div>
      <h2 class="notification-consent-title">Enable Notifications</h2>
    </div>
    
    <div class="notification-consent-body">
      <p class="notification-consent-message">
        Stay updated with important alerts and updates. Choose how you'd like to receive notifications:
      </p>
      
      <div class="notification-channels">
        <label class="channel-option">
          <input type="checkbox" id="channelWeb" checked>
          <span class="channel-label">
            <strong>Browser/Web Notifications</strong>
            <span class="channel-description">Receive notifications in your browser</span>
          </span>
        </label>
        
        <label class="channel-option">
          <input type="checkbox" id="channelEmail" checked>
          <span class="channel-label">
            <strong>Email Notifications</strong>
            <span class="channel-description">Receive notifications via email</span>
          </span>
        </label>
        
        <label class="channel-option disabled">
          <input type="checkbox" id="channelClickUp" disabled>
          <span class="channel-label">
            <strong>ClickUp Integration</strong>
            <span class="channel-description">Coming soon</span>
          </span>
        </label>
      </div>
    </div>
    
    <div class="notification-consent-actions">
      <button id="allowNotificationsBtn" class="notification-consent-btn primary">
        Allow Notifications
      </button>
      <button id="savePreferencesBtn" class="notification-consent-btn secondary">
        Save Preferences
      </button>
      <button id="skipConsentBtn" class="notification-consent-btn skip">
        Skip for now
      </button>
    </div>
  </div>
</div>

<style>
.notification-consent-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
  backdrop-filter: blur(0.25rem);
}

.notification-consent-overlay.show {
  opacity: 1;
  visibility: visible;
}

.notification-consent-dialog {
  background: white;
  border-radius: 1rem;
  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  max-width: 28rem;
  width: 90%;
  max-height: 90vh;
  overflow-y: auto;
  transform: scale(0.9);
  transition: transform 0.3s ease;
  margin: 1.25rem;
  padding: 1.5rem;
}

.notification-consent-overlay.show .notification-consent-dialog {
  transform: scale(1);
}

.notification-consent-header {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-bottom: 1.5rem;
  gap: 0.75rem;
}

.notification-consent-icon {
  width: 3rem;
  height: 3rem;
  border-radius: 50%;
  background-color: rgba(59, 130, 246, 0.1);
  display: flex;
  align-items: center;
  justify-content: center;
  color: #3b82f6;
}

.notification-consent-title {
  font-size: 1.5rem;
  font-weight: 700;
  color: #111827;
  margin: 0;
  text-align: center;
}

.notification-consent-body {
  margin-bottom: 1.5rem;
}

.notification-consent-message {
  font-size: 0.875rem;
  color: #6b7280;
  line-height: 1.5;
  margin: 0 0 1.25rem 0;
  text-align: center;
}

.notification-channels {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.channel-option {
  display: flex;
  align-items: flex-start;
  gap: 0.75rem;
  padding: 0.75rem;
  border: 1px solid #e5e7eb;
  border-radius: 0.5rem;
  cursor: pointer;
  transition: background-color 0.2s, border-color 0.2s;
}

.channel-option:hover:not(.disabled) {
  background-color: #f9fafb;
  border-color: #d1d5db;
}

.channel-option.disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.channel-option input[type="checkbox"] {
  margin-top: 0.125rem;
  cursor: pointer;
}

.channel-option.disabled input[type="checkbox"] {
  cursor: not-allowed;
}

.channel-label {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  flex: 1;
}

.channel-label strong {
  font-size: 0.875rem;
  font-weight: 600;
  color: #111827;
}

.channel-description {
  font-size: 0.75rem;
  color: #6b7280;
}

.notification-consent-actions {
  display: flex;
  flex-direction: column;
  gap: 0.625rem;
}

.notification-consent-btn {
  padding: 0.625rem 1.25rem;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  font-weight: 600;
  border: none;
  cursor: pointer;
  transition: all 0.2s;
}

.notification-consent-btn.primary {
  background-color: #3b82f6;
  color: white;
}

.notification-consent-btn.primary:hover {
  background-color: #2563eb;
}

.notification-consent-btn.secondary {
  background-color: #f3f4f6;
  color: #374151;
}

.notification-consent-btn.secondary:hover {
  background-color: #e5e7eb;
}

.notification-consent-btn.skip {
  background-color: transparent;
  color: #6b7280;
  text-decoration: underline;
}

.notification-consent-btn.skip:hover {
  color: #374151;
}
</style>
</body>
</html>