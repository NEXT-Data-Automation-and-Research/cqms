# Cursor Rules for Web QMS Migration Project

## File Size Limit - Modularity Enforcement

**CRITICAL RULE: Maximum 250 Lines Per File**

Every code file in this project MUST NOT exceed 250 lines of code. This rule applies to:
- TypeScript files (`.ts`, `.tsx`)
- JavaScript files (`.js`, `.jsx`)
- CSS files (`.css`)
- HTML files (`.html`)
- Any other source code files

### Why This Rule Exists
- **Modularity**: Smaller files are easier to understand, maintain, and test
- **Single Responsibility**: Forces each file to have a focused, single purpose
- **Code Reusability**: Encourages breaking down large files into reusable components/modules
- **Team Collaboration**: Smaller files reduce merge conflicts and make code reviews easier
- **Maintainability**: Easier to locate and fix bugs in smaller, focused files

### Enforcement Guidelines

1. **Before Writing Code**: 
   - If you're about to create or modify a file that would exceed 250 lines, break it down into smaller modules first
   - Plan the file structure to stay within the limit

2. **When Refactoring Existing Code**:
   - If a file exceeds 250 lines, it MUST be refactored immediately
   - Extract functions, classes, or components into separate files
   - Use proper imports/exports to maintain functionality
   - Consider creating utility modules, helper functions, or sub-components

3. **Refactoring Strategies**:
   - **Functions/Utilities**: Extract helper functions into separate utility files
   - **Classes**: Split large classes into smaller, focused classes or use composition
   - **Components**: Break down large components into smaller sub-components
   - **Configuration**: Move constants, types, and configuration to separate files
   - **Business Logic**: Separate business logic from presentation/UI code

4. **What Counts as "Lines"**:
   - All lines including comments, blank lines, and code
   - Empty lines between code blocks count toward the limit
   - This encourages concise, well-organized code

### Exceptions
- **Generated files** (e.g., in `dist/`, `node_modules/`) are exempt
- **Migration SQL files** may exceed the limit if necessary for atomic migrations
- **Configuration files** (e.g., `package.json`, `tsconfig.json`) are exempt

### AI Assistant Instructions
When working on this codebase:
- **Always check file line count** before making changes
- **Refuse to add code** that would push a file over 250 lines
- **Proactively suggest refactoring** if a file is approaching the limit (e.g., >200 lines)
- **Break down large implementations** into smaller, focused modules
- **Suggest appropriate file structure** when creating new features
- **For existing large files**: Immediately refactor into modules when discovered
- **Modular structure**: Each module should have a single, clear responsibility
- **Import/Export pattern**: Use ES modules with clear exports for reusability

### Example Refactoring Pattern

**Before (300+ lines - VIOLATION):**
```typescript
// feature.ts - TOO LARGE
export class Feature {
  // 300+ lines of code
}
```

**After (Compliant):**
```typescript
// feature.ts - Main class (50 lines)
import { FeatureValidator } from './feature-validator';
import { FeatureProcessor } from './feature-processor';
import { FeatureRenderer } from './feature-renderer';

export class Feature {
  // Focused implementation
}

// feature-validator.ts - Validation logic (80 lines)
export class FeatureValidator { }

// feature-processor.ts - Business logic (100 lines)
export class FeatureProcessor { }

// feature-renderer.ts - UI/rendering (70 lines)
export class FeatureRenderer { }
```

### Verification
- Use `wc -l` or your editor's line count feature to verify file sizes
- Consider adding a pre-commit hook to enforce this rule automatically

---

**Remember: If a file exceeds 250 lines, it's a code smell indicating the need for refactoring and better modularity.**

## Database Abstraction Architecture

**CRITICAL: All database access MUST go through the abstraction layer for database portability.**

### Database Configuration

**Location**: `src/core/config/database-config.ts`

- **Purpose**: Centralized database type configuration
- **Configuration**: Set `DATABASE_TYPE` environment variable (`supabase`, `postgresql`, `mysql`)
- **Default**: `supabase` if not specified
- **Usage**: Never hardcode database type - always use `DatabaseConfig.get()`

### Database Factory

**Location**: `src/infrastructure/database-factory.ts`

- **Purpose**: Factory for creating database clients
- **Usage**: `const db = DatabaseFactory.createClient();` (uses configured type)
- **Rules**:
  - Always use `DatabaseFactory.createClient()` - never instantiate adapters directly
  - Factory reads from `DatabaseConfig` automatically
  - Can override type: `DatabaseFactory.createClient('postgresql')` for testing

### Database Interfaces

**Location**: `src/core/database/`

- **IDatabaseClient**: Interface for all database clients
- **IQueryBuilder**: Interface for query building
- **Rules**:
  - All repositories MUST use `IDatabaseClient` interface
  - Never import database-specific adapters in repositories
  - All queries MUST use `IQueryBuilder` interface

### Database Adapters

**Location**: `src/infrastructure/database/{database-type}/`

- **Purpose**: Database-specific implementations
- **Structure**: Each database has its own adapter directory
- **Current**: `supabase/` (SupabaseClientAdapter, SupabaseQueryBuilder)
- **Future**: `postgresql/`, `mysql/` adapters follow same pattern
- **Rules**:
  - Each adapter MUST implement `IDatabaseClient` and `IQueryBuilder`
  - Adapters are ONLY used by `DatabaseFactory`
  - Never import adapters in feature code

### Switching Databases

To switch databases:
1. Set `DATABASE_TYPE` environment variable
2. Implement adapter for new database type
3. Register in `DatabaseFactory.createClient()`
4. All existing code works without changes!

## Supabase Authentication Enforcement

**CRITICAL: ALL Supabase calls MUST use the authenticated helper. No direct Supabase client access allowed.**

### Authenticated Supabase Helper

**Location**: `src/utils/authenticated-supabase.ts`

- **Purpose**: Enforce authentication on ALL Supabase database operations
- **Rule**: This is the ONLY way to access Supabase in the application
- **Usage**: `import { getAuthenticatedSupabase } from './utils/authenticated-supabase.js'`

### Authentication Rules

1. **MANDATORY**: All Supabase database calls MUST use `getAuthenticatedSupabase()`
2. **NO DIRECT ACCESS**: Never use `getSupabase()` or `createClient()` directly for database operations
3. **AUTHENTICATION REQUIRED**: All database operations automatically verify authentication
4. **AUTH METHODS ALLOWED**: `supabase.auth.*` methods are allowed (for login/logout)
5. **STORAGE REQUIRES AUTH**: Storage operations also require authentication

### Usage Pattern

```typescript
// ✅ CORRECT - Use authenticated helper
import { getAuthenticatedSupabase } from './utils/authenticated-supabase.js';

async function fetchUsers() {
  const supabase = await getAuthenticatedSupabase();
  const { data, error } = await supabase.from('users').select('*');
  return data;
}

// ❌ WRONG - Direct Supabase access (NOT ALLOWED)
import { getSupabase } from './utils/supabase-init.js';
const supabase = getSupabase(); // VIOLATION - bypasses authentication
```

### Exceptions

- **Server-side operations**: Use `getServerSupabase()` from `src/core/config/server-supabase.ts` (service role key, bypasses RLS)
- **Auth operations**: `supabase.auth.*` methods are allowed through authenticated helper
- **Initialization**: `initSupabase()` is allowed for setup only

### Enforcement

- **Code Review**: Reject any PR that uses direct Supabase client access
- **Linting**: Consider adding ESLint rule to prevent direct `getSupabase()` usage
- **Documentation**: All examples must use `getAuthenticatedSupabase()`

### Benefits

1. **Security by Default**: All operations require authentication
2. **Consistent Pattern**: Single way to access Supabase throughout the app
3. **Error Prevention**: Prevents accidental unauthenticated calls
4. **Audit Trail**: All database operations are logged with user context

---

## Repository Pattern

**CRITICAL: All repositories MUST extend BaseRepository and follow the repository pattern.**

### Base Repository

**Location**: `src/core/repository/base-repository.ts`

- **Purpose**: Common functionality for all repositories
- **Features**:
  - Error handling wrapper
  - Caching integration
  - Query execution helpers
- **Usage**: `export class MyRepository extends BaseRepository { }`

### Repository Rules

1. **Extend BaseRepository**: All repositories MUST extend `BaseRepository`
2. **Constructor**: Accept `IDatabaseClient` via dependency injection
3. **Table Name**: Pass table name to base constructor
4. **Error Handling**: Use `executeQuery()` for all database operations
5. **Caching**: Use `getCachedOrFetch()` for cacheable data
6. **No Business Logic**: Repositories ONLY handle data access

### Repository Example

```typescript
// infrastructure/my-repository.ts
import { BaseRepository } from '../../../core/repository/base-repository.js';
import { IDatabaseClient } from '../../../core/database/database-client.interface.js';
import type { MyEntity } from '../domain/entities.js';

export class MyRepository extends BaseRepository {
  constructor(db: IDatabaseClient) {
    super(db, 'my_table');
  }

  async findById(id: string): Promise<MyEntity | null> {
    return this.executeQuery(
      async () => this.db
        .from(this.getTableName())
        .select('*')
        .eq('id', id)
        .single()
        .execute<MyEntity>(),
      `Failed to find entity ${id}`
    );
  }
}
```

## Service Pattern

**CRITICAL: All services MUST extend BaseService and contain business logic only.**

### Base Service

**Location**: `src/core/service/base-service.ts`

- **Purpose**: Common functionality for all services
- **Features**:
  - Input validation helpers
  - Error handling wrapper
  - Retry logic for async operations
- **Usage**: `export class MyService extends BaseService { }`

### Service Rules

1. **Extend BaseService**: All services MUST extend `BaseService`
2. **Business Logic Only**: Services contain business rules and calculations
3. **Dependencies**: Accept repositories via constructor (dependency injection)
4. **No Data Access**: Services NEVER directly access database
5. **No UI Code**: Services NEVER manipulate DOM or handle events
6. **Validation**: Use `validateInput()` for input validation
7. **Error Handling**: Use `executeBusinessLogic()` for error handling

### Service Example

```typescript
// application/my-service.ts
import { BaseService } from '../../../core/service/base-service.js';
import { MyRepository } from '../infrastructure/my-repository.js';
import type { MyEntity } from '../domain/entities.js';

export class MyService extends BaseService {
  constructor(private repository: MyRepository) {
    super();
  }

  async processEntity(id: string): Promise<MyEntity> {
    this.validateInput(id, (id) => id.length > 0 || 'ID is required');
    
    return this.executeBusinessLogic(
      async () => {
        const entity = await this.repository.findById(id);
        if (!entity) {
          throw createBusinessError('Entity not found');
        }
        // Business logic here
        return entity;
      },
      'Failed to process entity'
    );
  }
}
```

## Dependency Injection

**CRITICAL: Use DI container for managing dependencies and promoting testability.**

### DI Container

**Location**: `src/core/di/container.ts`

- **Purpose**: Manage service dependencies
- **Features**: Singleton and transient service registration
- **Usage**: Register services, then resolve via `container.get()`

### DI Rules

1. **Register Dependencies**: Register all services in container
2. **Resolve in Controllers**: Controllers resolve dependencies from container
3. **Testing**: Easy to mock dependencies by replacing registrations
4. **Singleton by Default**: Services are singletons unless marked transient

### DI Example

```typescript
// Setup
const container = new DIContainer();
container.register('database', () => DatabaseFactory.createClient());
container.register('repository', (c) => new MyRepository(c.get('database')));
container.register('service', (c) => new MyService(c.get('repository')));

// Usage
const service = container.get<MyService>('service');
```

## Error Handling

**CRITICAL: All errors MUST use AppError for consistent error handling.**

### Error Types

**Location**: `src/core/errors/app-error.ts`

- **AppError**: Base error class for all application errors
- **ErrorCode**: Enum of error codes
- **Helper Functions**: `createDatabaseError()`, `createValidationError()`, `createBusinessError()`

### Error Handling Rules

1. **Use AppError**: Never throw plain `Error` - always use `AppError` or helpers
2. **Error Codes**: Use appropriate `ErrorCode` enum value
3. **Error Context**: Include relevant details in error
4. **Error Propagation**: Let errors bubble up - handle at appropriate layer
5. **Logging**: Errors are logged automatically by base classes

### Error Example

```typescript
import { createDatabaseError, createValidationError } from '../../../core/errors/app-error.js';

// In repository
if (error) {
  throw createDatabaseError('Failed to load data', error);
}

// In service
if (!data) {
  throw createValidationError('Data is required', { field: 'data' });
}
```

## Caching Architecture

**CRITICAL: Use CacheManager for all caching operations.**

### Cache Manager

**Location**: `src/core/cache/cache-manager.ts`

- **Purpose**: Centralized caching abstraction
- **Storage Types**: `session`, `local`, `memory`
- **Features**: TTL support, key prefixing, automatic expiration

### Caching Rules

1. **Use CacheManager**: Never use `sessionStorage`/`localStorage` directly
2. **Repository Level**: Caching happens in repositories
3. **TTL**: Always set appropriate TTL for cached data
4. **Cache Keys**: Use descriptive, namespaced keys
5. **Invalidation**: Invalidate cache on data mutations

### Caching Example

```typescript
// In repository
async loadUsers(): Promise<User[]> {
  return this.getCachedOrFetch(
    'users_list',
    async () => {
      const { data } = await this.db.from('users').select('*').execute();
      return data || [];
    },
    300000 // 5 minutes TTL
  );
}

// Invalidate on update
async updateUser(id: string, data: User): Promise<void> {
  await this.executeQuery(/* ... */);
  this.invalidateCache('users_list');
}
```

## Scalability Patterns

### Horizontal Scalability

1. **Stateless Services**: All services are stateless (no instance state)
2. **Database Abstraction**: Easy to scale database independently
3. **Caching**: Reduces database load
4. **Error Handling**: Graceful degradation

### Vertical Scalability

1. **Modular Architecture**: Easy to optimize individual components
2. **Base Classes**: Common optimizations in one place
3. **Dependency Injection**: Easy to swap implementations

### Code Reusability

1. **Base Classes**: Common functionality in base classes
2. **Interfaces**: Consistent contracts across implementations
3. **Utilities**: Shared utilities in `src/utils/`
4. **Core Modules**: Reusable core modules in `src/core/`

## Architecture Summary

### Core Principles

1. **Database Portability**: Switch databases via configuration
2. **Layer Separation**: Strict Clean Architecture layers
3. **Dependency Injection**: Testable, maintainable code
4. **Error Handling**: Consistent error management
5. **Caching**: Centralized caching strategy
6. **Modularity**: 250-line file limit enforces modularity

### File Organization

```
src/
├── core/                    # Core abstractions (reusable)
│   ├── config/             # Configuration (database, etc.)
│   ├── database/           # Database interfaces
│   ├── errors/             # Error handling
│   ├── cache/              # Caching
│   ├── repository/         # Base repository
│   ├── service/            # Base service
│   └── di/                 # Dependency injection
├── infrastructure/         # External adapters
│   └── database/          # Database adapters
├── features/              # Feature modules (Clean Architecture)
└── utils/                 # Shared utilities
```

### When Creating New Code

1. **Repository**: Extend `BaseRepository`, use `IDatabaseClient`
2. **Service**: Extend `BaseService`, accept repository via constructor
3. **Error**: Use `AppError` or helper functions
4. **Cache**: Use `CacheManager` via base repository methods
5. **Database**: Use `DatabaseFactory.createClient()`
6. **DI**: Register in container, resolve in controllers

---

**Remember: Architecture decisions prioritize scalability, reusability, and database portability. Follow these patterns consistently.**

## Security Rules & Best Practices

**CRITICAL: All security rules MUST be followed. See `SECURITY_RULES.md` for comprehensive security guidelines.**

### Quick Security Checklist

Before committing any code, verify:
- [ ] No `innerHTML` usage - Use `safeSetHTML()` from `src/utils/html-sanitizer.js`
- [ ] No `select('*')` queries - Use field whitelists from `src/core/constants/field-whitelists.ts`
- [ ] All user input is sanitized - Use `sanitizeString()` from `src/api/utils/validation.ts`
- [ ] CSRF tokens in POST/PUT/DELETE requests - Middleware applied automatically
- [ ] No `console.log` - Use `logInfo/logError/logWarn` from `src/utils/logging-helper.js`
- [ ] All database access uses `getAuthenticatedSupabase()` - Never use `getSupabase()` directly
- [ ] Error messages are generic (no sensitive data) - Use `AppError` from `src/core/errors/app-error.ts`
- [ ] HTML content is sanitized - Use DOMPurify via `safeSetHTML()`
- [ ] Only safe environment variables exposed to client - Check `getSafeEnvVars()` in server

### Security Rules Reference

**See `SECURITY_RULES.md` for:**
- Detailed security rules for each vulnerability type
- Code examples (correct vs wrong usage)
- Implementation details and file locations
- Enforcement guidelines
- Security violation examples
- Quick reference checklist

### Key Security Files

- **HTML Sanitization**: `src/utils/html-sanitizer.ts`
- **Field Whitelists**: `src/core/constants/field-whitelists.ts`
- **Input Validation**: `src/api/utils/validation.ts`
- **CSRF Protection**: `src/api/middleware/csrf.middleware.ts`
- **Error Handling**: `src/api/middleware/error-handler.middleware.ts`
- **Structured Logging**: `src/utils/logging-helper.js`
- **Authenticated Supabase**: `src/utils/authenticated-supabase.ts`

### Security Rating Goals

Target security ratings (all 9.0+/10):
- XSS Prevention: 9.5/10
- Data Protection: 9.5/10
- Input Validation: 9.0/10
- CSRF Protection: 9.0/10
- Error Handling: 9.0/10
- Logging Security: 9.5/10
- Authentication: 9.5/10
- **Overall Security: 9.3/10+**

---

**Remember: Security is not optional. Every line of code should follow the security rules in `SECURITY_RULES.md`.**

